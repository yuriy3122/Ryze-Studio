// <auto-generated/>

namespace SharpDX.DXGI
{
    /// <summary>
    /// Functions
    /// </summary>
    static partial class DXGI
    {
                ///<summary>Constant CreateFactoryDebug</summary>
        ///<unmanaged>DXGI_CREATE_FACTORY_DEBUG</unmanaged>
        public const int CreateFactoryDebug = 1;
        /// <summary>
        /// <p>Creates a DXGI 1.1 factory that you can use to generate other  DXGI objects.</p>
        /// </summary>
        /// <param name = "riid"><dd>  <p>The globally unique identifier (<see cref = "System.Guid"/>) of the <strong><see cref = "SharpDX.DXGI.Factory1"/></strong> object referenced by  the <em>ppFactory</em> parameter.</p> </dd></param>
        /// <param name = "factoryOut"><dd>  <p>Address of a reference to an <strong><see cref = "SharpDX.DXGI.Factory1"/></strong> object.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <p>Use a DXGI 1.1 factory to generate objects that <strong>enumerate adapters</strong>,  <strong>create swap chains</strong>, and <strong>associate a window</strong> with  the alt+enter key sequence for toggling to and from the full-screen display mode.  </p><p>If the <strong>CreateDXGIFactory1</strong> function succeeds, the reference count on the <strong><see cref = "SharpDX.DXGI.Factory1"/></strong> interface is incremented. To avoid a memory leak, when you finish using the interface, call the <strong>IDXGIFactory1::Release</strong> method to release the interface.</p><p>This entry point is not supported by DXGI 1.0, which shipped in Windows?Vista and Windows Server?2008. DXGI 1.1 support is required, which is available on  Windows?7, Windows Server?2008?R2, and as an update to Windows?Vista with Service Pack?2 (SP2) (KB 971644) and Windows Server?2008 (KB 971512).</p><strong>Note</strong>??Do not mix the use of DXGI 1.0 (<strong><see cref = "SharpDX.DXGI.Factory"/></strong>) and DXGI 1.1 (<strong><see cref = "SharpDX.DXGI.Factory1"/></strong>) in an application. Use <strong><see cref = "SharpDX.DXGI.Factory"/></strong> or <strong><see cref = "SharpDX.DXGI.Factory1"/></strong>, but not both in an application.?<strong>Note</strong>??<strong>CreateDXGIFactory1</strong> fails if your app's <strong>DllMain</strong> function calls it. For more info about how DXGI responds from <strong>DllMain</strong>, see DXGI Responses from DLLMain.?<strong>Note</strong>??Starting with Windows?8, all DXGI factories (regardless if they were created with <strong>CreateDXGIFactory</strong> or <strong>CreateDXGIFactory1</strong>) enumerate adapters identically. The enumeration order of adapters, which you retrieve with <strong>IDXGIFactory::EnumAdapters</strong> or <strong>IDXGIFactory1::EnumAdapters1</strong>, is as follows: <ul> <li>Adapter with the output on which the desktop primary is displayed. This adapter corresponds with an index of zero.</li> <li>Adapters with outputs.</li> <li>Adapters without outputs.</li> </ul>?
        /// </remarks>
        /// <doc-id>ff471318</doc-id>
        /// <unmanaged>HRESULT CreateDXGIFactory1([In] const GUID&amp; riid,[Out] void** ppFactory)</unmanaged>
        /// <unmanaged-short>CreateDXGIFactory1</unmanaged-short>
        public static unsafe void CreateDXGIFactory1(System.Guid riid, out System.IntPtr factoryOut)
        {
            SharpDX.Result __result__;
            fixed (void *factoryOut_ = &factoryOut)
                __result__ = CreateDXGIFactory1_(&riid, factoryOut_);
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("dxgi.dll", EntryPoint = "CreateDXGIFactory1", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int CreateDXGIFactory1_(void *param0, void *param1);
        /// <summary>
        /// <p>Creates a DXGI 1.3 factory that you can use to generate other  DXGI objects.</p><p>In Windows?8, any DXGI factory created while DXGIDebug.dll was present on the system would load and use it. Starting in Windows?8.1, apps explicitly request that DXGIDebug.dll be loaded instead. Use <strong>CreateDXGIFactory2</strong> and specify the <see cref = "CreateFactoryDebug"/> flag to request DXGIDebug.dll; the DLL will be loaded if it is present on the system.</p>
        /// </summary>
        /// <param name = "flags"><dd>  <p>Valid values include the <strong><see cref = "CreateFactoryDebug"/> (0x01)</strong> flag, and zero.</p> <strong>Note</strong>??This flag will be set by the D3D runtime if:<ul> <li>The system creates an implicit factory during device creation.</li> <li>The D3D11_CREATE_DEVICE_DEBUG flag is specified during device creation, for example using <strong>D3D11CreateDevice</strong> (or the swapchain method, or the Direct3D 10 equivalents).</li> </ul>  ? </dd></param>
        /// <param name = "riid"><dd>  <p>The globally unique identifier (<see cref = "System.Guid"/>) of the <strong><see cref = "SharpDX.DXGI.Factory2"/></strong> object referenced by  the <em>ppFactory</em> parameter.</p> </dd></param>
        /// <param name = "factoryOut"><dd>  <p>Address of a reference to an <strong><see cref = "SharpDX.DXGI.Factory2"/></strong> object.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <p>This function accepts a flag indicating whether DXGIDebug.dll is loaded. The function otherwise behaves identically to <strong>CreateDXGIFactory1</strong>.</p>
        /// </remarks>
        /// <doc-id>dn268307</doc-id>
        /// <unmanaged>HRESULT CreateDXGIFactory2([In] unsigned int Flags,[In] const GUID&amp; riid,[Out] void** ppFactory)</unmanaged>
        /// <unmanaged-short>CreateDXGIFactory2</unmanaged-short>
        public static unsafe void CreateDXGIFactory2(System.Int32 flags, System.Guid riid, out System.IntPtr factoryOut)
        {
            SharpDX.Result __result__;
            fixed (void *factoryOut_ = &factoryOut)
                __result__ = CreateDXGIFactory2_(flags, &riid, factoryOut_);
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("dxgi.dll", EntryPoint = "CreateDXGIFactory2", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int CreateDXGIFactory2_(int param0, void *param1, void *param2);
    }

    /// <summary>
    /// Functions
    /// </summary>
    public partial class ResultCode
    {
                ///<summary>Constant InvalidCall</summary>
        ///<unmanaged>DXGI_ERROR_INVALID_CALL</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidCall = new SharpDX.ResultDescriptor(unchecked ((int)2289696769UL), "SharpDX.DXGI", "DXGI_ERROR_INVALID_CALL", "InvalidCall");
                ///<summary>Constant NotFound</summary>
        ///<unmanaged>DXGI_ERROR_NOT_FOUND</unmanaged>
        public static readonly SharpDX.ResultDescriptor NotFound = new SharpDX.ResultDescriptor(unchecked ((int)2289696770UL), "SharpDX.DXGI", "DXGI_ERROR_NOT_FOUND", "NotFound");
                ///<summary>Constant MoreData</summary>
        ///<unmanaged>DXGI_ERROR_MORE_DATA</unmanaged>
        public static readonly SharpDX.ResultDescriptor MoreData = new SharpDX.ResultDescriptor(unchecked ((int)2289696771UL), "SharpDX.DXGI", "DXGI_ERROR_MORE_DATA", "MoreData");
                ///<summary>Constant Unsupported</summary>
        ///<unmanaged>DXGI_ERROR_UNSUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor Unsupported = new SharpDX.ResultDescriptor(unchecked ((int)2289696772UL), "SharpDX.DXGI", "DXGI_ERROR_UNSUPPORTED", "Unsupported");
                ///<summary>Constant DeviceRemoved</summary>
        ///<unmanaged>DXGI_ERROR_DEVICE_REMOVED</unmanaged>
        public static readonly SharpDX.ResultDescriptor DeviceRemoved = new SharpDX.ResultDescriptor(unchecked ((int)2289696773UL), "SharpDX.DXGI", "DXGI_ERROR_DEVICE_REMOVED", "DeviceRemoved");
                ///<summary>Constant DeviceHung</summary>
        ///<unmanaged>DXGI_ERROR_DEVICE_HUNG</unmanaged>
        public static readonly SharpDX.ResultDescriptor DeviceHung = new SharpDX.ResultDescriptor(unchecked ((int)2289696774UL), "SharpDX.DXGI", "DXGI_ERROR_DEVICE_HUNG", "DeviceHung");
                ///<summary>Constant DeviceReset</summary>
        ///<unmanaged>DXGI_ERROR_DEVICE_RESET</unmanaged>
        public static readonly SharpDX.ResultDescriptor DeviceReset = new SharpDX.ResultDescriptor(unchecked ((int)2289696775UL), "SharpDX.DXGI", "DXGI_ERROR_DEVICE_RESET", "DeviceReset");
                ///<summary>Constant WasStillDrawing</summary>
        ///<unmanaged>DXGI_ERROR_WAS_STILL_DRAWING</unmanaged>
        public static readonly SharpDX.ResultDescriptor WasStillDrawing = new SharpDX.ResultDescriptor(unchecked ((int)2289696778UL), "SharpDX.DXGI", "DXGI_ERROR_WAS_STILL_DRAWING", "WasStillDrawing");
                ///<summary>Constant FrameStatisticsDisjoint</summary>
        ///<unmanaged>DXGI_ERROR_FRAME_STATISTICS_DISJOINT</unmanaged>
        public static readonly SharpDX.ResultDescriptor FrameStatisticsDisjoint = new SharpDX.ResultDescriptor(unchecked ((int)2289696779UL), "SharpDX.DXGI", "DXGI_ERROR_FRAME_STATISTICS_DISJOINT", "FrameStatisticsDisjoint");
                ///<summary>Constant GraphicsVidpnSourceInUse</summary>
        ///<unmanaged>DXGI_ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE</unmanaged>
        public static readonly SharpDX.ResultDescriptor GraphicsVidpnSourceInUse = new SharpDX.ResultDescriptor(unchecked ((int)2289696780UL), "SharpDX.DXGI", "DXGI_ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE", "GraphicsVidpnSourceInUse");
                ///<summary>Constant DriverInternalError</summary>
        ///<unmanaged>DXGI_ERROR_DRIVER_INTERNAL_ERROR</unmanaged>
        public static readonly SharpDX.ResultDescriptor DriverInternalError = new SharpDX.ResultDescriptor(unchecked ((int)2289696800UL), "SharpDX.DXGI", "DXGI_ERROR_DRIVER_INTERNAL_ERROR", "DriverInternalError");
                ///<summary>Constant Nonexclusive</summary>
        ///<unmanaged>DXGI_ERROR_NONEXCLUSIVE</unmanaged>
        public static readonly SharpDX.ResultDescriptor Nonexclusive = new SharpDX.ResultDescriptor(unchecked ((int)2289696801UL), "SharpDX.DXGI", "DXGI_ERROR_NONEXCLUSIVE", "Nonexclusive");
                ///<summary>Constant NotCurrentlyAvailable</summary>
        ///<unmanaged>DXGI_ERROR_NOT_CURRENTLY_AVAILABLE</unmanaged>
        public static readonly SharpDX.ResultDescriptor NotCurrentlyAvailable = new SharpDX.ResultDescriptor(unchecked ((int)2289696802UL), "SharpDX.DXGI", "DXGI_ERROR_NOT_CURRENTLY_AVAILABLE", "NotCurrentlyAvailable");
                ///<summary>Constant RemoteClientDisconnected</summary>
        ///<unmanaged>DXGI_ERROR_REMOTE_CLIENT_DISCONNECTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor RemoteClientDisconnected = new SharpDX.ResultDescriptor(unchecked ((int)2289696803UL), "SharpDX.DXGI", "DXGI_ERROR_REMOTE_CLIENT_DISCONNECTED", "RemoteClientDisconnected");
                ///<summary>Constant RemoteOufOfMemory</summary>
        ///<unmanaged>DXGI_ERROR_REMOTE_OUTOFMEMORY</unmanaged>
        public static readonly SharpDX.ResultDescriptor RemoteOufOfMemory = new SharpDX.ResultDescriptor(unchecked ((int)2289696804UL), "SharpDX.DXGI", "DXGI_ERROR_REMOTE_OUTOFMEMORY", "RemoteOufOfMemory");
                ///<summary>Constant AccessLost</summary>
        ///<unmanaged>DXGI_ERROR_ACCESS_LOST</unmanaged>
        public static readonly SharpDX.ResultDescriptor AccessLost = new SharpDX.ResultDescriptor(unchecked ((int)2289696806UL), "SharpDX.DXGI", "DXGI_ERROR_ACCESS_LOST", "AccessLost");
                ///<summary>Constant WaitTimeout</summary>
        ///<unmanaged>DXGI_ERROR_WAIT_TIMEOUT</unmanaged>
        public static readonly SharpDX.ResultDescriptor WaitTimeout = new SharpDX.ResultDescriptor(unchecked ((int)2289696807UL), "SharpDX.DXGI", "DXGI_ERROR_WAIT_TIMEOUT", "WaitTimeout");
                ///<summary>Constant SessionDisconnected</summary>
        ///<unmanaged>DXGI_ERROR_SESSION_DISCONNECTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor SessionDisconnected = new SharpDX.ResultDescriptor(unchecked ((int)2289696808UL), "SharpDX.DXGI", "DXGI_ERROR_SESSION_DISCONNECTED", "SessionDisconnected");
                ///<summary>Constant RestrictToOutputStale</summary>
        ///<unmanaged>DXGI_ERROR_RESTRICT_TO_OUTPUT_STALE</unmanaged>
        public static readonly SharpDX.ResultDescriptor RestrictToOutputStale = new SharpDX.ResultDescriptor(unchecked ((int)2289696809UL), "SharpDX.DXGI", "DXGI_ERROR_RESTRICT_TO_OUTPUT_STALE", "RestrictToOutputStale");
                ///<summary>Constant CannotProtectContent</summary>
        ///<unmanaged>DXGI_ERROR_CANNOT_PROTECT_CONTENT</unmanaged>
        public static readonly SharpDX.ResultDescriptor CannotProtectContent = new SharpDX.ResultDescriptor(unchecked ((int)2289696810UL), "SharpDX.DXGI", "DXGI_ERROR_CANNOT_PROTECT_CONTENT", "CannotProtectContent");
                ///<summary>Constant AccessDenied</summary>
        ///<unmanaged>DXGI_ERROR_ACCESS_DENIED</unmanaged>
        public static readonly SharpDX.ResultDescriptor AccessDenied = new SharpDX.ResultDescriptor(unchecked ((int)2289696811UL), "SharpDX.DXGI", "DXGI_ERROR_ACCESS_DENIED", "AccessDenied");
                ///<summary>Constant NameAlreadyExists</summary>
        ///<unmanaged>DXGI_ERROR_NAME_ALREADY_EXISTS</unmanaged>
        public static readonly SharpDX.ResultDescriptor NameAlreadyExists = new SharpDX.ResultDescriptor(unchecked ((int)2289696812UL), "SharpDX.DXGI", "DXGI_ERROR_NAME_ALREADY_EXISTS", "NameAlreadyExists");
                ///<summary>Constant SdkComponentMissing</summary>
        ///<unmanaged>DXGI_ERROR_SDK_COMPONENT_MISSING</unmanaged>
        public static readonly SharpDX.ResultDescriptor SdkComponentMissing = new SharpDX.ResultDescriptor(unchecked ((int)2289696813UL), "SharpDX.DXGI", "DXGI_ERROR_SDK_COMPONENT_MISSING", "SdkComponentMissing");
                ///<summary>Constant NotCurrent</summary>
        ///<unmanaged>DXGI_ERROR_NOT_CURRENT</unmanaged>
        public static readonly SharpDX.ResultDescriptor NotCurrent = new SharpDX.ResultDescriptor(unchecked ((int)2289696814UL), "SharpDX.DXGI", "DXGI_ERROR_NOT_CURRENT", "NotCurrent");
                ///<summary>Constant HwProtectionOufOfMemory</summary>
        ///<unmanaged>DXGI_ERROR_HW_PROTECTION_OUTOFMEMORY</unmanaged>
        public static readonly SharpDX.ResultDescriptor HwProtectionOufOfMemory = new SharpDX.ResultDescriptor(unchecked ((int)2289696816UL), "SharpDX.DXGI", "DXGI_ERROR_HW_PROTECTION_OUTOFMEMORY", "HwProtectionOufOfMemory");
                ///<summary>Constant DynamicCodePolicyViolation</summary>
        ///<unmanaged>DXGI_ERROR_DYNAMIC_CODE_POLICY_VIOLATION</unmanaged>
        public static readonly SharpDX.ResultDescriptor DynamicCodePolicyViolation = new SharpDX.ResultDescriptor(unchecked ((int)2289696817UL), "SharpDX.DXGI", "DXGI_ERROR_DYNAMIC_CODE_POLICY_VIOLATION", "DynamicCodePolicyViolation");
                ///<summary>Constant NonCompositedUi</summary>
        ///<unmanaged>DXGI_ERROR_NON_COMPOSITED_UI</unmanaged>
        public static readonly SharpDX.ResultDescriptor NonCompositedUi = new SharpDX.ResultDescriptor(unchecked ((int)2289696818UL), "SharpDX.DXGI", "DXGI_ERROR_NON_COMPOSITED_UI", "NonCompositedUi");
                ///<summary>Constant ModeChangeInProgress</summary>
        ///<unmanaged>DXGI_ERROR_MODE_CHANGE_IN_PROGRESS</unmanaged>
        public static readonly SharpDX.ResultDescriptor ModeChangeInProgress = new SharpDX.ResultDescriptor(unchecked ((int)2289696805UL), "SharpDX.DXGI", "DXGI_ERROR_MODE_CHANGE_IN_PROGRESS", "ModeChangeInProgress");
                ///<summary>Constant CacheCorrupt</summary>
        ///<unmanaged>DXGI_ERROR_CACHE_CORRUPT</unmanaged>
        public static readonly SharpDX.ResultDescriptor CacheCorrupt = new SharpDX.ResultDescriptor(unchecked ((int)2289696819UL), "SharpDX.DXGI", "DXGI_ERROR_CACHE_CORRUPT", "CacheCorrupt");
                ///<summary>Constant CacheFull</summary>
        ///<unmanaged>DXGI_ERROR_CACHE_FULL</unmanaged>
        public static readonly SharpDX.ResultDescriptor CacheFull = new SharpDX.ResultDescriptor(unchecked ((int)2289696820UL), "SharpDX.DXGI", "DXGI_ERROR_CACHE_FULL", "CacheFull");
                ///<summary>Constant CacheHashCollision</summary>
        ///<unmanaged>DXGI_ERROR_CACHE_HASH_COLLISION</unmanaged>
        public static readonly SharpDX.ResultDescriptor CacheHashCollision = new SharpDX.ResultDescriptor(unchecked ((int)2289696821UL), "SharpDX.DXGI", "DXGI_ERROR_CACHE_HASH_COLLISION", "CacheHashCollision");
                ///<summary>Constant AlreadyExists</summary>
        ///<unmanaged>DXGI_ERROR_ALREADY_EXISTS</unmanaged>
        public static readonly SharpDX.ResultDescriptor AlreadyExists = new SharpDX.ResultDescriptor(unchecked ((int)2289696822UL), "SharpDX.DXGI", "DXGI_ERROR_ALREADY_EXISTS", "AlreadyExists");
    }
}