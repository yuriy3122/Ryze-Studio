// <auto-generated/>

namespace SharpDX.DXGI
{
    [System.Runtime.InteropServices.GuidAttribute("2411e7e1-12ac-4ccf-bd14-9798e8534dc0")]
    public partial class Adapter : SharpDX.DXGI.DXGIObject
    {
        public Adapter(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Adapter(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Adapter(nativePtr);
        /// <summary>
        /// <p>Gets a DXGI 1.0 description of an adapter (or video card).</p>
        /// </summary>
        /// <remarks>
        /// <p>Graphics apps can use the DXGI API to retrieve an accurate set of graphics memory  values on systems that have Windows Display Driver Model (WDDM) drivers. The following are the critical steps involved.</p><ul> <li> Graphics driver model determination ? Because DXGI is only available on systems with WDDM drivers, the app must first confirm the driver model by using the following API.  <pre> HasWDDMDriver()
        /// { LPDIRECT3DCREATE9EX pD3D9Create9Ex = <c>null</c>; HMODULE             hD3D9          = <c>null</c>; hD3D9 = LoadLibrary( L"d3d9.dll" ); if ( <c>null</c> == hD3D9 ) { return false; } // /*  Try to create IDirect3D9Ex interface (also known as a DX9L interface). This interface can only be created if the driver is a WDDM driver. */ // pD3D9Create9Ex = (LPDIRECT3DCREATE9EX) GetProcAddress( hD3D9, "Direct3DCreate9Ex" ); return pD3D9Create9Ex != <c>null</c>;
        /// } </pre>  </li> <li> Retrieval of graphics memory values.? After the app determines the driver model to be WDDM, the app can use the Direct3D 10 or later API and DXGI to get the amount of graphics memory.  After you create a Direct3D device, use this code to obtain  a <strong><see cref = "SharpDX.DXGI.AdapterDescription"/></strong> structure that contains the amount of available graphics memory.  <pre> <see cref = "SharpDX.DXGI.Device"/> * pDXGIDevice;
        /// hr = g_pd3dDevice-&gt;QueryInterface(__uuidof(<see cref = "SharpDX.DXGI.Device"/>), (void **)&amp;pDXGIDevice);
        /// <see cref = "SharpDX.DXGI.Adapter"/> * pDXGIAdapter;
        /// pDXGIDevice-&gt;GetAdapter(&amp;pDXGIAdapter);
        /// <see cref = "SharpDX.DXGI.AdapterDescription"/> adapterDesc;
        /// pDXGIAdapter-&gt;GetDesc(&amp;adapterDesc); </pre>  </li> </ul>
        /// </remarks>
        /// <doc-id>bb174526</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.DXGI.AdapterDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Enumerate adapter (video card) outputs.</p>
        /// </summary>
        /// <param name = "output"><dd>  <p>The index of the output.</p> </dd></param>
        /// <param name = "outputOut"><dd>  <p>The address of a reference to an <strong><see cref = "SharpDX.DXGI.Output"/></strong> interface at the position specified by the <em>Output</em> parameter.</p> </dd></param>
        /// <returns><p>A code that indicates success or failure (see DXGI_ERROR). <see cref = "NotFound"/> is returned if the index is greater than the number of outputs.</p><p>If the adapter came from a device created using D3D_DRIVER_TYPE_WARP, then the adapter has no outputs, so <see cref = "NotFound"/> is returned.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??If you call this API in a Session 0 process, it returns <strong><see cref = "NotCurrentlyAvailable"/></strong>.?<p>When the <strong>EnumOutputs</strong> method succeeds and fills the <em>ppOutput</em> parameter with the address of the reference to the output interface, <strong>EnumOutputs</strong> increments the output interface's reference count. To avoid a memory leak, when you finish using the  output interface, call the <strong>Release</strong> method to decrement the reference count.</p><p><strong>EnumOutputs</strong> first returns the output on which the desktop primary is displayed. This output corresponds with an index of zero. <strong>EnumOutputs</strong> then returns other outputs.</p>
        /// </remarks>
        /// <doc-id>bb174525</doc-id>
        /// <unmanaged>HRESULT IDXGIAdapter::EnumOutputs([In] unsigned int Output,[Out] IDXGIOutput** ppOutput)</unmanaged>
        /// <unmanaged-short>IDXGIAdapter::EnumOutputs</unmanaged-short>
        internal unsafe SharpDX.Result GetOutput(System.Int32 output, out SharpDX.DXGI.Output outputOut)
        {
            System.IntPtr outputOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, output, &outputOut_, (*(void ***)this._nativePointer)[7]);
            if (outputOut_ != System.IntPtr.Zero)
                outputOut = new SharpDX.DXGI.Output(outputOut_);
            else
                outputOut = null;
            return __result__;
        }

        /// <summary>
        /// <p>Gets a DXGI 1.0 description of an adapter (or video card).</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p>A reference to a <strong><see cref = "SharpDX.DXGI.AdapterDescription"/></strong> structure that describes the adapter. This parameter must not be <strong><c>null</c></strong>. On feature level 9 graphics hardware, <strong>GetDesc</strong> returns zeros for the PCI ID in the <strong>VendorId</strong>, <strong>DeviceId</strong>, <strong>SubSysId</strong>, and <strong>Revision</strong> members of <strong><see cref = "SharpDX.DXGI.AdapterDescription"/></strong> and ?Software Adapter? for the description string in the <strong>Description</strong> member.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise returns E_INVALIDARG if the <em>pDesc</em> parameter is <strong><c>null</c></strong>.   </p></returns>
        /// <remarks>
        /// <p>Graphics apps can use the DXGI API to retrieve an accurate set of graphics memory  values on systems that have Windows Display Driver Model (WDDM) drivers. The following are the critical steps involved.</p><ul> <li> Graphics driver model determination ? Because DXGI is only available on systems with WDDM drivers, the app must first confirm the driver model by using the following API.  <pre> HasWDDMDriver()
        /// { LPDIRECT3DCREATE9EX pD3D9Create9Ex = <c>null</c>; HMODULE             hD3D9          = <c>null</c>; hD3D9 = LoadLibrary( L"d3d9.dll" ); if ( <c>null</c> == hD3D9 ) { return false; } // /*  Try to create IDirect3D9Ex interface (also known as a DX9L interface). This interface can only be created if the driver is a WDDM driver. */ // pD3D9Create9Ex = (LPDIRECT3DCREATE9EX) GetProcAddress( hD3D9, "Direct3DCreate9Ex" ); return pD3D9Create9Ex != <c>null</c>;
        /// } </pre>  </li> <li> Retrieval of graphics memory values.? After the app determines the driver model to be WDDM, the app can use the Direct3D 10 or later API and DXGI to get the amount of graphics memory.  After you create a Direct3D device, use this code to obtain  a <strong><see cref = "SharpDX.DXGI.AdapterDescription"/></strong> structure that contains the amount of available graphics memory.  <pre> <see cref = "SharpDX.DXGI.Device"/> * pDXGIDevice;
        /// hr = g_pd3dDevice-&gt;QueryInterface(__uuidof(<see cref = "SharpDX.DXGI.Device"/>), (void **)&amp;pDXGIDevice);
        /// <see cref = "SharpDX.DXGI.Adapter"/> * pDXGIAdapter;
        /// pDXGIDevice-&gt;GetAdapter(&amp;pDXGIAdapter);
        /// <see cref = "SharpDX.DXGI.AdapterDescription"/> adapterDesc;
        /// pDXGIAdapter-&gt;GetDesc(&amp;adapterDesc); </pre>  </li> </ul>
        /// </remarks>
        /// <doc-id>bb174526</doc-id>
        /// <unmanaged>HRESULT IDXGIAdapter::GetDesc([Out] DXGI_ADAPTER_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>IDXGIAdapter::GetDesc</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.DXGI.AdapterDescription descRef)
        {
            SharpDX.DXGI.AdapterDescription.__Native descRef_ = default (SharpDX.DXGI.AdapterDescription.__Native);
            descRef = default (SharpDX.DXGI.AdapterDescription);
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &descRef_, (*(void ***)this._nativePointer)[8]);
            descRef.__MarshalFrom(ref descRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Checks whether the system supports a device interface for a graphics component.</p>
        /// </summary>
        /// <param name = "interfaceName"><dd>  <p>The <see cref = "System.Guid"/> of the interface of the device version for which support is being checked. For example, __uuidof(ID3D10Device).</p> </dd></param>
        /// <param name = "uMDVersionRef"><dd>  <p>The user mode driver version of <em>InterfaceName</em>. This is  returned only if the interface is supported, otherwise this parameter will be <strong><c>null</c></strong>.</p> </dd></param>
        /// <returns><p><see cref = "SharpDX.Result.Ok"/> indicates that the interface is supported, otherwise <see cref = "Unsupported"/> is returned (For more information, see DXGI_ERROR).</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??You can  use <strong>CheckInterfaceSupport</strong> only to  check whether a Direct3D 10.x interface is supported, and only on Windows Vista SP1 and later versions of the operating system. If you try to use <strong>CheckInterfaceSupport</strong> to check whether a Direct3D 11.x and later version interface is supported, <strong>CheckInterfaceSupport</strong> returns <see cref = "Unsupported"/>. Therefore, do not use <strong>CheckInterfaceSupport</strong>. Instead, to verify whether the operating system supports a particular interface, try to create the interface. For example, if you call the <strong>ID3D11Device::CreateBlendState</strong> method and it fails, the operating system does not support the <strong><see cref = "SharpDX.Direct3D11.BlendState"/></strong> interface.?
        /// </remarks>
        /// <doc-id>bb174524</doc-id>
        /// <unmanaged>HRESULT IDXGIAdapter::CheckInterfaceSupport([In] const GUID&amp; InterfaceName,[Out] LARGE_INTEGER* pUMDVersion)</unmanaged>
        /// <unmanaged-short>IDXGIAdapter::CheckInterfaceSupport</unmanaged-short>
        internal unsafe SharpDX.Result CheckInterfaceSupport(System.Guid interfaceName, out System.Int64 uMDVersionRef)
        {
            SharpDX.Result __result__;
            fixed (void *uMDVersionRef_ = &uMDVersionRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &interfaceName, uMDVersionRef_, (*(void ***)this._nativePointer)[9]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("29038f61-3839-4626-91fd-086879011a05")]
    public partial class Adapter1 : SharpDX.DXGI.Adapter
    {
        public Adapter1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Adapter1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Adapter1(nativePtr);
        /// <summary>
        /// <p>Gets a DXGI 1.1 description of an adapter (or video card).</p>
        /// </summary>
        /// <remarks>
        /// <p>This method is not supported by DXGI 1.0, which shipped in Windows?Vista and Windows Server?2008. DXGI 1.1 support is required, which is available on  Windows?7, Windows Server?2008?R2, and as an update to Windows?Vista with Service Pack?2 (SP2) (KB 971644) and Windows Server?2008 (KB 971512).</p><p>Use the <strong>GetDesc1</strong> method to get a DXGI 1.1 description of an adapter.  To get a DXGI 1.0 description, use the <strong><see cref = "SharpDX.DXGI.Adapter"/></strong> method.</p>
        /// </remarks>
        /// <doc-id>ff471330</doc-id>
        /// <unmanaged>GetDesc1</unmanaged>
        /// <unmanaged-short>GetDesc1</unmanaged-short>
        public SharpDX.DXGI.AdapterDescription1 Description1
        {
            get
            {
                GetDescription1(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets a DXGI 1.1 description of an adapter (or video card).</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p>A reference to a <strong><see cref = "SharpDX.DXGI.AdapterDescription1"/></strong> structure that describes the adapter.   This parameter must not be <strong><c>null</c></strong>. On feature level 9 graphics hardware, <strong>GetDesc1</strong> returns zeros for the PCI ID in the <strong>VendorId</strong>, <strong>DeviceId</strong>, <strong>SubSysId</strong>, and <strong>Revision</strong> members of <strong><see cref = "SharpDX.DXGI.AdapterDescription1"/></strong> and ?Software Adapter? for the description string in the <strong>Description</strong> member.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns E_INVALIDARG if the <em>pDesc</em> parameter is <strong><c>null</c></strong>.   </p></returns>
        /// <remarks>
        /// <p>This method is not supported by DXGI 1.0, which shipped in Windows?Vista and Windows Server?2008. DXGI 1.1 support is required, which is available on  Windows?7, Windows Server?2008?R2, and as an update to Windows?Vista with Service Pack?2 (SP2) (KB 971644) and Windows Server?2008 (KB 971512).</p><p>Use the <strong>GetDesc1</strong> method to get a DXGI 1.1 description of an adapter.  To get a DXGI 1.0 description, use the <strong><see cref = "SharpDX.DXGI.Adapter"/></strong> method.</p>
        /// </remarks>
        /// <doc-id>ff471330</doc-id>
        /// <unmanaged>HRESULT IDXGIAdapter1::GetDesc1([Out] DXGI_ADAPTER_DESC1* pDesc)</unmanaged>
        /// <unmanaged-short>IDXGIAdapter1::GetDesc1</unmanaged-short>
        internal unsafe void GetDescription1(out SharpDX.DXGI.AdapterDescription1 descRef)
        {
            SharpDX.DXGI.AdapterDescription1.__Native descRef_ = default (SharpDX.DXGI.AdapterDescription1.__Native);
            descRef = default (SharpDX.DXGI.AdapterDescription1);
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &descRef_, (*(void ***)this._nativePointer)[10]);
            descRef.__MarshalFrom(ref descRef_);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("0AA1AE0A-FA0E-4B84-8644-E05FF8E5ACB5")]
    public partial class Adapter2 : SharpDX.DXGI.Adapter1
    {
        public Adapter2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Adapter2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Adapter2(nativePtr);
        /// <summary>
        /// <p>Gets a Microsoft DirectX Graphics Infrastructure (DXGI) 1.2 description of an adapter or video card. This description includes information about the granularity at which the graphics processing unit (GPU) can be preempted from performing its current task.</p>
        /// </summary>
        /// <remarks>
        /// <p>Use the <strong>GetDesc2</strong> method to get a DXGI 1.2 description of an adapter.  To get a DXGI 1.1 description, use the <strong>IDXGIAdapter1::GetDesc1</strong> method. To get a DXGI 1.0 description, use the <strong>IDXGIAdapter::GetDesc</strong> method.</p><p>The Windows Display Driver Model (WDDM) scheduler can preempt the GPU's execution of application tasks. The granularity at which the GPU can be preempted from performing its current task in the WDDM 1.1 or earlier driver model is a direct memory access (DMA) buffer for graphics tasks or a compute packet for compute tasks. The GPU can switch between tasks only after it completes the currently executing unit of work, a DMA buffer or a compute packet. </p><p>A DMA buffer is the largest independent unit of graphics work that the WDDM scheduler can submit to the GPU. This buffer contains a set of GPU instructions that the WDDM driver and GPU use. A compute packet is the largest independent unit of compute work that the WDDM scheduler can submit to the GPU. A compute packet contains dispatches (for example, calls to the <strong>ID3D11DeviceContext::Dispatch</strong> method), which contain thread groups. The WDDM 1.2 or later driver model allows the GPU to be preempted at finer granularity levels than a DMA buffer or compute packet. You can use the <strong>GetDesc2</strong> method to retrieve the granularity levels for graphics and compute tasks.</p>
        /// </remarks>
        /// <doc-id>hh404540</doc-id>
        /// <unmanaged>GetDesc2</unmanaged>
        /// <unmanaged-short>GetDesc2</unmanaged-short>
        public SharpDX.DXGI.AdapterDescription2 Description2
        {
            get
            {
                GetDescription2(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets a Microsoft DirectX Graphics Infrastructure (DXGI) 1.2 description of an adapter or video card. This description includes information about the granularity at which the graphics processing unit (GPU) can be preempted from performing its current task.</p>
        /// </summary>
        /// <param name = "descRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.DXGI.AdapterDescription2"/></strong> structure that describes the adapter.   This parameter must not be <strong><c>null</c></strong>. On feature level 9 graphics hardware, earlier versions of  <strong>GetDesc2</strong> (<strong>GetDesc</strong> and <strong>GetDesc1</strong>) return zeros for the PCI ID in the <strong>VendorId</strong>, <strong>DeviceId</strong>, <strong>SubSysId</strong>, and <strong>Revision</strong> members of the adapter description structure and ?Software Adapter? for the description string in the <strong>Description</strong> member. <strong>GetDesc2</strong> returns the actual feature level 9 hardware values in these members.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns E_INVALIDARG if the <em>pDesc</em> parameter is <strong><c>null</c></strong>.   </p></returns>
        /// <remarks>
        /// <p>Use the <strong>GetDesc2</strong> method to get a DXGI 1.2 description of an adapter.  To get a DXGI 1.1 description, use the <strong>IDXGIAdapter1::GetDesc1</strong> method. To get a DXGI 1.0 description, use the <strong>IDXGIAdapter::GetDesc</strong> method.</p><p>The Windows Display Driver Model (WDDM) scheduler can preempt the GPU's execution of application tasks. The granularity at which the GPU can be preempted from performing its current task in the WDDM 1.1 or earlier driver model is a direct memory access (DMA) buffer for graphics tasks or a compute packet for compute tasks. The GPU can switch between tasks only after it completes the currently executing unit of work, a DMA buffer or a compute packet. </p><p>A DMA buffer is the largest independent unit of graphics work that the WDDM scheduler can submit to the GPU. This buffer contains a set of GPU instructions that the WDDM driver and GPU use. A compute packet is the largest independent unit of compute work that the WDDM scheduler can submit to the GPU. A compute packet contains dispatches (for example, calls to the <strong>ID3D11DeviceContext::Dispatch</strong> method), which contain thread groups. The WDDM 1.2 or later driver model allows the GPU to be preempted at finer granularity levels than a DMA buffer or compute packet. You can use the <strong>GetDesc2</strong> method to retrieve the granularity levels for graphics and compute tasks.</p>
        /// </remarks>
        /// <doc-id>hh404540</doc-id>
        /// <unmanaged>HRESULT IDXGIAdapter2::GetDesc2([Out] DXGI_ADAPTER_DESC2* pDesc)</unmanaged>
        /// <unmanaged-short>IDXGIAdapter2::GetDesc2</unmanaged-short>
        internal unsafe void GetDescription2(out SharpDX.DXGI.AdapterDescription2 descRef)
        {
            SharpDX.DXGI.AdapterDescription2.__Native descRef_ = default (SharpDX.DXGI.AdapterDescription2.__Native);
            descRef = default (SharpDX.DXGI.AdapterDescription2);
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &descRef_, (*(void ***)this._nativePointer)[11]);
            descRef.__MarshalFrom(ref descRef_);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("645967A4-1392-4310-A798-8053CE3E93FD")]
    public partial class Adapter3 : SharpDX.DXGI.Adapter2
    {
        public Adapter3(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Adapter3(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Adapter3(nativePtr);
        /// <summary>
        /// <p>Registers to receive notification of hardware content protection teardown events.</p>
        /// </summary>
        /// <param name = "hEvent"><dd>  <p>A handle to the event object that the operating system sets when hardware content protection teardown occurs. The <strong>CreateEvent</strong> or <strong>OpenEvent</strong> function returns this handle. </p> </dd></param>
        /// <returns><dd>  <p>A reference to a key value that an application can pass to the <strong>IDXGIAdapter3::UnregisterHardwareContentProtectionTeardownStatus</strong> method to unregister the notification event that <em>hEvent</em> specifies.</p> </dd></returns>
        /// <remarks>
        /// <p>Call <strong>ID3D11VideoDevice::GetContentProtectionCaps</strong>() to check for the presence of the <strong>D3D11_CONTENT_PROTECTION_CAPS_HARDWARE_TEARDOWN</strong> capability to know whether the hardware contains an automatic teardown mechanism. After the event is signaled, the application can call <strong>ID3D11VideoContext1::CheckCryptoSessionStatus</strong> to determine the impact of the hardware teardown for a specific <strong><see cref = "SharpDX.Direct3D11.CryptoSession"/></strong> interface.
        /// </p>
        /// </remarks>
        /// <doc-id>dn933230</doc-id>
        /// <unmanaged>HRESULT IDXGIAdapter3::RegisterHardwareContentProtectionTeardownStatusEvent([In] void* hEvent,[Out] DWORD* pdwCookie)</unmanaged>
        /// <unmanaged-short>IDXGIAdapter3::RegisterHardwareContentProtectionTeardownStatusEvent</unmanaged-short>
        public unsafe System.Int32 RegisterHardwareContentProtectionTeardownStatusEvent(System.IntPtr hEvent)
        {
            System.Int32 dwCookieRef;
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)hEvent, &dwCookieRef, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
            return dwCookieRef;
        }

        /// <summary>
        /// <p>Unregisters an event to stop it from receiving notification of hardware content protection teardown events.</p>
        /// </summary>
        /// <param name = "dwCookie"><dd>  <p>A key value for the window or event to unregister. The  <strong>IDXGIAdapter3::RegisterHardwareContentProtectionTeardownStatusEvent</strong> method returns this value. </p> </dd></param>
        /// <doc-id>dn933233</doc-id>
        /// <unmanaged>void IDXGIAdapter3::UnregisterHardwareContentProtectionTeardownStatus([In] DWORD dwCookie)</unmanaged>
        /// <unmanaged-short>IDXGIAdapter3::UnregisterHardwareContentProtectionTeardownStatus</unmanaged-short>
        public unsafe void UnregisterHardwareContentProtectionTeardownStatus(System.Int32 dwCookie)
        {
            SharpDX.DXGI.LocalInterop.CalliStdCallvoid(this._nativePointer, dwCookie, (*(void ***)this._nativePointer)[13]);
        }

        /// <summary>
        /// <p> This method informs the process of the current budget and process usage. </p>
        /// </summary>
        /// <param name = "nodeIndex"><dd>  <p> Specifies the device's physical adapter for which the video memory information is queried. For single-GPU operation, set this to zero. If there are multiple GPU nodes, set this to the index of the node (the device's physical adapter) for which the video memory information is queried. See Multi-Adapter. </p> </dd></param>
        /// <param name = "memorySegmentGroup"><dd>  <p> Specifies a <see cref = "SharpDX.DXGI.MemorySegmentGroup"/> that identifies the group as local or non-local. </p> </dd></param>
        /// <returns><dd>  <p> Fills in a <see cref = "SharpDX.DXGI.QueryVideoMemoryInformation"/> structure with the current values. </p> </dd></returns>
        /// <remarks>
        /// <p> Applications must explicitly manage their usage of physical memory explicitly and keep usage within the budget assigned to the application process. Processes that cannot kept their usage within their assigned budgets will likely experience stuttering, as they are intermittently frozen and paged-out to allow other processes to run. </p>
        /// </remarks>
        /// <doc-id>dn933223</doc-id>
        /// <unmanaged>HRESULT IDXGIAdapter3::QueryVideoMemoryInfo([In] unsigned int NodeIndex,[In] DXGI_MEMORY_SEGMENT_GROUP MemorySegmentGroup,[Out] DXGI_QUERY_VIDEO_MEMORY_INFO* pVideoMemoryInfo)</unmanaged>
        /// <unmanaged-short>IDXGIAdapter3::QueryVideoMemoryInfo</unmanaged-short>
        public unsafe SharpDX.DXGI.QueryVideoMemoryInformation QueryVideoMemoryInfo(System.Int32 nodeIndex, SharpDX.DXGI.MemorySegmentGroup memorySegmentGroup)
        {
            SharpDX.DXGI.QueryVideoMemoryInformation videoMemoryInfoRef;
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, nodeIndex, unchecked ((System.Int32)memorySegmentGroup), &videoMemoryInfoRef, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
            return videoMemoryInfoRef;
        }

        /// <summary>
        /// <p> This method sends the minimum required physical memory for an application, to the OS. </p>
        /// </summary>
        /// <param name = "nodeIndex"><dd>  <p> Specifies the device's physical adapter for which the video memory information is being set. For single-GPU operation, set this to zero. If there are multiple GPU nodes, set this to the index of the node (the device's physical adapter) for which the video memory information is being set. See Multi-Adapter. </p> </dd></param>
        /// <param name = "memorySegmentGroup"><dd>  <p> Specifies a <see cref = "SharpDX.DXGI.MemorySegmentGroup"/> that identifies the group as local or non-local. </p> </dd></param>
        /// <param name = "reservation"><dd>  <p> Specifies a UINT64 that sets the minimum required physical memory, in bytes. </p> </dd></param>
        /// <returns><p> Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR. </p></returns>
        /// <remarks>
        /// <p> Applications are encouraged to set a video reservation to denote the amount of physical memory they cannot go without. This value helps the OS quickly minimize the impact of large memory pressure situations. </p>
        /// </remarks>
        /// <doc-id>dn933232</doc-id>
        /// <unmanaged>HRESULT IDXGIAdapter3::SetVideoMemoryReservation([In] unsigned int NodeIndex,[In] DXGI_MEMORY_SEGMENT_GROUP MemorySegmentGroup,[In] unsigned longlong Reservation)</unmanaged>
        /// <unmanaged-short>IDXGIAdapter3::SetVideoMemoryReservation</unmanaged-short>
        public unsafe void SetVideoMemoryReservation(System.Int32 nodeIndex, SharpDX.DXGI.MemorySegmentGroup memorySegmentGroup, System.Int64 reservation)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, nodeIndex, unchecked ((System.Int32)memorySegmentGroup), reservation, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>This method establishes a correlation between a CPU synchronization object and the budget change event.</p>
        /// </summary>
        /// <param name = "hEvent"><dd>  <p>Specifies a HANDLE for the event.</p> </dd></param>
        /// <returns><dd>  <p>A key value for the window or event to unregister. The  <strong>IDXGIAdapter3::RegisterHardwareContentProtectionTeardownStatusEvent</strong> method returns this value. </p> </dd></returns>
        /// <remarks>
        /// <p>Instead of calling <strong>QueryVideoMemoryInfo</strong> regularly, applications can use CPU synchronization objects to efficiently wake threads when budget changes occur. </p>
        /// </remarks>
        /// <doc-id>dn933231</doc-id>
        /// <unmanaged>HRESULT IDXGIAdapter3::RegisterVideoMemoryBudgetChangeNotificationEvent([In] void* hEvent,[Out] DWORD* pdwCookie)</unmanaged>
        /// <unmanaged-short>IDXGIAdapter3::RegisterVideoMemoryBudgetChangeNotificationEvent</unmanaged-short>
        public unsafe System.Int32 RegisterVideoMemoryBudgetChangeNotificationEvent(System.IntPtr hEvent)
        {
            System.Int32 dwCookieRef;
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)hEvent, &dwCookieRef, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
            return dwCookieRef;
        }

        /// <summary>
        /// <p>This method stops notifying a CPU synchronization object whenever a budget change occurs. An application may switch back to polling the information regularly.</p>
        /// </summary>
        /// <param name = "dwCookie"><dd>  <p>A key value for the window or event to unregister. The  <strong>IDXGIAdapter3::RegisterHardwareContentProtectionTeardownStatusEvent</strong> method returns this value. </p> </dd></param>
        /// <remarks>
        /// <p>An application may switch back to polling for the information regularly.</p>
        /// </remarks>
        /// <doc-id>dn933234</doc-id>
        /// <unmanaged>void IDXGIAdapter3::UnregisterVideoMemoryBudgetChangeNotification([In] DWORD dwCookie)</unmanaged>
        /// <unmanaged-short>IDXGIAdapter3::UnregisterVideoMemoryBudgetChangeNotification</unmanaged-short>
        public unsafe void UnregisterVideoMemoryBudgetChangeNotification(System.Int32 dwCookie)
        {
            SharpDX.DXGI.LocalInterop.CalliStdCallvoid(this._nativePointer, dwCookie, (*(void ***)this._nativePointer)[17]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("3c8d99d1-4fbf-4181-a82c-af66bf7bd24e")]
    public partial class Adapter4 : SharpDX.DXGI.Adapter3
    {
        public Adapter4(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Adapter4(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Adapter4(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetDesc3</unmanaged>
        /// <unmanaged-short>GetDesc3</unmanaged-short>
        public SharpDX.DXGI.AdapterDescription3 Desc3
        {
            get
            {
                GetDesc3(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "descRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT IDXGIAdapter4::GetDesc3([Out] DXGI_ADAPTER_DESC3* pDesc)</unmanaged>
        /// <unmanaged-short>IDXGIAdapter4::GetDesc3</unmanaged-short>
        internal unsafe void GetDesc3(out SharpDX.DXGI.AdapterDescription3 descRef)
        {
            SharpDX.DXGI.AdapterDescription3.__Native descRef_ = default (SharpDX.DXGI.AdapterDescription3.__Native);
            descRef = default (SharpDX.DXGI.AdapterDescription3);
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &descRef_, (*(void ***)this._nativePointer)[18]);
            descRef.__MarshalFrom(ref descRef_);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2633066b-4514-4c7a-8fd8-12ea98059d18")]
    public partial class DecodeSwapChain : SharpDX.ComObject
    {
        public DecodeSwapChain(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DecodeSwapChain(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DecodeSwapChain(nativePtr);
        /// <summary>
        /// <p>Gets or sets the source region that is used for the swap chain.</p>
        /// </summary>
        /// <doc-id>dn384121</doc-id>
        /// <unmanaged>GetSourceRect / SetSourceRect</unmanaged>
        /// <unmanaged-short>GetSourceRect</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawRectangle SourceRect
        {
            get
            {
                GetSourceRect(out var __output__);
                return __output__;
            }

            set => SetSourceRect(value);
        }

        /// <summary>
        /// <p>Gets or sets the rectangle that defines the target region for the video processing blit operation.</p>
        /// </summary>
        /// <doc-id>dn384122</doc-id>
        /// <unmanaged>GetTargetRect / SetTargetRect</unmanaged>
        /// <unmanaged-short>GetTargetRect</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawRectangle TargetRect
        {
            get
            {
                GetTargetRect(out var __output__);
                return __output__;
            }

            set => SetTargetRect(value);
        }

        /// <summary>
        /// <p>Gets or sets the color space used by the swap chain.</p>
        /// </summary>
        /// <doc-id>dn384119</doc-id>
        /// <unmanaged>GetColorSpace / SetColorSpace</unmanaged>
        /// <unmanaged-short>GetColorSpace</unmanaged-short>
        public SharpDX.DXGI.MultiplaneOverlayYCbCrFlags ColorSpace
        {
            get => GetColorSpace();
            set => SetColorSpace(value);
        }

        /// <summary>
        /// <p>Presents a frame on the output adapter. The frame is a subresource of the <strong><see cref = "SharpDX.DXGI.Resource"/></strong> object that was used to create the decode swap chain.</p>
        /// </summary>
        /// <param name = "bufferToPresent">No documentation.</param>
        /// <param name = "syncInterval">No documentation.</param>
        /// <param name = "flags">No documentation.</param>
        /// <returns><p>This method returns <strong><see cref = "SharpDX.Result.Ok"/></strong> on success, or it returns one of the following error codes:</p><ul> <li><see cref = "DeviceRemoved"/></li> <li>DXGI_STATUS_OCCLUDED</li> <li><see cref = "InvalidCall"/></li> <li><strong>E_OUTOFMEMORY</strong></li> </ul></returns>
        /// <doc-id>dn384123</doc-id>
        /// <unmanaged>HRESULT IDXGIDecodeSwapChain::PresentBuffer([In] unsigned int BufferToPresent,[In] unsigned int SyncInterval,[In] unsigned int Flags)</unmanaged>
        /// <unmanaged-short>IDXGIDecodeSwapChain::PresentBuffer</unmanaged-short>
        public unsafe void PresentBuffer(System.Int32 bufferToPresent, System.Int32 syncInterval, System.Int32 flags)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, bufferToPresent, syncInterval, flags, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the rectangle that defines the source region for the video processing blit operation.</p><p>The source rectangle is the portion of the input surface that is blitted to the destination surface. The source rectangle is given in pixel coordinates, relative to the input surface.</p>
        /// </summary>
        /// <param name = "rectRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure  that contains the source region to set for the swap chain.</p> </dd></param>
        /// <returns><p>This method returns <see cref = "SharpDX.Result.Ok"/> on success, or it returns one of the error codes that are described in the DXGI_ERROR topic.</p></returns>
        /// <doc-id>dn384126</doc-id>
        /// <unmanaged>HRESULT IDXGIDecodeSwapChain::SetSourceRect([In] const RECT* pRect)</unmanaged>
        /// <unmanaged-short>IDXGIDecodeSwapChain::SetSourceRect</unmanaged-short>
        internal unsafe void SetSourceRect(SharpDX.Mathematics.Interop.RawRectangle rectRef)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &rectRef, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the rectangle that defines the target region for the video processing blit operation.</p><p>The target rectangle is the area within the destination surface where the output will be drawn. The target rectangle is given in pixel coordinates, relative to the destination surface.</p>
        /// </summary>
        /// <param name = "rectRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure  that contains the target region to set for the swap chain.</p> </dd></param>
        /// <returns><p>This method returns <see cref = "SharpDX.Result.Ok"/> on success, or it returns one of the error codes that are described in the DXGI_ERROR topic.</p></returns>
        /// <doc-id>dn384127</doc-id>
        /// <unmanaged>HRESULT IDXGIDecodeSwapChain::SetTargetRect([In] const RECT* pRect)</unmanaged>
        /// <unmanaged-short>IDXGIDecodeSwapChain::SetTargetRect</unmanaged-short>
        internal unsafe void SetTargetRect(SharpDX.Mathematics.Interop.RawRectangle rectRef)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &rectRef, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the size of the destination surface to use for the video processing blit operation.</p><p>The destination rectangle is the portion of the output surface that receives the blit for this stream. The destination rectangle is given in pixel coordinates, relative to the output surface.</p>
        /// </summary>
        /// <param name = "width"><dd> <p>The width of the destination size, in pixels.</p> </dd></param>
        /// <param name = "height"><dd> <p>The height of the destination size, in pixels.</p> </dd></param>
        /// <returns><p>This method returns <see cref = "SharpDX.Result.Ok"/> on success, or it returns one of the error codes that are described in the DXGI_ERROR topic.</p></returns>
        /// <doc-id>dn384125</doc-id>
        /// <unmanaged>HRESULT IDXGIDecodeSwapChain::SetDestSize([In] unsigned int Width,[In] unsigned int Height)</unmanaged>
        /// <unmanaged-short>IDXGIDecodeSwapChain::SetDestSize</unmanaged-short>
        public unsafe void SetDestSize(System.Int32 width, System.Int32 height)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, width, height, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the source region that is used for the swap chain.</p>
        /// </summary>
        /// <param name = "rectRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure  that receives the source region for the swap chain.</p> </dd></param>
        /// <returns><p>This method returns <see cref = "SharpDX.Result.Ok"/> on success, or it returns one of the error codes that are described in the DXGI_ERROR topic.</p></returns>
        /// <doc-id>dn384121</doc-id>
        /// <unmanaged>HRESULT IDXGIDecodeSwapChain::GetSourceRect([Out] RECT* pRect)</unmanaged>
        /// <unmanaged-short>IDXGIDecodeSwapChain::GetSourceRect</unmanaged-short>
        internal unsafe void GetSourceRect(out SharpDX.Mathematics.Interop.RawRectangle rectRef)
        {
            rectRef = default (SharpDX.Mathematics.Interop.RawRectangle);
            SharpDX.Result __result__;
            fixed (void *rectRef_ = &rectRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, rectRef_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the rectangle that defines the target region for the video processing blit operation.</p>
        /// </summary>
        /// <param name = "rectRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure  that receives the target region for the swap chain.</p> </dd></param>
        /// <returns><p>This method returns <see cref = "SharpDX.Result.Ok"/> on success, or it returns one of the error codes that are described in the DXGI_ERROR topic.</p></returns>
        /// <doc-id>dn384122</doc-id>
        /// <unmanaged>HRESULT IDXGIDecodeSwapChain::GetTargetRect([Out] RECT* pRect)</unmanaged>
        /// <unmanaged-short>IDXGIDecodeSwapChain::GetTargetRect</unmanaged-short>
        internal unsafe void GetTargetRect(out SharpDX.Mathematics.Interop.RawRectangle rectRef)
        {
            rectRef = default (SharpDX.Mathematics.Interop.RawRectangle);
            SharpDX.Result __result__;
            fixed (void *rectRef_ = &rectRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, rectRef_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the size of the destination surface to use for the video processing blit operation.</p>
        /// </summary>
        /// <param name = "widthRef"><dd> <p>A reference to a variable that receives the width in pixels.</p> </dd></param>
        /// <param name = "heightRef"><dd> <p>A reference to a variable that receives the height in pixels.</p> </dd></param>
        /// <returns><p>This method returns <see cref = "SharpDX.Result.Ok"/> on success, or it returns one of the error codes that are described in the DXGI_ERROR topic.</p></returns>
        /// <doc-id>dn384120</doc-id>
        /// <unmanaged>HRESULT IDXGIDecodeSwapChain::GetDestSize([Out] unsigned int* pWidth,[Out] unsigned int* pHeight)</unmanaged>
        /// <unmanaged-short>IDXGIDecodeSwapChain::GetDestSize</unmanaged-short>
        public unsafe void GetDestSize(out System.Int32 widthRef, out System.Int32 heightRef)
        {
            SharpDX.Result __result__;
            fixed (void *heightRef_ = &heightRef)
                fixed (void *widthRef_ = &widthRef)
                    __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, widthRef_, heightRef_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the color space used by the swap chain.</p>
        /// </summary>
        /// <param name = "colorSpace"><dd> <p>A reference to a combination of <strong><see cref = "SharpDX.DXGI.MultiplaneOverlayYCbCrFlags"/></strong>-typed values that are combined by using a bitwise OR operation. The resulting value specifies the color space to set for the swap chain.</p> </dd></param>
        /// <returns><p>This method returns <see cref = "SharpDX.Result.Ok"/> on success, or it returns one of the error codes that are described in the DXGI_ERROR topic.</p></returns>
        /// <doc-id>dn384124</doc-id>
        /// <unmanaged>HRESULT IDXGIDecodeSwapChain::SetColorSpace([In] DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS ColorSpace)</unmanaged>
        /// <unmanaged-short>IDXGIDecodeSwapChain::SetColorSpace</unmanaged-short>
        internal unsafe void SetColorSpace(SharpDX.DXGI.MultiplaneOverlayYCbCrFlags colorSpace)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)colorSpace), (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the color space used by the swap chain.</p>
        /// </summary>
        /// <returns><p>A combination of <strong><see cref = "SharpDX.DXGI.MultiplaneOverlayYCbCrFlags"/></strong>-typed values that are combined by using a bitwise OR operation. The resulting value specifies the color space for the swap chain.</p></returns>
        /// <doc-id>dn384119</doc-id>
        /// <unmanaged>DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS IDXGIDecodeSwapChain::GetColorSpace()</unmanaged>
        /// <unmanaged-short>IDXGIDecodeSwapChain::GetColorSpace</unmanaged-short>
        internal unsafe SharpDX.DXGI.MultiplaneOverlayYCbCrFlags GetColorSpace()
        {
            SharpDX.DXGI.MultiplaneOverlayYCbCrFlags __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallSharpDXDXGIMultiplaneOverlayYCbCrFlags(this._nativePointer, (*(void ***)this._nativePointer)[11]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("54ec77fa-1377-44e6-8c32-88fd5f44c84c")]
    public partial class Device : SharpDX.DXGI.DXGIObject
    {
        public Device(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device(nativePtr);
        /// <summary>
        /// <p>Returns the adapter for the specified device.</p>
        /// </summary>
        /// <remarks>
        /// <p>If the <strong>GetAdapter</strong> method succeeds, the reference count on the adapter interface will be incremented. To avoid a memory leak, be sure to release the interface when you are finished using it.</p>
        /// </remarks>
        /// <doc-id>bb174531</doc-id>
        /// <unmanaged>GetAdapter</unmanaged>
        /// <unmanaged-short>GetAdapter</unmanaged-short>
        public SharpDX.DXGI.Adapter Adapter
        {
            get
            {
                GetAdapter(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets or sets the GPU thread priority.</p>
        /// </summary>
        /// <doc-id>bb174532</doc-id>
        /// <unmanaged>GetGPUThreadPriority / SetGPUThreadPriority</unmanaged>
        /// <unmanaged-short>GetGPUThreadPriority</unmanaged-short>
        public System.Int32 GPUThreadPriority
        {
            get
            {
                GetGPUThreadPriority(out var __output__);
                return __output__;
            }

            set => SetGPUThreadPriority(value);
        }

        /// <summary>
        /// <p>Returns the adapter for the specified device.</p>
        /// </summary>
        /// <param name = "adapterRef"><dd>  <p>The address of an <strong><see cref = "SharpDX.DXGI.Adapter"/></strong> interface reference to the adapter.  This parameter must not be <strong><c>null</c></strong>.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns one of the DXGI_ERROR that indicates failure. If the <em>pAdapter</em> parameter is <strong><c>null</c></strong> this method returns E_INVALIDARG.</p></returns>
        /// <remarks>
        /// <p>If the <strong>GetAdapter</strong> method succeeds, the reference count on the adapter interface will be incremented. To avoid a memory leak, be sure to release the interface when you are finished using it.</p>
        /// </remarks>
        /// <doc-id>bb174531</doc-id>
        /// <unmanaged>HRESULT IDXGIDevice::GetAdapter([Out] IDXGIAdapter** pAdapter)</unmanaged>
        /// <unmanaged-short>IDXGIDevice::GetAdapter</unmanaged-short>
        internal unsafe void GetAdapter(out SharpDX.DXGI.Adapter adapterRef)
        {
            System.IntPtr adapterRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &adapterRef_, (*(void ***)this._nativePointer)[7]);
            if (adapterRef_ != System.IntPtr.Zero)
                adapterRef = new SharpDX.DXGI.Adapter(adapterRef_);
            else
                adapterRef = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns a surface. This method is used internally and you should not call it directly in your application.</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p>A reference to a <strong><see cref = "SharpDX.DXGI.SurfaceDescription"/></strong> structure that describes the surface.</p> </dd></param>
        /// <param name = "numSurfaces"><dd>  <p>The number of surfaces to create.</p> </dd></param>
        /// <param name = "usage"><dd>  <p>A DXGI_USAGE flag that specifies how the surface is expected to be used.</p> </dd></param>
        /// <param name = "sharedResourceRef"><dd>  <p>An optional reference to a <strong><see cref = "SharpDX.DXGI.SharedResource"/></strong> structure that contains shared resource information for opening views of such resources.</p> </dd></param>
        /// <param name = "surfaceOut"><dd>  <p>The address of an <strong><see cref = "SharpDX.DXGI.Surface"/></strong> interface reference to the first created surface.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise.  For a list of error codes, see DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <p>The <strong>CreateSurface</strong> method creates a buffer to exchange data between one or more devices. It is used internally, and you should not directly call it.</p><p>The runtime automatically creates an <strong><see cref = "SharpDX.DXGI.Surface"/></strong> interface when it creates a Direct3D resource object that represents a surface. For example, the runtime creates an <strong><see cref = "SharpDX.DXGI.Surface"/></strong> interface when it calls <strong>ID3D11Device::CreateTexture2D</strong> or <strong>ID3D10Device::CreateTexture2D</strong> to create a 2D texture. To retrieve the <strong><see cref = "SharpDX.DXGI.Surface"/></strong> interface that represents the 2D texture surface, call <strong>ID3D11Texture2D::QueryInterface</strong> or <strong>ID3D10Texture2D::QueryInterface</strong>. In this call, you must pass the identifier of <strong><see cref = "SharpDX.DXGI.Surface"/></strong>. If the 2D texture has only a single MIP-map level and does not consist of an array of textures, <strong>QueryInterface</strong> succeeds and returns a reference to the <strong><see cref = "SharpDX.DXGI.Surface"/></strong> interface reference. Otherwise, <strong>QueryInterface</strong> fails and does not return the reference to <strong><see cref = "SharpDX.DXGI.Surface"/></strong>. 
        /// </p>
        /// </remarks>
        /// <doc-id>bb174530</doc-id>
        /// <unmanaged>HRESULT IDXGIDevice::CreateSurface([In] const DXGI_SURFACE_DESC* pDesc,[In] unsigned int NumSurfaces,[In] unsigned int Usage,[In, Optional] const DXGI_SHARED_RESOURCE* pSharedResource,[Out] IDXGISurface** ppSurface)</unmanaged>
        /// <unmanaged-short>IDXGIDevice::CreateSurface</unmanaged-short>
        internal unsafe void CreateSurface(ref SharpDX.DXGI.SurfaceDescription descRef, System.Int32 numSurfaces, System.Int32 usage, SharpDX.DXGI.SharedResource? sharedResourceRef, out SharpDX.DXGI.Surface surfaceOut)
        {
            SharpDX.DXGI.SharedResource sharedResourceRef_;
            System.IntPtr surfaceOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (sharedResourceRef != null)
                sharedResourceRef_ = sharedResourceRef.Value;
            fixed (void *descRef_ = &descRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, descRef_, numSurfaces, usage, sharedResourceRef == null ? (void *)0 : &sharedResourceRef_, &surfaceOut_, (*(void ***)this._nativePointer)[8]);
            if (surfaceOut_ != System.IntPtr.Zero)
                surfaceOut = new SharpDX.DXGI.Surface(surfaceOut_);
            else
                surfaceOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the residency status of an array of resources.</p>
        /// </summary>
        /// <param name = "resourcesOut"><dd>  <p>An array of <strong><see cref = "SharpDX.DXGI.Resource"/></strong> interfaces.</p> </dd></param>
        /// <param name = "residencyStatusRef"><dd>  <p>An array of <strong><see cref = "SharpDX.DXGI.Residency"/></strong> flags. Each element describes the residency status for corresponding element in  the <em>ppResources</em> argument array.</p> </dd></param>
        /// <param name = "numResources"><dd>  <p>The number of resources in the <em>ppResources</em> argument array and <em>pResidencyStatus</em> argument array.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns <see cref = "DeviceRemoved"/>, E_INVALIDARG, or  E_POINTER (see Common <see cref = "SharpDX.Result"/> Values and WinError.h for more information).</p></returns>
        /// <remarks>
        /// <p>The information returned by the <em>pResidencyStatus</em> argument array describes the residency status at the time that the <strong>QueryResourceResidency</strong> method was called.   </p><strong>Note</strong>??The residency status will constantly change.?<p>If you call the <strong>QueryResourceResidency</strong> method during a device removed state, the <em>pResidencyStatus</em> argument will return the <strong>DXGI_RESIDENCY_RESIDENT_IN_SHARED_MEMORY</strong> flag.</p><strong>Note</strong>??This method should not be called every frame as it incurs a non-trivial amount of overhead.?
        /// </remarks>
        /// <doc-id>bb174533</doc-id>
        /// <unmanaged>HRESULT IDXGIDevice::QueryResourceResidency([In, Buffer] const IUnknown** ppResources,[Out, Buffer] DXGI_RESIDENCY* pResidencyStatus,[In] unsigned int NumResources)</unmanaged>
        /// <unmanaged-short>IDXGIDevice::QueryResourceResidency</unmanaged-short>
        internal unsafe void QueryResourceResidency(SharpDX.IUnknown[] resourcesOut, SharpDX.DXGI.Residency[] residencyStatusRef, System.Int32 numResources)
        {
            System.IntPtr*resourcesOut_;
            resourcesOut_ = (System.IntPtr*)0;
            if (resourcesOut != null)
            {
                System.IntPtr*_resourcesOut = stackalloc System.IntPtr[resourcesOut.Length];
                resourcesOut_ = _resourcesOut;
            }

            SharpDX.Result __result__;
            if (resourcesOut != null)
                for (int i = 0; i < resourcesOut.Length; ++i)
                    (resourcesOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(resourcesOut[i]);
            fixed (void *residencyStatusRef_ = residencyStatusRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)resourcesOut_, residencyStatusRef_, numResources, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the GPU thread priority.</p>
        /// </summary>
        /// <param name = "priority"><dd>  <p>A value that specifies the required GPU thread priority. This value must be between -7 and 7, inclusive, where 0 represents normal priority.</p> </dd></param>
        /// <returns><p>Return <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns E_INVALIDARG if the <em>Priority</em> parameter is invalid.</p></returns>
        /// <remarks>
        /// <p>The values for the <em>Priority</em> parameter function as follows:</p><ul> <li>Positive values increase the likelihood that the GPU scheduler will grant GPU execution cycles to the device when rendering.</li> <li>Negative values lessen the likelihood that the device will receive GPU execution cycles when devices compete for them.</li> <li>The device is guaranteed to receive some GPU execution cycles at all settings.</li> </ul><p>To use the <strong>SetGPUThreadPriority</strong> method, you should have a comprehensive understanding of GPU scheduling. You should profile your application to ensure that it behaves as intended. If used inappropriately, the <strong>SetGPUThreadPriority</strong> method can impede rendering speed and result in a poor user experience.</p>
        /// </remarks>
        /// <doc-id>bb174534</doc-id>
        /// <unmanaged>HRESULT IDXGIDevice::SetGPUThreadPriority([In] int Priority)</unmanaged>
        /// <unmanaged-short>IDXGIDevice::SetGPUThreadPriority</unmanaged-short>
        internal unsafe void SetGPUThreadPriority(System.Int32 priority)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, priority, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the GPU thread priority.</p>
        /// </summary>
        /// <param name = "priorityRef"><dd>  <p>A reference to a variable that receives a value that indicates the current GPU thread priority. The value will be between -7 and 7, inclusive, where 0 represents normal priority.</p> </dd></param>
        /// <returns><p>Return <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns E_POINTER if the <em>pPriority</em> parameter is <strong><c>null</c></strong>.</p></returns>
        /// <doc-id>bb174532</doc-id>
        /// <unmanaged>HRESULT IDXGIDevice::GetGPUThreadPriority([Out] int* pPriority)</unmanaged>
        /// <unmanaged-short>IDXGIDevice::GetGPUThreadPriority</unmanaged-short>
        internal unsafe void GetGPUThreadPriority(out System.Int32 priorityRef)
        {
            SharpDX.Result __result__;
            fixed (void *priorityRef_ = &priorityRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, priorityRef_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("77db970f-6276-48ba-ba28-070143b4392c")]
    public partial class Device1 : SharpDX.DXGI.Device
    {
        public Device1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device1(nativePtr);
        /// <summary>
        /// <p>Gets or sets the number of frames that the system is allowed to queue for rendering.</p>
        /// </summary>
        /// <remarks>
        /// <p>This method is not supported by DXGI 1.0, which shipped in Windows?Vista and Windows Server?2008. DXGI 1.1 support is required, which is available on  Windows?7, Windows Server?2008?R2, and as an update to Windows?Vista with Service Pack?2 (SP2) (KB 971644) and Windows Server?2008 (KB 971512).</p><p>Frame latency is the number of frames that are allowed to be stored in a queue before submission for rendering.  Latency is often  used to control how the CPU chooses between responding to user input and frames that are in the render queue.  It is often beneficial for applications  that have no user input (for example, video playback) to queue more than 3 frames of data.</p>
        /// </remarks>
        /// <doc-id>ff471332</doc-id>
        /// <unmanaged>GetMaximumFrameLatency / SetMaximumFrameLatency</unmanaged>
        /// <unmanaged-short>GetMaximumFrameLatency</unmanaged-short>
        public System.Int32 MaximumFrameLatency
        {
            get
            {
                GetMaximumFrameLatency(out var __output__);
                return __output__;
            }

            set => SetMaximumFrameLatency(value);
        }

        /// <summary>
        /// <p>Sets the number of frames that the system is allowed to queue for rendering.</p>
        /// </summary>
        /// <param name = "maxLatency"><dd>  <p>The maximum number of back buffer frames that a driver can queue. The value defaults to 3, but  can range from 1 to 16. A value of 0 will reset latency to the default.  For multi-head devices, this value is specified per-head.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, <see cref = "DeviceRemoved"/> if the device was removed.</p></returns>
        /// <remarks>
        /// <p>This method is not supported by DXGI 1.0, which shipped in Windows?Vista and Windows Server?2008. DXGI 1.1 support is required, which is available on  Windows?7, Windows Server?2008?R2, and as an update to Windows?Vista with Service Pack?2 (SP2) (KB 971644) and Windows Server?2008 (KB 971512).</p><p>Frame latency is the number of frames that are allowed to be stored in a queue before submission for rendering.  Latency is often used to  control how the CPU chooses between responding to user input and frames that are in the render queue.  It is often beneficial for applications that  have no user input (for example, video playback) to queue more than 3 frames of data.</p>
        /// </remarks>
        /// <doc-id>ff471334</doc-id>
        /// <unmanaged>HRESULT IDXGIDevice1::SetMaximumFrameLatency([In] unsigned int MaxLatency)</unmanaged>
        /// <unmanaged-short>IDXGIDevice1::SetMaximumFrameLatency</unmanaged-short>
        internal unsafe void SetMaximumFrameLatency(System.Int32 maxLatency)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, maxLatency, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the number of frames that the system is allowed to queue for rendering.</p>
        /// </summary>
        /// <param name = "maxLatencyRef"><dd>  <p>This value is set to the number of frames that can be queued for render.   This value defaults to 3, but can range from 1 to 16.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns one of the following members of the D3DERR enumerated type:</p><ul> <li><strong>D3DERR_DEVICELOST</strong></li> <li><strong>D3DERR_DEVICEREMOVED</strong></li> <li><strong>D3DERR_DRIVERINTERNALERROR</strong></li> <li><strong>D3DERR_INVALIDCALL</strong></li> <li><strong>D3DERR_OUTOFVIDEOMEMORY</strong></li> </ul></returns>
        /// <remarks>
        /// <p>This method is not supported by DXGI 1.0, which shipped in Windows?Vista and Windows Server?2008. DXGI 1.1 support is required, which is available on  Windows?7, Windows Server?2008?R2, and as an update to Windows?Vista with Service Pack?2 (SP2) (KB 971644) and Windows Server?2008 (KB 971512).</p><p>Frame latency is the number of frames that are allowed to be stored in a queue before submission for rendering.  Latency is often  used to control how the CPU chooses between responding to user input and frames that are in the render queue.  It is often beneficial for applications  that have no user input (for example, video playback) to queue more than 3 frames of data.</p>
        /// </remarks>
        /// <doc-id>ff471332</doc-id>
        /// <unmanaged>HRESULT IDXGIDevice1::GetMaximumFrameLatency([Out] unsigned int* pMaxLatency)</unmanaged>
        /// <unmanaged-short>IDXGIDevice1::GetMaximumFrameLatency</unmanaged-short>
        internal unsafe void GetMaximumFrameLatency(out System.Int32 maxLatencyRef)
        {
            SharpDX.Result __result__;
            fixed (void *maxLatencyRef_ = &maxLatencyRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, maxLatencyRef_, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("05008617-fbfd-4051-a790-144884b4f6a9")]
    public partial class Device2 : SharpDX.DXGI.Device1
    {
        public Device2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device2(nativePtr);
        /// <summary>
        /// <p>Allows the operating system to free the video memory of resources by discarding their content.</p>
        /// </summary>
        /// <param name = "numResources"><dd> <p>The number of resources in the <em>ppResources</em> argument array.</p> </dd></param>
        /// <param name = "resourcesOut"><dd> <p>An array of references to <strong><see cref = "SharpDX.DXGI.Resource"/></strong> interfaces for the resources to offer.</p> </dd></param>
        /// <param name = "priority"><dd> <p>A <strong><see cref = "SharpDX.DXGI.OfferResourcePriority"/></strong>-typed value that indicates how valuable data is.</p> </dd></param>
        /// <returns><p><strong>OfferResources</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if resources were successfully offered</li> <li>E_INVALIDARG if a resource in the array or the priority is invalid</li> </ul></returns>
        /// <remarks>
        /// <p>The priority value that the  <em>Priority</em> parameter specifies describes how valuable the caller considers the content to be.  The operating system uses the priority value to discard resources in order of priority. The operating system discards a resource that is offered with low priority before it discards a resource that is  offered with a higher priority.</p><p>If you call <strong>OfferResources</strong> to offer a resource while the resource is bound to the pipeline, the resource is unbound.  You cannot call <strong>OfferResources</strong> on a resource that is mapped.  After you offer a resource, the resource cannot be mapped or bound to the pipeline until you call the <strong>IDXGIDevice2::ReclaimResource</strong> method to reclaim the resource. You cannot call <strong>OfferResources</strong> to offer immutable resources.</p><p>To offer shared resources, call <strong>OfferResources</strong> on only one of the sharing devices.  To ensure exclusive access to the resources, you must use an <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> object and then call <strong>OfferResources</strong> only while you hold the mutex. In fact, you can't offer shared resources unless you use <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> because offering shared resources without using <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> isn't supported.</p><strong>Note</strong>??The user mode display driver might not immediately offer the resources that you specified in a call to <strong>OfferResources</strong>. The driver can postpone offering them until the next call to <strong>IDXGISwapChain::Present</strong>, <strong>IDXGISwapChain1::Present1</strong>, or <strong>ID3D11DeviceContext::Flush</strong>.?<p><strong>Platform Update for Windows?7:??</strong>The runtime validates that <strong>OfferResources</strong> is used correctly on non-shared resources but doesn't perform the intended functionality. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p>
        /// </remarks>
        /// <doc-id>hh404549</doc-id>
        /// <unmanaged>HRESULT IDXGIDevice2::OfferResources([In] unsigned int NumResources,[In, Buffer] const IDXGIResource** ppResources,[In] DXGI_OFFER_RESOURCE_PRIORITY Priority)</unmanaged>
        /// <unmanaged-short>IDXGIDevice2::OfferResources</unmanaged-short>
        public unsafe void OfferResources(System.Int32 numResources, SharpDX.DXGI.Resource[] resourcesOut, SharpDX.DXGI.OfferResourcePriority priority)
        {
            System.IntPtr*resourcesOut_;
            resourcesOut_ = (System.IntPtr*)0;
            if (resourcesOut != null)
            {
                System.IntPtr*_resourcesOut = stackalloc System.IntPtr[resourcesOut.Length];
                resourcesOut_ = _resourcesOut;
            }

            SharpDX.Result __result__;
            if (resourcesOut != null)
                for (int i = 0; i < resourcesOut.Length; ++i)
                    (resourcesOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Resource>(resourcesOut[i]);
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, numResources, (void *)resourcesOut_, unchecked ((System.Int32)priority), (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Restores access to resources that were previously offered by calling <strong>IDXGIDevice2::OfferResources</strong>.</p>
        /// </summary>
        /// <param name = "numResources">No documentation.</param>
        /// <param name = "resourcesOut">No documentation.</param>
        /// <param name = "discardedRef">No documentation.</param>
        /// <returns><p><strong>ReclaimResources</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if resources were successfully reclaimed</li> <li>E_INVALIDARG if the resources are invalid</li> </ul></returns>
        /// <remarks>
        /// <p>After you call <strong>IDXGIDevice2::OfferResources</strong> to offer one or more resources, you must call <strong>ReclaimResources</strong> before you can use those resources again.  You must check the values in the array at <em>pDiscarded</em> to determine whether each resource?s content was discarded. If a resource?s content was discarded while it was offered, its current content is undefined. Therefore, you must overwrite the resource?s content before you use the resource.</p><p>To reclaim shared resources, call <strong>ReclaimResources</strong> only on one of the sharing devices.  To ensure exclusive access to the resources, you must use an <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> object and then call <strong>ReclaimResources</strong> only while you hold the mutex.</p><p><strong>Platform Update for Windows?7:??</strong>The runtime validates that <strong>ReclaimResources</strong> is used correctly on non-shared resources but doesn't perform the intended functionality. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p>
        /// </remarks>
        /// <doc-id>hh404551</doc-id>
        /// <unmanaged>HRESULT IDXGIDevice2::ReclaimResources([In] unsigned int NumResources,[In, Buffer] const IDXGIResource** ppResources,[Out, Buffer, Optional] BOOL* pDiscarded)</unmanaged>
        /// <unmanaged-short>IDXGIDevice2::ReclaimResources</unmanaged-short>
        public unsafe void ReclaimResources(System.Int32 numResources, SharpDX.DXGI.Resource[] resourcesOut, SharpDX.Mathematics.Interop.RawBool[] discardedRef)
        {
            System.IntPtr*resourcesOut_;
            resourcesOut_ = (System.IntPtr*)0;
            if (resourcesOut != null)
            {
                System.IntPtr*_resourcesOut = stackalloc System.IntPtr[resourcesOut.Length];
                resourcesOut_ = _resourcesOut;
            }

            SharpDX.Result __result__;
            if (resourcesOut != null)
                for (int i = 0; i < resourcesOut.Length; ++i)
                    (resourcesOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Resource>(resourcesOut[i]);
            fixed (void *discardedRef_ = discardedRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, numResources, (void *)resourcesOut_, discardedRef_, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Flushes any outstanding rendering commands and sets the specified event object to the signaled state after all previously submitted rendering commands complete.</p>
        /// </summary>
        /// <param name = "hEvent"><dd> <p>A handle to the event object. The <strong>CreateEvent</strong> or <strong>OpenEvent</strong> function returns this handle. All types of event objects (manual-reset, auto-reset, and so on) are supported.</p> <p>The handle must have the EVENT_MODIFY_STATE access right. For more information about access rights, see Synchronization Object Security and Access Rights.</p> </dd></param>
        /// <returns><p>Returns <strong><see cref = "SharpDX.Result.Ok"/></strong> if successful; otherwise, returns one of the following values:</p><ul> <li><strong>E_OUTOFMEMORY</strong> if insufficient memory is available to complete the operation.</li> <li><strong>E_INVALIDARG</strong> if the parameter was validated and determined to be incorrect.</li> </ul><p><strong>Platform Update for Windows?7:??</strong>On Windows?7 or Windows Server?2008?R2 with the Platform Update for Windows?7 installed, <strong>EnqueueSetEvent</strong> fails with E_NOTIMPL. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p></returns>
        /// <remarks>
        /// <p><strong>EnqueueSetEvent</strong> calls the <strong>SetEvent</strong> function on the event object after all previously submitted rendering commands complete or the device is removed.</p><p>After an application calls <strong>EnqueueSetEvent</strong>, it  can immediately call the <strong>WaitForSingleObject</strong> function to put itself to sleep until rendering commands complete.</p><p>You cannot use <strong>EnqueueSetEvent</strong> to determine work completion that is associated with presentation (<strong>IDXGISwapChain::Present</strong>); instead, we recommend that you use <strong>IDXGISwapChain::GetFrameStatistics</strong>.</p>
        /// </remarks>
        /// <doc-id>hh404546</doc-id>
        /// <unmanaged>HRESULT IDXGIDevice2::EnqueueSetEvent([In] void* hEvent)</unmanaged>
        /// <unmanaged-short>IDXGIDevice2::EnqueueSetEvent</unmanaged-short>
        public unsafe void EnqueueSetEvent(System.IntPtr hEvent)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)hEvent, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Allows the operating system to free the video memory of resources by discarding their content.</p>
        /// </summary>
        /// <param name = "numResources"><dd> <p>The number of resources in the <em>ppResources</em> argument array.</p> </dd></param>
        /// <param name = "resourcesOut"><dd> <p>An array of references to <strong><see cref = "SharpDX.DXGI.Resource"/></strong> interfaces for the resources to offer.</p> </dd></param>
        /// <param name = "priority"><dd> <p>A <strong><see cref = "SharpDX.DXGI.OfferResourcePriority"/></strong>-typed value that indicates how valuable data is.</p> </dd></param>
        /// <returns><p><strong>OfferResources</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if resources were successfully offered</li> <li>E_INVALIDARG if a resource in the array or the priority is invalid</li> </ul></returns>
        /// <remarks>
        /// <p>The priority value that the  <em>Priority</em> parameter specifies describes how valuable the caller considers the content to be.  The operating system uses the priority value to discard resources in order of priority. The operating system discards a resource that is offered with low priority before it discards a resource that is  offered with a higher priority.</p><p>If you call <strong>OfferResources</strong> to offer a resource while the resource is bound to the pipeline, the resource is unbound.  You cannot call <strong>OfferResources</strong> on a resource that is mapped.  After you offer a resource, the resource cannot be mapped or bound to the pipeline until you call the <strong>IDXGIDevice2::ReclaimResource</strong> method to reclaim the resource. You cannot call <strong>OfferResources</strong> to offer immutable resources.</p><p>To offer shared resources, call <strong>OfferResources</strong> on only one of the sharing devices.  To ensure exclusive access to the resources, you must use an <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> object and then call <strong>OfferResources</strong> only while you hold the mutex. In fact, you can't offer shared resources unless you use <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> because offering shared resources without using <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> isn't supported.</p><strong>Note</strong>??The user mode display driver might not immediately offer the resources that you specified in a call to <strong>OfferResources</strong>. The driver can postpone offering them until the next call to <strong>IDXGISwapChain::Present</strong>, <strong>IDXGISwapChain1::Present1</strong>, or <strong>ID3D11DeviceContext::Flush</strong>.?<p><strong>Platform Update for Windows?7:??</strong>The runtime validates that <strong>OfferResources</strong> is used correctly on non-shared resources but doesn't perform the intended functionality. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p>
        /// </remarks>
        /// <doc-id>hh404549</doc-id>
        /// <unmanaged>HRESULT IDXGIDevice2::OfferResources([In] unsigned int NumResources,[In, Buffer] const IDXGIResource** ppResources,[In] DXGI_OFFER_RESOURCE_PRIORITY Priority)</unmanaged>
        /// <unmanaged-short>IDXGIDevice2::OfferResources</unmanaged-short>
        public unsafe void OfferResources(System.Int32 numResources, SharpDX.ComArray<SharpDX.DXGI.Resource> resourcesOut, SharpDX.DXGI.OfferResourcePriority priority)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, numResources, (void *)(resourcesOut?.NativePointer ?? System.IntPtr.Zero), unchecked ((System.Int32)priority), (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Allows the operating system to free the video memory of resources by discarding their content.</p>
        /// </summary>
        /// <param name = "numResources"><dd> <p>The number of resources in the <em>ppResources</em> argument array.</p> </dd></param>
        /// <param name = "resourcesOut"><dd> <p>An array of references to <strong><see cref = "SharpDX.DXGI.Resource"/></strong> interfaces for the resources to offer.</p> </dd></param>
        /// <param name = "priority"><dd> <p>A <strong><see cref = "SharpDX.DXGI.OfferResourcePriority"/></strong>-typed value that indicates how valuable data is.</p> </dd></param>
        /// <returns><p><strong>OfferResources</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if resources were successfully offered</li> <li>E_INVALIDARG if a resource in the array or the priority is invalid</li> </ul></returns>
        /// <remarks>
        /// <p>The priority value that the  <em>Priority</em> parameter specifies describes how valuable the caller considers the content to be.  The operating system uses the priority value to discard resources in order of priority. The operating system discards a resource that is offered with low priority before it discards a resource that is  offered with a higher priority.</p><p>If you call <strong>OfferResources</strong> to offer a resource while the resource is bound to the pipeline, the resource is unbound.  You cannot call <strong>OfferResources</strong> on a resource that is mapped.  After you offer a resource, the resource cannot be mapped or bound to the pipeline until you call the <strong>IDXGIDevice2::ReclaimResource</strong> method to reclaim the resource. You cannot call <strong>OfferResources</strong> to offer immutable resources.</p><p>To offer shared resources, call <strong>OfferResources</strong> on only one of the sharing devices.  To ensure exclusive access to the resources, you must use an <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> object and then call <strong>OfferResources</strong> only while you hold the mutex. In fact, you can't offer shared resources unless you use <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> because offering shared resources without using <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> isn't supported.</p><strong>Note</strong>??The user mode display driver might not immediately offer the resources that you specified in a call to <strong>OfferResources</strong>. The driver can postpone offering them until the next call to <strong>IDXGISwapChain::Present</strong>, <strong>IDXGISwapChain1::Present1</strong>, or <strong>ID3D11DeviceContext::Flush</strong>.?<p><strong>Platform Update for Windows?7:??</strong>The runtime validates that <strong>OfferResources</strong> is used correctly on non-shared resources but doesn't perform the intended functionality. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p>
        /// </remarks>
        /// <doc-id>hh404549</doc-id>
        /// <unmanaged>HRESULT IDXGIDevice2::OfferResources([In] unsigned int NumResources,[In, Buffer] const IDXGIResource** ppResources,[In] DXGI_OFFER_RESOURCE_PRIORITY Priority)</unmanaged>
        /// <unmanaged-short>IDXGIDevice2::OfferResources</unmanaged-short>
        private unsafe void OfferResources(System.Int32 numResources, System.IntPtr resourcesOut, SharpDX.DXGI.OfferResourcePriority priority)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, numResources, (void *)resourcesOut, unchecked ((System.Int32)priority), (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Restores access to resources that were previously offered by calling <strong>IDXGIDevice2::OfferResources</strong>.</p>
        /// </summary>
        /// <param name = "numResources">No documentation.</param>
        /// <param name = "resourcesOut">No documentation.</param>
        /// <param name = "discardedRef">No documentation.</param>
        /// <returns><p><strong>ReclaimResources</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if resources were successfully reclaimed</li> <li>E_INVALIDARG if the resources are invalid</li> </ul></returns>
        /// <remarks>
        /// <p>After you call <strong>IDXGIDevice2::OfferResources</strong> to offer one or more resources, you must call <strong>ReclaimResources</strong> before you can use those resources again.  You must check the values in the array at <em>pDiscarded</em> to determine whether each resource?s content was discarded. If a resource?s content was discarded while it was offered, its current content is undefined. Therefore, you must overwrite the resource?s content before you use the resource.</p><p>To reclaim shared resources, call <strong>ReclaimResources</strong> only on one of the sharing devices.  To ensure exclusive access to the resources, you must use an <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> object and then call <strong>ReclaimResources</strong> only while you hold the mutex.</p><p><strong>Platform Update for Windows?7:??</strong>The runtime validates that <strong>ReclaimResources</strong> is used correctly on non-shared resources but doesn't perform the intended functionality. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p>
        /// </remarks>
        /// <doc-id>hh404551</doc-id>
        /// <unmanaged>HRESULT IDXGIDevice2::ReclaimResources([In] unsigned int NumResources,[In, Buffer] const IDXGIResource** ppResources,[Out, Buffer, Optional] BOOL* pDiscarded)</unmanaged>
        /// <unmanaged-short>IDXGIDevice2::ReclaimResources</unmanaged-short>
        public unsafe void ReclaimResources(System.Int32 numResources, SharpDX.ComArray<SharpDX.DXGI.Resource> resourcesOut, SharpDX.Mathematics.Interop.RawBool[] discardedRef)
        {
            SharpDX.Result __result__;
            fixed (void *discardedRef_ = discardedRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, numResources, (void *)(resourcesOut?.NativePointer ?? System.IntPtr.Zero), discardedRef_, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Restores access to resources that were previously offered by calling <strong>IDXGIDevice2::OfferResources</strong>.</p>
        /// </summary>
        /// <param name = "numResources">No documentation.</param>
        /// <param name = "resourcesOut">No documentation.</param>
        /// <param name = "discardedRef">No documentation.</param>
        /// <returns><p><strong>ReclaimResources</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if resources were successfully reclaimed</li> <li>E_INVALIDARG if the resources are invalid</li> </ul></returns>
        /// <remarks>
        /// <p>After you call <strong>IDXGIDevice2::OfferResources</strong> to offer one or more resources, you must call <strong>ReclaimResources</strong> before you can use those resources again.  You must check the values in the array at <em>pDiscarded</em> to determine whether each resource?s content was discarded. If a resource?s content was discarded while it was offered, its current content is undefined. Therefore, you must overwrite the resource?s content before you use the resource.</p><p>To reclaim shared resources, call <strong>ReclaimResources</strong> only on one of the sharing devices.  To ensure exclusive access to the resources, you must use an <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> object and then call <strong>ReclaimResources</strong> only while you hold the mutex.</p><p><strong>Platform Update for Windows?7:??</strong>The runtime validates that <strong>ReclaimResources</strong> is used correctly on non-shared resources but doesn't perform the intended functionality. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p>
        /// </remarks>
        /// <doc-id>hh404551</doc-id>
        /// <unmanaged>HRESULT IDXGIDevice2::ReclaimResources([In] unsigned int NumResources,[In, Buffer] const IDXGIResource** ppResources,[Out, Buffer, Optional] BOOL* pDiscarded)</unmanaged>
        /// <unmanaged-short>IDXGIDevice2::ReclaimResources</unmanaged-short>
        private unsafe void ReclaimResources(System.Int32 numResources, System.IntPtr resourcesOut, System.IntPtr discardedRef)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, numResources, (void *)resourcesOut, (void *)discardedRef, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("6007896c-3244-4afd-bf18-a6d3beda5023")]
    public partial class Device3 : SharpDX.DXGI.Device2
    {
        public Device3(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device3(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device3(nativePtr);
        /// <summary>
        /// <p>Trims the graphics memory allocated by the <strong><see cref = "SharpDX.DXGI.Device3"/></strong> DXGI device on the app's behalf.</p><p>For apps that render with DirectX, graphics drivers periodically allocate internal memory buffers in order to speed up subsequent rendering requests. These memory allocations count against the app's memory usage for PLM  and in general lead to increased memory usage by the overall system.</p><p>Starting in Windows?8.1, apps that render with Direct2D and/or Direct3D (including <strong>CoreWindow</strong> and XAML interop) must call <strong>Trim</strong> in response to the PLM suspend callback. The Direct3D runtime and the graphics driver will discard internal memory buffers allocated for the app, reducing its memory footprint.</p><p>Calling this method does not change the rendering state of the graphics device and it has no effect on rendering operations. There is a brief performance hit when internal buffers are reallocated during the first rendering operations after the <strong>Trim</strong> call, therefore apps should only call <strong>Trim</strong> when going idle for a period of time (in response to PLM suspend, for example).</p><p>Apps should ensure that they call <strong>Trim</strong> as one of the last D3D operations done before going idle. Direct3D will normally defer the destruction of D3D objects. Calling <strong>Trim</strong>, however, forces Direct3D to destroy objects immediately. For this reason, it is not guaranteed that releasing the final reference on Direct3D objects after calling <strong>Trim</strong> will cause the object to be destroyed and memory to be deallocated  before the app suspends.</p><p>Similar to <strong>ID3D11DeviceContext::Flush</strong>, apps should call <strong>ID3D11DeviceContext::ClearState</strong> before calling <strong>Trim</strong>. <strong>ClearState</strong> clears the Direct3D pipeline bindings, ensuring that Direct3D does not hold any references to the Direct3D objects you are trying to release.</p><p>It is also prudent to release references on middleware before calling <strong>Trim</strong>, as that middleware may also need to release references
        /// to Direct3D objects.</p>
        /// </summary>
        /// <doc-id>dn280346</doc-id>
        /// <unmanaged>void IDXGIDevice3::Trim()</unmanaged>
        /// <unmanaged-short>IDXGIDevice3::Trim</unmanaged-short>
        public unsafe void Trim()
        {
            SharpDX.DXGI.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[17]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("95B4F95F-D8DA-4CA4-9EE6-3B76D5968A10")]
    public partial class Device4 : SharpDX.DXGI.Device3
    {
        public Device4(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device4(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device4(nativePtr);
        /// <summary>
        /// <p>Allows the operating system to free the video memory of resources, including both discarding the content and de-committing the memory.</p>
        /// </summary>
        /// <param name = "numResources"><dd>  <p>The number of resources in the <em>ppResources</em> argument array.</p> </dd></param>
        /// <param name = "resourcesOut"><dd>  <p>An array of references to <strong><see cref = "SharpDX.DXGI.Resource"/></strong> interfaces for the resources to offer.</p> </dd></param>
        /// <param name = "priority"><dd>  <p>A <strong><see cref = "SharpDX.DXGI.OfferResourcePriority"/></strong>-typed value that indicates how valuable data is.</p> </dd></param>
        /// <param name = "flags"><dd>  <p>Specifies the <strong><see cref = "SharpDX.DXGI.OfferResourceFlags"/></strong>.</p> </dd></param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code, which can include E_INVALIDARG if a resource in the array, or the priority, is invalid.</p></returns>
        /// <remarks>
        /// <p><strong>OfferResources1</strong> (an extension of the original <strong>IDXGIDevice2::OfferResources</strong> API) enables D3D based applications to allow de-committing of an allocation?s backing store to reduce system commit under low memory conditions. 
        /// A de-committed allocation cannot be reused, so opting in to the new DXGI_OFFER_RESOURCE_FLAG_ALLOW_DECOMMIT flag means the new reclaim results must be properly handled. Refer to the flag descriptions in <strong><see cref = "SharpDX.DXGI.ReclaimResourceResults"/></strong> and the Example below.</p><p><strong>OfferResources1</strong> and <strong>ReclaimResources1</strong> may <em>not</em> be used interchangeably with <strong>OfferResources</strong> and <strong>ReclaimResources</strong>. 
        /// </p><p>The priority value that the  <em>Priority</em> parameter specifies describes how valuable the caller considers the content to be.  The operating system uses the priority value to discard resources in order of priority. The operating system discards a resource that is offered with low priority before it discards a resource that is  offered with a higher priority.</p><p>If you call <strong>OfferResources1</strong> to offer a resource while the resource is bound to the pipeline, the resource is unbound.  You cannot call <strong>OfferResources1</strong> on a resource that is mapped.  After you offer a resource, the resource cannot be mapped or bound to the pipeline until you call the <strong>ReclaimResources1</strong> method to reclaim the resource. You cannot call <strong>OfferResources1</strong> to offer immutable resources.</p><p>To offer shared resources, call <strong>OfferResources1</strong> on only one of the sharing devices.  To ensure exclusive access to the resources, you must use an <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> object and then call <strong>OfferResources1</strong> only while you hold the mutex. In fact, you can't offer shared resources unless you use <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> because offering shared resources without using <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> isn't supported.</p><p>The user mode display driver might not immediately offer the resources that you specified in a call to <strong>OfferResources1</strong>. The driver can postpone offering them until the next call to <strong>IDXGISwapChain::Present</strong>, <strong>IDXGISwapChain1::Present1</strong>, or <strong>ID3D11DeviceContext::Flush</strong>.</p>
        /// </remarks>
        /// <doc-id>mt732705</doc-id>
        /// <unmanaged>HRESULT IDXGIDevice4::OfferResources1([In] unsigned int NumResources,[In, Buffer] const IDXGIResource** ppResources,[In] DXGI_OFFER_RESOURCE_PRIORITY Priority,[In] unsigned int Flags)</unmanaged>
        /// <unmanaged-short>IDXGIDevice4::OfferResources1</unmanaged-short>
        public unsafe void OfferResources1(System.Int32 numResources, SharpDX.DXGI.Resource[] resourcesOut, SharpDX.DXGI.OfferResourcePriority priority, System.Int32 flags)
        {
            System.IntPtr*resourcesOut_;
            resourcesOut_ = (System.IntPtr*)0;
            if (resourcesOut != null)
            {
                System.IntPtr*_resourcesOut = stackalloc System.IntPtr[resourcesOut.Length];
                resourcesOut_ = _resourcesOut;
            }

            SharpDX.Result __result__;
            if (resourcesOut != null)
                for (int i = 0; i < resourcesOut.Length; ++i)
                    (resourcesOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Resource>(resourcesOut[i]);
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, numResources, (void *)resourcesOut_, unchecked ((System.Int32)priority), flags, (*(void ***)this._nativePointer)[18]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Restores access to resources that were previously offered by calling <strong>IDXGIDevice4::OfferResources1</strong>.</p>
        /// </summary>
        /// <param name = "numResources">No documentation.</param>
        /// <param name = "resourcesOut">No documentation.</param>
        /// <param name = "resultsRef">No documentation.</param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code, including E_INVALIDARG if the resources are invalid.</p></returns>
        /// <remarks>
        /// <p>After you call <strong>OfferResources1</strong> to offer one or more resources, you must call <strong>ReclaimResources1</strong> before you can use those resources again.</p><p>To reclaim shared resources, call <strong>ReclaimResources1</strong> only on one of the sharing devices.  To ensure exclusive access to the resources, you must use an <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> object and then call <strong>ReclaimResources1</strong> only while you hold the mutex.</p>
        /// </remarks>
        /// <doc-id>mt732706</doc-id>
        /// <unmanaged>HRESULT IDXGIDevice4::ReclaimResources1([In] unsigned int NumResources,[In, Buffer] const IDXGIResource** ppResources,[Out, Buffer] DXGI_RECLAIM_RESOURCE_RESULTS* pResults)</unmanaged>
        /// <unmanaged-short>IDXGIDevice4::ReclaimResources1</unmanaged-short>
        public unsafe void ReclaimResources1(System.Int32 numResources, SharpDX.DXGI.Resource[] resourcesOut, SharpDX.DXGI.ReclaimResourceResults[] resultsRef)
        {
            System.IntPtr*resourcesOut_;
            resourcesOut_ = (System.IntPtr*)0;
            if (resourcesOut != null)
            {
                System.IntPtr*_resourcesOut = stackalloc System.IntPtr[resourcesOut.Length];
                resourcesOut_ = _resourcesOut;
            }

            SharpDX.Result __result__;
            if (resourcesOut != null)
                for (int i = 0; i < resourcesOut.Length; ++i)
                    (resourcesOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Resource>(resourcesOut[i]);
            fixed (void *resultsRef_ = resultsRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, numResources, (void *)resourcesOut_, resultsRef_, (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Allows the operating system to free the video memory of resources, including both discarding the content and de-committing the memory.</p>
        /// </summary>
        /// <param name = "numResources"><dd>  <p>The number of resources in the <em>ppResources</em> argument array.</p> </dd></param>
        /// <param name = "resourcesOut"><dd>  <p>An array of references to <strong><see cref = "SharpDX.DXGI.Resource"/></strong> interfaces for the resources to offer.</p> </dd></param>
        /// <param name = "priority"><dd>  <p>A <strong><see cref = "SharpDX.DXGI.OfferResourcePriority"/></strong>-typed value that indicates how valuable data is.</p> </dd></param>
        /// <param name = "flags"><dd>  <p>Specifies the <strong><see cref = "SharpDX.DXGI.OfferResourceFlags"/></strong>.</p> </dd></param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code, which can include E_INVALIDARG if a resource in the array, or the priority, is invalid.</p></returns>
        /// <remarks>
        /// <p><strong>OfferResources1</strong> (an extension of the original <strong>IDXGIDevice2::OfferResources</strong> API) enables D3D based applications to allow de-committing of an allocation?s backing store to reduce system commit under low memory conditions. 
        /// A de-committed allocation cannot be reused, so opting in to the new DXGI_OFFER_RESOURCE_FLAG_ALLOW_DECOMMIT flag means the new reclaim results must be properly handled. Refer to the flag descriptions in <strong><see cref = "SharpDX.DXGI.ReclaimResourceResults"/></strong> and the Example below.</p><p><strong>OfferResources1</strong> and <strong>ReclaimResources1</strong> may <em>not</em> be used interchangeably with <strong>OfferResources</strong> and <strong>ReclaimResources</strong>. 
        /// </p><p>The priority value that the  <em>Priority</em> parameter specifies describes how valuable the caller considers the content to be.  The operating system uses the priority value to discard resources in order of priority. The operating system discards a resource that is offered with low priority before it discards a resource that is  offered with a higher priority.</p><p>If you call <strong>OfferResources1</strong> to offer a resource while the resource is bound to the pipeline, the resource is unbound.  You cannot call <strong>OfferResources1</strong> on a resource that is mapped.  After you offer a resource, the resource cannot be mapped or bound to the pipeline until you call the <strong>ReclaimResources1</strong> method to reclaim the resource. You cannot call <strong>OfferResources1</strong> to offer immutable resources.</p><p>To offer shared resources, call <strong>OfferResources1</strong> on only one of the sharing devices.  To ensure exclusive access to the resources, you must use an <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> object and then call <strong>OfferResources1</strong> only while you hold the mutex. In fact, you can't offer shared resources unless you use <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> because offering shared resources without using <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> isn't supported.</p><p>The user mode display driver might not immediately offer the resources that you specified in a call to <strong>OfferResources1</strong>. The driver can postpone offering them until the next call to <strong>IDXGISwapChain::Present</strong>, <strong>IDXGISwapChain1::Present1</strong>, or <strong>ID3D11DeviceContext::Flush</strong>.</p>
        /// </remarks>
        /// <doc-id>mt732705</doc-id>
        /// <unmanaged>HRESULT IDXGIDevice4::OfferResources1([In] unsigned int NumResources,[In, Buffer] const IDXGIResource** ppResources,[In] DXGI_OFFER_RESOURCE_PRIORITY Priority,[In] unsigned int Flags)</unmanaged>
        /// <unmanaged-short>IDXGIDevice4::OfferResources1</unmanaged-short>
        public unsafe void OfferResources1(System.Int32 numResources, SharpDX.ComArray<SharpDX.DXGI.Resource> resourcesOut, SharpDX.DXGI.OfferResourcePriority priority, System.Int32 flags)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, numResources, (void *)(resourcesOut?.NativePointer ?? System.IntPtr.Zero), unchecked ((System.Int32)priority), flags, (*(void ***)this._nativePointer)[18]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Allows the operating system to free the video memory of resources, including both discarding the content and de-committing the memory.</p>
        /// </summary>
        /// <param name = "numResources"><dd>  <p>The number of resources in the <em>ppResources</em> argument array.</p> </dd></param>
        /// <param name = "resourcesOut"><dd>  <p>An array of references to <strong><see cref = "SharpDX.DXGI.Resource"/></strong> interfaces for the resources to offer.</p> </dd></param>
        /// <param name = "priority"><dd>  <p>A <strong><see cref = "SharpDX.DXGI.OfferResourcePriority"/></strong>-typed value that indicates how valuable data is.</p> </dd></param>
        /// <param name = "flags"><dd>  <p>Specifies the <strong><see cref = "SharpDX.DXGI.OfferResourceFlags"/></strong>.</p> </dd></param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code, which can include E_INVALIDARG if a resource in the array, or the priority, is invalid.</p></returns>
        /// <remarks>
        /// <p><strong>OfferResources1</strong> (an extension of the original <strong>IDXGIDevice2::OfferResources</strong> API) enables D3D based applications to allow de-committing of an allocation?s backing store to reduce system commit under low memory conditions. 
        /// A de-committed allocation cannot be reused, so opting in to the new DXGI_OFFER_RESOURCE_FLAG_ALLOW_DECOMMIT flag means the new reclaim results must be properly handled. Refer to the flag descriptions in <strong><see cref = "SharpDX.DXGI.ReclaimResourceResults"/></strong> and the Example below.</p><p><strong>OfferResources1</strong> and <strong>ReclaimResources1</strong> may <em>not</em> be used interchangeably with <strong>OfferResources</strong> and <strong>ReclaimResources</strong>. 
        /// </p><p>The priority value that the  <em>Priority</em> parameter specifies describes how valuable the caller considers the content to be.  The operating system uses the priority value to discard resources in order of priority. The operating system discards a resource that is offered with low priority before it discards a resource that is  offered with a higher priority.</p><p>If you call <strong>OfferResources1</strong> to offer a resource while the resource is bound to the pipeline, the resource is unbound.  You cannot call <strong>OfferResources1</strong> on a resource that is mapped.  After you offer a resource, the resource cannot be mapped or bound to the pipeline until you call the <strong>ReclaimResources1</strong> method to reclaim the resource. You cannot call <strong>OfferResources1</strong> to offer immutable resources.</p><p>To offer shared resources, call <strong>OfferResources1</strong> on only one of the sharing devices.  To ensure exclusive access to the resources, you must use an <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> object and then call <strong>OfferResources1</strong> only while you hold the mutex. In fact, you can't offer shared resources unless you use <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> because offering shared resources without using <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> isn't supported.</p><p>The user mode display driver might not immediately offer the resources that you specified in a call to <strong>OfferResources1</strong>. The driver can postpone offering them until the next call to <strong>IDXGISwapChain::Present</strong>, <strong>IDXGISwapChain1::Present1</strong>, or <strong>ID3D11DeviceContext::Flush</strong>.</p>
        /// </remarks>
        /// <doc-id>mt732705</doc-id>
        /// <unmanaged>HRESULT IDXGIDevice4::OfferResources1([In] unsigned int NumResources,[In, Buffer] const IDXGIResource** ppResources,[In] DXGI_OFFER_RESOURCE_PRIORITY Priority,[In] unsigned int Flags)</unmanaged>
        /// <unmanaged-short>IDXGIDevice4::OfferResources1</unmanaged-short>
        private unsafe void OfferResources1(System.Int32 numResources, System.IntPtr resourcesOut, SharpDX.DXGI.OfferResourcePriority priority, System.Int32 flags)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, numResources, (void *)resourcesOut, unchecked ((System.Int32)priority), flags, (*(void ***)this._nativePointer)[18]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Restores access to resources that were previously offered by calling <strong>IDXGIDevice4::OfferResources1</strong>.</p>
        /// </summary>
        /// <param name = "numResources">No documentation.</param>
        /// <param name = "resourcesOut">No documentation.</param>
        /// <param name = "resultsRef">No documentation.</param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code, including E_INVALIDARG if the resources are invalid.</p></returns>
        /// <remarks>
        /// <p>After you call <strong>OfferResources1</strong> to offer one or more resources, you must call <strong>ReclaimResources1</strong> before you can use those resources again.</p><p>To reclaim shared resources, call <strong>ReclaimResources1</strong> only on one of the sharing devices.  To ensure exclusive access to the resources, you must use an <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> object and then call <strong>ReclaimResources1</strong> only while you hold the mutex.</p>
        /// </remarks>
        /// <doc-id>mt732706</doc-id>
        /// <unmanaged>HRESULT IDXGIDevice4::ReclaimResources1([In] unsigned int NumResources,[In, Buffer] const IDXGIResource** ppResources,[Out, Buffer] DXGI_RECLAIM_RESOURCE_RESULTS* pResults)</unmanaged>
        /// <unmanaged-short>IDXGIDevice4::ReclaimResources1</unmanaged-short>
        public unsafe void ReclaimResources1(System.Int32 numResources, SharpDX.ComArray<SharpDX.DXGI.Resource> resourcesOut, SharpDX.DXGI.ReclaimResourceResults[] resultsRef)
        {
            SharpDX.Result __result__;
            fixed (void *resultsRef_ = resultsRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, numResources, (void *)(resourcesOut?.NativePointer ?? System.IntPtr.Zero), resultsRef_, (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Restores access to resources that were previously offered by calling <strong>IDXGIDevice4::OfferResources1</strong>.</p>
        /// </summary>
        /// <param name = "numResources">No documentation.</param>
        /// <param name = "resourcesOut">No documentation.</param>
        /// <param name = "resultsRef">No documentation.</param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code, including E_INVALIDARG if the resources are invalid.</p></returns>
        /// <remarks>
        /// <p>After you call <strong>OfferResources1</strong> to offer one or more resources, you must call <strong>ReclaimResources1</strong> before you can use those resources again.</p><p>To reclaim shared resources, call <strong>ReclaimResources1</strong> only on one of the sharing devices.  To ensure exclusive access to the resources, you must use an <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> object and then call <strong>ReclaimResources1</strong> only while you hold the mutex.</p>
        /// </remarks>
        /// <doc-id>mt732706</doc-id>
        /// <unmanaged>HRESULT IDXGIDevice4::ReclaimResources1([In] unsigned int NumResources,[In, Buffer] const IDXGIResource** ppResources,[Out, Buffer] DXGI_RECLAIM_RESOURCE_RESULTS* pResults)</unmanaged>
        /// <unmanaged-short>IDXGIDevice4::ReclaimResources1</unmanaged-short>
        private unsafe void ReclaimResources1(System.Int32 numResources, System.IntPtr resourcesOut, System.IntPtr resultsRef)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, numResources, (void *)resourcesOut, (void *)resultsRef, (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("3d3e0379-f9de-4d58-bb6c-18d62992f1a6")]
    public partial class DeviceChild : SharpDX.DXGI.DXGIObject
    {
        public DeviceChild(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DeviceChild(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DeviceChild(nativePtr);
        /// <summary>
        /// <p>Retrieves the device.</p>
        /// </summary>
        /// <param name = "riid"><dd>  <p>The reference id for the device.</p> </dd></param>
        /// <param name = "deviceOut"><dd>  <p>The address of a reference to the device.</p> </dd></param>
        /// <returns><p>A code that indicates success or failure (see DXGI_ERROR).</p></returns>
        /// <remarks>
        /// <p>The type of interface that is returned can be any interface published by the device. For example, it could be an <see cref = "SharpDX.DXGI.Device"/> * called pDevice, and therefore the REFIID would be obtained by calling __uuidof(pDevice).</p>
        /// </remarks>
        /// <doc-id>bb174529</doc-id>
        /// <unmanaged>HRESULT IDXGIDeviceSubObject::GetDevice([In] const GUID&amp; riid,[Out] void** ppDevice)</unmanaged>
        /// <unmanaged-short>IDXGIDeviceSubObject::GetDevice</unmanaged-short>
        public unsafe void GetDevice(System.Guid riid, out System.IntPtr deviceOut)
        {
            SharpDX.Result __result__;
            fixed (void *deviceOut_ = &deviceOut)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &riid, deviceOut_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("ea9dbf1a-c88e-4486-854a-98aa0138f30c")]
    public partial class DisplayControl : SharpDX.ComObject
    {
        public DisplayControl(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DisplayControl(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DisplayControl(nativePtr);
        /// <summary>
        /// <p>Retrieves a Boolean value that indicates whether the operating system's stereoscopic 3D display behavior is enabled.</p>
        /// </summary>
        /// <remarks>
        /// <p>You pass a Boolean value to the  <strong>IDXGIDisplayControl::SetStereoEnabled</strong> method to either enable or disable the operating system's stereoscopic 3D display behavior. TRUE enables the operating system's stereoscopic 3D display behavior and <see cref = "SharpDX.Result.False"/> disables it.</p>
        /// </remarks>
        /// <doc-id>hh404553</doc-id>
        /// <unmanaged>IsStereoEnabled</unmanaged>
        /// <unmanaged-short>IsStereoEnabled</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsStereoEnabled
        {
            get => IsStereoEnabled_();
        }

        /// <summary>
        /// <p>Set a Boolean value to either enable or disable the operating system's stereoscopic 3D display behavior.</p>
        /// </summary>
        /// <remarks>
        /// <p><strong>Platform Update for Windows?7:??</strong>On Windows?7 or Windows Server?2008?R2 with the Platform Update for Windows?7 installed, <strong>SetStereoEnabled</strong> doesn't change stereoscopic 3D display behavior because stereoscopic 3D display behavior isn?t available with the Platform Update for Windows?7. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p>
        /// </remarks>
        /// <doc-id>hh404554</doc-id>
        /// <unmanaged>SetStereoEnabled</unmanaged>
        /// <unmanaged-short>SetStereoEnabled</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool StereoEnabled
        {
            set => SetStereoEnabled(value);
        }

        /// <summary>
        /// <p>Retrieves a Boolean value that indicates whether the operating system's stereoscopic 3D display behavior is enabled.</p>
        /// </summary>
        /// <returns><p><strong>IsStereoEnabled</strong> returns TRUE when the operating system's stereoscopic 3D display behavior is enabled and <see cref = "SharpDX.Result.False"/> when this behavior is disabled.</p><p><strong>Platform Update for Windows?7:??</strong>On Windows?7 or Windows Server?2008?R2 with the Platform Update for Windows?7 installed, <strong>IsStereoEnabled</strong> always returns <see cref = "SharpDX.Result.False"/> because stereoscopic 3D display behavior isn?t available with the Platform Update for Windows?7. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p></returns>
        /// <remarks>
        /// <p>You pass a Boolean value to the  <strong>IDXGIDisplayControl::SetStereoEnabled</strong> method to either enable or disable the operating system's stereoscopic 3D display behavior. TRUE enables the operating system's stereoscopic 3D display behavior and <see cref = "SharpDX.Result.False"/> disables it.</p>
        /// </remarks>
        /// <doc-id>hh404553</doc-id>
        /// <unmanaged>BOOL IDXGIDisplayControl::IsStereoEnabled()</unmanaged>
        /// <unmanaged-short>IDXGIDisplayControl::IsStereoEnabled</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawBool IsStereoEnabled_()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[3]);
            return __result__;
        }

        /// <summary>
        /// <p>Set a Boolean value to either enable or disable the operating system's stereoscopic 3D display behavior.</p>
        /// </summary>
        /// <param name = "enabled"><dd> <p>A Boolean value that either enables or disables the operating system's stereoscopic 3D display behavior. TRUE enables the operating system's stereoscopic 3D display behavior and <see cref = "SharpDX.Result.False"/> disables it.</p> </dd></param>
        /// <remarks>
        /// <p><strong>Platform Update for Windows?7:??</strong>On Windows?7 or Windows Server?2008?R2 with the Platform Update for Windows?7 installed, <strong>SetStereoEnabled</strong> doesn't change stereoscopic 3D display behavior because stereoscopic 3D display behavior isn?t available with the Platform Update for Windows?7. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p>
        /// </remarks>
        /// <doc-id>hh404554</doc-id>
        /// <unmanaged>void IDXGIDisplayControl::SetStereoEnabled([In] BOOL enabled)</unmanaged>
        /// <unmanaged-short>IDXGIDisplayControl::SetStereoEnabled</unmanaged-short>
        internal unsafe void SetStereoEnabled(SharpDX.Mathematics.Interop.RawBool enabled)
        {
            SharpDX.DXGI.LocalInterop.CalliStdCallvoid0(this._nativePointer, enabled, (*(void ***)this._nativePointer)[4]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("119E7452-DE9E-40fe-8806-88F90C12B441")]
    public partial class DXGIDebug : SharpDX.ComObject
    {
        public DXGIDebug(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DXGIDebug(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DXGIDebug(nativePtr);
        /// <summary>
        /// <p>Reports info about the lifetime of an object or objects.</p>
        /// </summary>
        /// <param name = "apiid"><dd> <p>The globally unique identifier (<see cref = "System.Guid"/>) of the object or objects to get info about. Use one of the <strong>DXGI_DEBUG_ID</strong> GUIDs.</p> </dd></param>
        /// <param name = "flags"><dd> <p>A <strong><see cref = "SharpDX.DXGI.DebugRloFlags"/></strong>-typed value that specifies the amount of info to report.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780352</doc-id>
        /// <unmanaged>HRESULT IDXGIDebug::ReportLiveObjects([In] GUID apiid,[In] DXGI_DEBUG_RLO_FLAGS flags)</unmanaged>
        /// <unmanaged-short>IDXGIDebug::ReportLiveObjects</unmanaged-short>
        public unsafe void ReportLiveObjects(System.Guid apiid, SharpDX.DXGI.DebugRloFlags flags)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, apiid, unchecked ((System.Int32)flags), (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("c5a05f0c-16f2-4adf-9f4d-a8c4d58ac550")]
    public partial class DXGIDebug1 : SharpDX.DXGI.DXGIDebug
    {
        public DXGIDebug1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DXGIDebug1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DXGIDebug1(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>IsLeakTrackingEnabledForThread</unmanaged>
        /// <unmanaged-short>IsLeakTrackingEnabledForThread</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsLeakTrackingEnabledForThread
        {
            get => IsLeakTrackingEnabledForThread_();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>void IDXGIDebug1::EnableLeakTrackingForThread()</unmanaged>
        /// <unmanaged-short>IDXGIDebug1::EnableLeakTrackingForThread</unmanaged-short>
        public unsafe void EnableLeakTrackingForThread()
        {
            SharpDX.DXGI.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[4]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>void IDXGIDebug1::DisableLeakTrackingForThread()</unmanaged>
        /// <unmanaged-short>IDXGIDebug1::DisableLeakTrackingForThread</unmanaged-short>
        public unsafe void DisableLeakTrackingForThread()
        {
            SharpDX.DXGI.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[5]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>BOOL IDXGIDebug1::IsLeakTrackingEnabledForThread()</unmanaged>
        /// <unmanaged-short>IDXGIDebug1::IsLeakTrackingEnabledForThread</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawBool IsLeakTrackingEnabledForThread_()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[6]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("aec22fb8-76f3-4639-9be0-28eb43a67a2e")]
    public partial class DXGIObject : SharpDX.ComObject
    {
        public DXGIObject(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DXGIObject(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DXGIObject(nativePtr);
        /// <summary>
        /// <p>Sets application-defined data to the object and associates that data with a <see cref = "System.Guid"/>.</p>
        /// </summary>
        /// <param name = "name"><dd>  <p>A <see cref = "System.Guid"/> that identifies the data. Use this <see cref = "System.Guid"/> in a call to <strong>GetPrivateData</strong> to get the data.</p> </dd></param>
        /// <param name = "dataSize"><dd>  <p>The size of the object's data.</p> </dd></param>
        /// <param name = "dataRef"><dd>  <p>A reference to the object's data.</p> </dd></param>
        /// <returns><p>Returns one of the DXGI_ERROR values.</p></returns>
        /// <remarks>
        /// <p><strong>SetPrivateData</strong> makes a copy of the specified data and stores it with the object.</p><p>Private data that <strong>SetPrivateData</strong> stores in the object occupies the same storage space as private data that is stored by associated Direct3D objects (for example, by a Microsoft Direct3D?11 device through <strong>ID3D11Device::SetPrivateData</strong> or by a Direct3D?11 child device through <strong>ID3D11DeviceChild::SetPrivateData</strong>).</p><p>The debug layer reports memory leaks by outputting a list of object interface references along with their friendly names. The default friendly name is "&lt;unnamed&gt;". You can set the friendly name so that you can determine if the corresponding object interface reference caused the leak. To set the friendly name, use the <strong>SetPrivateData</strong> method and the well-known private data <see cref = "System.Guid"/> (<strong><see cref = "DebugObjectName"/></strong>) that is in D3Dcommon.h. For example, to give pContext a friendly name of <em>My name</em>, use the following code:</p><pre> static const char c_szName[] = "My name";
        /// hr = pContext-&gt;SetPrivateData( <see cref = "DebugObjectName"/>, sizeof( c_szName ) - 1, c_szName );
        /// </pre><p>You can use <strong><see cref = "DebugObjectName"/></strong> to track down memory leaks and understand performance characteristics of your applications. This information is reflected in the output of the debug layer that is related to memory leaks (<strong>ID3D11Debug::ReportLiveDeviceObjects</strong>) and with the event tracing for Windows events that we've added to Windows?8.
        /// </p>
        /// </remarks>
        /// <doc-id>bb174544</doc-id>
        /// <unmanaged>HRESULT IDXGIObject::SetPrivateData([In] const GUID&amp; Name,[In] unsigned int DataSize,[In, Buffer] const void* pData)</unmanaged>
        /// <unmanaged-short>IDXGIObject::SetPrivateData</unmanaged-short>
        public unsafe void SetPrivateData(System.Guid name, System.Int32 dataSize, System.IntPtr dataRef)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &name, dataSize, (void *)dataRef, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Set an interface in the object's private data.</p>
        /// </summary>
        /// <param name = "name"><dd>  <p>A <see cref = "System.Guid"/> identifying the interface.</p> </dd></param>
        /// <param name = "unknownRef"><dd>  <p>The interface to set.</p> </dd></param>
        /// <returns><p>Returns one of the following DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <p>This API associates an interface reference with the object.</p><p>When the interface is set its reference count is incremented. When the data are overwritten (by calling SPD or SPDI with the same <see cref = "System.Guid"/>) or the object is destroyed, ::Release() is called and the interface's reference count is decremented.</p>
        /// </remarks>
        /// <doc-id>bb174545</doc-id>
        /// <unmanaged>HRESULT IDXGIObject::SetPrivateDataInterface([In] const GUID&amp; Name,[In, Optional] const IUnknown* pUnknown)</unmanaged>
        /// <unmanaged-short>IDXGIObject::SetPrivateDataInterface</unmanaged-short>
        public unsafe void SetPrivateDataInterface(System.Guid name, SharpDX.IUnknown unknownRef)
        {
            System.IntPtr unknownRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            unknownRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(unknownRef);
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &name, (void *)unknownRef_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Get a reference to the object's data.</p>
        /// </summary>
        /// <param name = "name"><dd>  <p>A <see cref = "System.Guid"/> identifying the data.</p> </dd></param>
        /// <param name = "dataSizeRef"><dd>  <p>The size of the data.</p> </dd></param>
        /// <param name = "dataRef"><dd>  <p>Pointer to the data.</p> </dd></param>
        /// <returns><p>Returns one of the following DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <p>If the data returned is a reference to an <strong><see cref = "SharpDX.IUnknown"/></strong>, or one of its derivative classes, previously set by <strong>IDXGIObject::SetPrivateDataInterface</strong>, you must call <strong>::Release()</strong> on the reference before the reference is freed to decrement the reference count.</p><p>You can pass <strong>GUID_DeviceType</strong> in the <em>Name</em> parameter of <strong>GetPrivateData</strong> to retrieve the device type from the display adapter object (<strong><see cref = "SharpDX.DXGI.Adapter"/></strong>, <strong><see cref = "SharpDX.DXGI.Adapter1"/></strong>, <strong><see cref = "SharpDX.DXGI.Adapter2"/></strong>). </p><p><strong>To get the type of device on which the display adapter was created</strong></p><ol> <li>Call <strong>IUnknown::QueryInterface</strong> on the <strong><see cref = "SharpDX.Direct3D11.Device"/></strong> or <strong>ID3D10Device</strong> object to retrieve the <strong><see cref = "SharpDX.DXGI.Device"/></strong> object.</li> <li>Call <strong>GetParent</strong> on the <strong><see cref = "SharpDX.DXGI.Device"/></strong> object to retrieve the <strong><see cref = "SharpDX.DXGI.Adapter"/></strong> object.</li> <li>Call <strong>GetPrivateData</strong> on the <strong><see cref = "SharpDX.DXGI.Adapter"/></strong> object with <strong>GUID_DeviceType</strong> to retrieve the type of device on which the display adapter was created. <em>pData</em> will point to a value from the driver-type enumeration (for example, a value from <strong><see cref = "SharpDX.Direct3D.DriverType"/></strong>).</li> </ol><p>On Windows?7 or earlier, this type is either a value from <strong>D3D10_DRIVER_TYPE</strong> or <strong><see cref = "SharpDX.Direct3D.DriverType"/></strong> depending on which kind of device was created. On Windows?8, this type is always a value from <strong><see cref = "SharpDX.Direct3D.DriverType"/></strong>. Don't use <strong>IDXGIObject::SetPrivateData</strong> with <strong>GUID_DeviceType</strong> because the behavior when doing so is undefined.</p>
        /// </remarks>
        /// <doc-id>bb174543</doc-id>
        /// <unmanaged>HRESULT IDXGIObject::GetPrivateData([In] const GUID&amp; Name,[InOut] unsigned int* pDataSize,[Out, Buffer] void* pData)</unmanaged>
        /// <unmanaged-short>IDXGIObject::GetPrivateData</unmanaged-short>
        public unsafe SharpDX.Result GetPrivateData(System.Guid name, ref System.Int32 dataSizeRef, System.IntPtr dataRef)
        {
            SharpDX.Result __result__;
            fixed (void *dataSizeRef_ = &dataSizeRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &name, dataSizeRef_, (void *)dataRef, (*(void ***)this._nativePointer)[5]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the parent of the object.</p>
        /// </summary>
        /// <param name = "riid"><dd>  <p>The ID of the requested interface.</p> </dd></param>
        /// <param name = "parentOut"><dd>  <p>The address of a reference to the parent object.</p> </dd></param>
        /// <returns><p>Returns one of the DXGI_ERROR values.</p></returns>
        /// <doc-id>bb174542</doc-id>
        /// <unmanaged>HRESULT IDXGIObject::GetParent([In] const GUID&amp; riid,[Out] void** ppParent)</unmanaged>
        /// <unmanaged-short>IDXGIObject::GetParent</unmanaged-short>
        public unsafe void GetParent(System.Guid riid, out System.IntPtr parentOut)
        {
            SharpDX.Result __result__;
            fixed (void *parentOut_ = &parentOut)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &riid, parentOut_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("7b7166ec-21c7-44ae-b21a-c9ae321ae369")]
    public partial class Factory : SharpDX.DXGI.DXGIObject
    {
        public Factory(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Factory(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Factory(nativePtr);
        /// <summary>
        /// <p>Enumerates the adapters (video cards).</p>
        /// </summary>
        /// <param name = "adapter"><dd>  <p>The index of the adapter to enumerate.</p> </dd></param>
        /// <param name = "adapterOut"><dd>  <p>The address of a reference to an <strong><see cref = "SharpDX.DXGI.Adapter"/></strong> interface at the position specified by the <em>Adapter</em> parameter.  This parameter must not be <strong><c>null</c></strong>.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns <see cref = "NotFound"/> if the index is greater than or equal to the number of adapters in the local system, or <see cref = "InvalidCall"/> if <em>ppAdapter</em> parameter is <strong><c>null</c></strong>.</p></returns>
        /// <remarks>
        /// <p>When you create a factory, the factory enumerates the set of adapters that are available in the system. Therefore, if you change the adapters in a system, you must destroy  and recreate the <strong><see cref = "SharpDX.DXGI.Factory"/></strong> object. The number of adapters in a system changes when you add or remove a display card, or dock or undock a laptop. </p><p>When the <strong>EnumAdapters</strong> method succeeds and fills the <em>ppAdapter</em> parameter with the address of the reference to the adapter interface, <strong>EnumAdapters</strong> increments the adapter interface's reference count. When you finish using the  adapter interface, call the <strong>Release</strong> method to decrement the reference count before you destroy the reference.</p><p><strong>EnumAdapters</strong> first returns the adapter with the output on which the desktop primary is displayed. This adapter corresponds with an index of zero. <strong>EnumAdapters</strong> next returns other adapters with outputs. <strong>EnumAdapters</strong> finally returns adapters without outputs. </p>
        /// </remarks>
        /// <doc-id>bb174538</doc-id>
        /// <unmanaged>HRESULT IDXGIFactory::EnumAdapters([In] unsigned int Adapter,[Out] IDXGIAdapter** ppAdapter)</unmanaged>
        /// <unmanaged-short>IDXGIFactory::EnumAdapters</unmanaged-short>
        internal unsafe SharpDX.Result GetAdapter(System.Int32 adapter, out SharpDX.DXGI.Adapter adapterOut)
        {
            System.IntPtr adapterOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, adapter, &adapterOut_, (*(void ***)this._nativePointer)[7]);
            if (adapterOut_ != System.IntPtr.Zero)
                adapterOut = new SharpDX.DXGI.Adapter(adapterOut_);
            else
                adapterOut = null;
            return __result__;
        }

        /// <summary>
        /// <p>Allows DXGI to monitor an application's message queue for the alt-enter key sequence (which causes the application to switch from windowed to full screen or vice versa).</p>
        /// </summary>
        /// <param name = "windowHandle"><dd>  <p>The handle of the window that is to be monitored. This parameter can be <strong><c>null</c></strong>; but only if the flags are also 0. </p> </dd></param>
        /// <param name = "flags"><dd>  <p>One or more of the following values:</p> <ul> <li>DXGI_MWA_NO_WINDOW_CHANGES - Prevent DXGI from monitoring an applications message queue; this makes DXGI unable to respond to mode changes.</li> <li>DXGI_MWA_NO_ALT_ENTER - Prevent DXGI from responding to an alt-enter sequence.</li> <li>DXGI_MWA_NO_PRINT_SCREEN - Prevent DXGI from responding to a print-screen key.</li> </ul> </dd></param>
        /// <returns><p> <see cref = "InvalidCall"/> if <em>WindowHandle</em> is invalid, or E_OUTOFMEMORY.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??If you call this API in a Session 0 process, it returns <strong><see cref = "NotCurrentlyAvailable"/></strong>.?<p>The combination of <em>WindowHandle</em> and <em>Flags</em> informs DXGI to stop monitoring window messages for the previously-associated window.</p><p>If the application switches to full-screen mode, DXGI will choose a full-screen resolution to be the smallest supported resolution that is larger or the same size as the current back buffer size.</p><p>Applications can make some changes to make the transition from windowed to full screen more efficient. For example, on a WM_SIZE message, the application should release any outstanding swap-chain back buffers, call <strong>IDXGISwapChain::ResizeBuffers</strong>, then re-acquire the back buffers from the swap chain(s). This gives the swap chain(s) an opportunity to resize the back buffers, and/or recreate them to enable full-screen flipping operation. If the application does not perform this sequence, DXGI will still make the full-screen/windowed transition, but may be forced to use a stretch operation (since the back buffers may not be the correct size), which may be less efficient. Even if a stretch is not required, presentation may not be optimal because the back buffers might not be directly interchangeable with the front buffer. Thus, a call to <strong>ResizeBuffers</strong> on WM_SIZE is always recommended, since WM_SIZE is always sent during a fullscreen transition.</p><p>While windowed, the application can, if it chooses, restrict the size of its window's client area to sizes to which it is comfortable rendering. A fully flexible application would make no such restriction, but UI elements or other design considerations can, of course, make this flexibility untenable. If the application further chooses to restrict its window's client area to just those that match supported full-screen resolutions, the application can field WM_SIZING, then check against <strong>IDXGIOutput::FindClosestMatchingMode</strong>. If a matching mode is found, allow the resize. (The <see cref = "SharpDX.DXGI.Output"/> can be retrieved from <strong>IDXGISwapChain::GetContainingOutput</strong>. Absent subsequent changes to desktop topology, this will be the same output that will be chosen when alt-enter is fielded and fullscreen mode is begun for that swap chain.)</p><p>Applications that want to handle mode changes or Alt+Enter themselves should call <strong>MakeWindowAssociation</strong> with the DXGI_MWA_NO_WINDOW_CHANGES flag after swap chain creation. The <em>WindowHandle</em> argument, if non-<strong><c>null</c></strong>, specifies that the application message queues will not be handled by the DXGI runtime for all swap chains of a particular target <strong><see cref = "System.IntPtr"/></strong>.  Calling <strong>MakeWindowAssociation</strong> with the DXGI_MWA_NO_WINDOW_CHANGES flag after swapchain creation ensures that DXGI will not interfere with application's handling of window mode changes or Alt+Enter.</p>
        /// </remarks>
        /// <doc-id>bb174540</doc-id>
        /// <unmanaged>HRESULT IDXGIFactory::MakeWindowAssociation([In] HWND WindowHandle,[In] unsigned int Flags)</unmanaged>
        /// <unmanaged-short>IDXGIFactory::MakeWindowAssociation</unmanaged-short>
        public unsafe void MakeWindowAssociation(System.IntPtr windowHandle, SharpDX.DXGI.WindowAssociationFlags flags)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)windowHandle, unchecked ((System.Int32)flags), (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Get the window through which the user controls the transition to and from full screen.</p>
        /// </summary>
        /// <returns><dd>  <p>A reference to a window handle.</p> </dd></returns>
        /// <remarks>
        /// <strong>Note</strong>??If you call this API in a Session 0 process, it returns <strong><see cref = "NotCurrentlyAvailable"/></strong>.?
        /// </remarks>
        /// <doc-id>bb174539</doc-id>
        /// <unmanaged>HRESULT IDXGIFactory::GetWindowAssociation([Out] HWND* pWindowHandle)</unmanaged>
        /// <unmanaged-short>IDXGIFactory::GetWindowAssociation</unmanaged-short>
        public unsafe System.IntPtr GetWindowAssociation()
        {
            System.IntPtr windowHandleRef;
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &windowHandleRef, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
            return windowHandleRef;
        }

        /// <summary>
        /// <p>[Starting with Direct3D 11.1, we recommend not to use <strong>CreateSwapChain</strong> anymore to create a swap chain. Instead, use <strong>CreateSwapChainForHwnd</strong>, <strong>CreateSwapChainForCoreWindow</strong>, or <strong>CreateSwapChainForComposition</strong> depending on how you want to create the swap chain.]</p><p>Creates a swap chain.</p>
        /// </summary>
        /// <param name = "deviceRef">No documentation.</param>
        /// <param name = "descRef">No documentation.</param>
        /// <param name = "swapChainOut">No documentation.</param>
        /// <returns><p> <see cref = "InvalidCall"/> if <em>pDesc</em> or <em>ppSwapChain</em> is <strong><c>null</c></strong>, DXGI_STATUS_OCCLUDED if you request full-screen mode and it is unavailable, or E_OUTOFMEMORY. Other error codes defined by the type of device passed in may also be returned.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??If you call this API in a Session 0 process, it returns <strong><see cref = "NotCurrentlyAvailable"/></strong>.?<p>If you attempt to create a swap chain in full-screen mode, and full-screen mode is unavailable, the swap chain will be created in windowed mode and DXGI_STATUS_OCCLUDED will be returned.</p><p>If the buffer width or the buffer height is zero, the sizes will be inferred from the output window size in the swap-chain description.</p><p>Because the target output can't be chosen explicitly when the swap chain is created, we recommend not to create a full-screen swap chain. This can reduce presentation performance if the swap chain size and the output window size do not match. Here are two ways to ensure that the sizes match:</p><ul> <li>Create a windowed swap chain and then set it full-screen using <strong>IDXGISwapChain::SetFullscreenState</strong>.</li> <li>Save a reference to the swap chain immediately after creation, and use it to get the output window size during a WM_SIZE event. Then resize the swap chain buffers (with <strong>IDXGISwapChain::ResizeBuffers</strong>) during the transition from windowed to full-screen.</li> </ul><p>If the swap chain is in full-screen mode, before you release it you must use <strong>SetFullscreenState</strong> to switch it to windowed mode. For more information about releasing a swap chain, see the "Destroying a Swap Chain" section of DXGI Overview.</p><p>After the runtime renders the initial frame in full screen, the runtime might unexpectedly exit full screen during a call to <strong>IDXGISwapChain::Present</strong>. To work around this issue, we recommend that you execute the following code right after you call <strong>CreateSwapChain</strong> to create a full-screen swap chain (<strong>Windowed</strong> member of <strong><see cref = "SharpDX.DXGI.SwapChainDescription"/></strong> set to <strong><see cref = "SharpDX.Result.False"/></strong>).
        /// </p><pre> // Detect if newly created full-screen swap chain isn't actually full screen.
        /// <see cref = "SharpDX.DXGI.Output"/>* pTarget; <see cref = "SharpDX.Mathematics.Interop.RawBool"/> bFullscreen;
        /// if (SUCCEEDED(pSwapChain-&gt;GetFullscreenState(&amp;bFullscreen, &amp;pTarget)))
        /// { pTarget-&gt;Release();
        /// }
        /// else bFullscreen = <see cref = "SharpDX.Result.False"/>;
        /// // If not full screen, enable full screen again.
        /// if (!bFullscreen)
        /// { ShowWindow(hWnd, SW_MINIMIZE); ShowWindow(hWnd, SW_RESTORE); pSwapChain-&gt;SetFullscreenState(TRUE, <c>null</c>);
        /// }
        /// </pre><p>You can specify <strong><see cref = "SharpDX.DXGI.SwapEffect"/></strong> and <strong><see cref = "SharpDX.DXGI.SwapChainFlags"/></strong> values in the swap-chain description that <em>pDesc</em> points to. These values allow you to use features like flip-model presentation and content protection by using pre-Windows?8 APIs.</p><p>However, to use stereo presentation and to change resize behavior for the flip model, applications must use the <strong>IDXGIFactory2::CreateSwapChainForHwnd</strong> method. Otherwise, the back-buffer contents implicitly scale to fit the presentation target size; that is, you can't turn off scaling.</p>
        /// </remarks>
        /// <doc-id>bb174537</doc-id>
        /// <unmanaged>HRESULT IDXGIFactory::CreateSwapChain([In] IUnknown* pDevice,[In] DXGI_SWAP_CHAIN_DESC* pDesc,[Out, Fast] IDXGISwapChain** ppSwapChain)</unmanaged>
        /// <unmanaged-short>IDXGIFactory::CreateSwapChain</unmanaged-short>
        internal unsafe void CreateSwapChain(SharpDX.IUnknown deviceRef, ref SharpDX.DXGI.SwapChainDescription descRef, SharpDX.DXGI.SwapChain swapChainOut)
        {
            System.IntPtr deviceRef_ = System.IntPtr.Zero;
            System.IntPtr swapChainOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            deviceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(deviceRef);
            fixed (void *descRef_ = &descRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)deviceRef_, descRef_, &swapChainOut_, (*(void ***)this._nativePointer)[10]);
            (swapChainOut).NativePointer = swapChainOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Create an adapter interface that represents a software adapter.</p>
        /// </summary>
        /// <param name = "module"><dd>  <p>Handle to the software adapter's dll. HMODULE can be obtained with <strong>GetModuleHandle</strong> or <strong>LoadLibrary</strong>.</p> </dd></param>
        /// <returns><dd>  <p>Address of a reference to an adapter (see <strong><see cref = "SharpDX.DXGI.Adapter"/></strong>).</p> </dd></returns>
        /// <remarks>
        /// <p>A software adapter is a DLL that implements the entirety of a device driver interface, plus emulation, if necessary, of kernel-mode graphics components for Windows. Details on implementing a software adapter can be found in the Windows Vista Driver Development Kit. This is a very complex development task, and is not recommended for general readers.</p><p>Calling this method will increment the module's reference count by one. The reference count can be decremented by calling <strong>FreeLibrary</strong>.</p><p>The typical calling scenario is to call <strong>LoadLibrary</strong>, pass the handle to <strong>CreateSoftwareAdapter</strong>, then immediately call <strong>FreeLibrary</strong> on the DLL and forget the DLL's <strong>HMODULE</strong>. Since the software adapter calls <strong>FreeLibrary</strong> when it is destroyed, the lifetime of the DLL will now be owned by the adapter, and the application is free of any further consideration of its lifetime.</p>
        /// </remarks>
        /// <doc-id>bb174536</doc-id>
        /// <unmanaged>HRESULT IDXGIFactory::CreateSoftwareAdapter([In] HINSTANCE Module,[Out] IDXGIAdapter** ppAdapter)</unmanaged>
        /// <unmanaged-short>IDXGIFactory::CreateSoftwareAdapter</unmanaged-short>
        public unsafe SharpDX.DXGI.Adapter CreateSoftwareAdapter(System.IntPtr module)
        {
            SharpDX.DXGI.Adapter adapterOut;
            System.IntPtr adapterOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)module, &adapterOut_, (*(void ***)this._nativePointer)[11]);
            if (adapterOut_ != System.IntPtr.Zero)
                adapterOut = new SharpDX.DXGI.Adapter(adapterOut_);
            else
                adapterOut = null;
            __result__.CheckError();
            return adapterOut;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("770aae78-f26f-4dba-a829-253c83d1b387")]
    public partial class Factory1 : SharpDX.DXGI.Factory
    {
        public Factory1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Factory1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Factory1(nativePtr);
        /// <summary>
        /// <p>Informs an application of the possible need to re-enumerate adapters.</p>
        /// </summary>
        /// <remarks>
        /// <p>This method is not supported by DXGI 1.0, which shipped in Windows?Vista and Windows Server?2008. DXGI 1.1 support is required, which is available on  Windows?7, Windows Server?2008?R2, and as an update to Windows?Vista with Service Pack?2 (SP2) (KB 971644) and Windows Server?2008 (KB 971512).</p>
        /// </remarks>
        /// <doc-id>ff471337</doc-id>
        /// <unmanaged>IsCurrent</unmanaged>
        /// <unmanaged-short>IsCurrent</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsCurrent
        {
            get => IsCurrent_();
        }

        /// <summary>
        /// <p>Enumerates both adapters (video cards) with or without outputs.</p>
        /// </summary>
        /// <param name = "adapter"><dd>  <p>The index of the adapter to enumerate.</p> </dd></param>
        /// <param name = "adapterOut"><dd>  <p>The address of a reference to an <strong><see cref = "SharpDX.DXGI.Adapter1"/></strong> interface at the position specified by the <em>Adapter</em> parameter.   This parameter must not be <strong><c>null</c></strong>.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns <see cref = "NotFound"/> if the index is greater than or equal to the number of adapters in the local  system, or <see cref = "InvalidCall"/> if <em>ppAdapter</em> parameter is <strong><c>null</c></strong>.</p></returns>
        /// <remarks>
        /// <p>This method is not supported by DXGI 1.0, which shipped in Windows?Vista and Windows Server?2008. DXGI 1.1 support is required, which is available on  Windows?7, Windows Server?2008?R2, and as an update to Windows?Vista with Service Pack?2 (SP2) (KB 971644) and Windows Server?2008 (KB 971512).</p><p>When you create a factory, the factory enumerates the set of adapters that are available in the system. Therefore, if you change the adapters in a system, you must destroy  and recreate the <strong><see cref = "SharpDX.DXGI.Factory1"/></strong> object. The number of adapters in a system changes when you add or remove a display card, or dock or undock a laptop. </p><p>When the <strong>EnumAdapters1</strong> method succeeds and fills the <em>ppAdapter</em> parameter with the address of the reference to the adapter interface, <strong>EnumAdapters1</strong> increments the adapter interface's reference count. When you finish using the  adapter interface, call the <strong>Release</strong> method to decrement the reference count before you destroy the reference.</p><p><strong>EnumAdapters1</strong> first returns the adapter with the output on which the desktop primary is displayed. This adapter corresponds with an index of zero. <strong>EnumAdapters1</strong> next returns other adapters with outputs. <strong>EnumAdapters1</strong> finally returns adapters without outputs.</p>
        /// </remarks>
        /// <doc-id>ff471336</doc-id>
        /// <unmanaged>HRESULT IDXGIFactory1::EnumAdapters1([In] unsigned int Adapter,[Out] IDXGIAdapter1** ppAdapter)</unmanaged>
        /// <unmanaged-short>IDXGIFactory1::EnumAdapters1</unmanaged-short>
        internal unsafe SharpDX.Result GetAdapter1(System.Int32 adapter, out SharpDX.DXGI.Adapter1 adapterOut)
        {
            System.IntPtr adapterOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, adapter, &adapterOut_, (*(void ***)this._nativePointer)[12]);
            if (adapterOut_ != System.IntPtr.Zero)
                adapterOut = new SharpDX.DXGI.Adapter1(adapterOut_);
            else
                adapterOut = null;
            return __result__;
        }

        /// <summary>
        /// <p>Informs an application of the possible need to re-enumerate adapters.</p>
        /// </summary>
        /// <returns><p><strong><see cref = "SharpDX.Result.False"/></strong>, if a new adapter is becoming available or the current adapter is going away. <strong>TRUE</strong>, no adapter changes.</p><p><strong>IsCurrent</strong> returns <strong><see cref = "SharpDX.Result.False"/></strong> to inform the calling application to re-enumerate adapters.</p></returns>
        /// <remarks>
        /// <p>This method is not supported by DXGI 1.0, which shipped in Windows?Vista and Windows Server?2008. DXGI 1.1 support is required, which is available on  Windows?7, Windows Server?2008?R2, and as an update to Windows?Vista with Service Pack?2 (SP2) (KB 971644) and Windows Server?2008 (KB 971512).</p>
        /// </remarks>
        /// <doc-id>ff471337</doc-id>
        /// <unmanaged>BOOL IDXGIFactory1::IsCurrent()</unmanaged>
        /// <unmanaged-short>IDXGIFactory1::IsCurrent</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawBool IsCurrent_()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[13]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("50c83a1c-e072-4c48-87b0-3630fa36a6d0")]
    public partial class Factory2 : SharpDX.DXGI.Factory1
    {
        public Factory2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Factory2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Factory2(nativePtr);
        /// <summary>
        /// <p>Determines whether to use stereo mode.</p>
        /// </summary>
        /// <remarks>
        /// <p>We recommend that windowed applications call <strong>IsWindowedStereoEnabled</strong> before they attempt to use stereo.  <strong>IsWindowedStereoEnabled</strong> returns <strong>TRUE</strong> if both of the following items are true:</p><ul> <li>All adapters in the computer have drivers that are capable of stereo.  This only means that the driver is implemented to the Windows Display Driver Model (WDDM) for Windows?8 (WDDM 1.2).  However, the adapter does not necessarily have to be able to scan out stereo.</li> <li>The current desktop mode (desktop modes are mono) and system policy and hardware are configured so that the Desktop Window Manager (DWM) performs stereo composition on at least one adapter output.</li> </ul><p>The creation of a windowed stereo swap chain succeeds if the first requirement is met. However, if the adapter can't scan out stereo, the output on that adapter is reduced to mono.</p><p>The Direct3D 11.1 Simple Stereo 3D Sample shows how to add a stereoscopic 3D effect and how to respond to system stereo changes.</p>
        /// </remarks>
        /// <doc-id>hh404561</doc-id>
        /// <unmanaged>IsWindowedStereoEnabled</unmanaged>
        /// <unmanaged-short>IsWindowedStereoEnabled</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsWindowedStereoEnabled
        {
            get => IsWindowedStereoEnabled_();
        }

        /// <summary>
        /// <p>Determines whether to use stereo mode.</p>
        /// </summary>
        /// <returns><p>Indicates whether to use stereo mode. <strong>TRUE</strong> indicates that you can use stereo mode; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>.</p><p><strong>Platform Update for Windows?7:??</strong>On Windows?7 or Windows Server?2008?R2 with the Platform Update for Windows?7 installed, <strong>IsWindowedStereoEnabled</strong> always returns <see cref = "SharpDX.Result.False"/> because stereoscopic 3D display behavior isn?t available with the Platform Update for Windows?7. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p></returns>
        /// <remarks>
        /// <p>We recommend that windowed applications call <strong>IsWindowedStereoEnabled</strong> before they attempt to use stereo.  <strong>IsWindowedStereoEnabled</strong> returns <strong>TRUE</strong> if both of the following items are true:</p><ul> <li>All adapters in the computer have drivers that are capable of stereo.  This only means that the driver is implemented to the Windows Display Driver Model (WDDM) for Windows?8 (WDDM 1.2).  However, the adapter does not necessarily have to be able to scan out stereo.</li> <li>The current desktop mode (desktop modes are mono) and system policy and hardware are configured so that the Desktop Window Manager (DWM) performs stereo composition on at least one adapter output.</li> </ul><p>The creation of a windowed stereo swap chain succeeds if the first requirement is met. However, if the adapter can't scan out stereo, the output on that adapter is reduced to mono.</p><p>The Direct3D 11.1 Simple Stereo 3D Sample shows how to add a stereoscopic 3D effect and how to respond to system stereo changes.</p>
        /// </remarks>
        /// <doc-id>hh404561</doc-id>
        /// <unmanaged>BOOL IDXGIFactory2::IsWindowedStereoEnabled()</unmanaged>
        /// <unmanaged-short>IDXGIFactory2::IsWindowedStereoEnabled</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawBool IsWindowedStereoEnabled_()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[14]);
            return __result__;
        }

        /// <summary>
        /// <p>Creates a swap chain that is associated with an <strong><see cref = "System.IntPtr"/></strong> handle to the output window for the swap chain.</p>
        /// </summary>
        /// <param name = "deviceRef">No documentation.</param>
        /// <param name = "hWnd">No documentation.</param>
        /// <param name = "descRef">No documentation.</param>
        /// <param name = "fullscreenDescRef">No documentation.</param>
        /// <param name = "restrictToOutputRef">No documentation.</param>
        /// <param name = "swapChainOut">No documentation.</param>
        /// <returns><p><strong>CreateSwapChainForHwnd</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if it successfully created a swap chain.</li> <li>E_OUTOFMEMORY if memory is unavailable to complete the operation.</li> <li> <see cref = "InvalidCall"/> if the calling application provided invalid data, for example, if <em>pDesc</em> or <em>ppSwapChain</em> is <strong><c>null</c></strong>.</li> <li>Possibly other error codes that are described in the DXGI_ERROR topic that are defined by the type of device that you pass to <em>pDevice</em>.</li> </ul><p><strong>Platform Update for Windows?7:??</strong><strong>DXGI_SCALING_NONE</strong> is not supported on Windows?7 or Windows Server?2008?R2 with the Platform Update for Windows?7 installed and causes <strong>CreateSwapChainForHwnd</strong> to return <see cref = "InvalidCall"/> when called. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p></returns>
        /// <remarks>
        /// <strong>Note</strong>??Do not use this method in Windows Store apps. Instead, use <strong>IDXGIFactory2::CreateSwapChainForCoreWindow</strong>.?<p>If you specify the width, height, or both (<strong>Width</strong> and <strong>Height</strong> members of <strong><see cref = "SharpDX.DXGI.SwapChainDescription1"/></strong> that <em>pDesc</em> points to) of the swap chain as zero, the runtime obtains the size from the output window that the <em>hWnd</em> parameter specifies. You can subsequently call the <strong>IDXGISwapChain1::GetDesc1</strong> method to retrieve the assigned width or height value.</p><p>Because you can associate only one flip presentation model swap chain at a time with an <strong><see cref = "System.IntPtr"/></strong>, the Microsoft Direct3D?11 policy of deferring the destruction of objects can cause problems if you attempt to destroy a flip presentation model swap chain and replace it with another swap chain. For more info about this situation, see <strong>Deferred Destruction Issues with Flip Presentation Swap Chains</strong>.</p><p>For info about how to choose a format for the swap chain's back buffer, see Converting data for the color space.</p>
        /// </remarks>
        /// <doc-id>hh404557</doc-id>
        /// <unmanaged>HRESULT IDXGIFactory2::CreateSwapChainForHwnd([In] IUnknown* pDevice,[In] HWND hWnd,[In] const DXGI_SWAP_CHAIN_DESC1* pDesc,[In, Optional] const DXGI_SWAP_CHAIN_FULLSCREEN_DESC* pFullscreenDesc,[In, Optional] IDXGIOutput* pRestrictToOutput,[Out, Fast] IDXGISwapChain1** ppSwapChain)</unmanaged>
        /// <unmanaged-short>IDXGIFactory2::CreateSwapChainForHwnd</unmanaged-short>
        internal unsafe void CreateSwapChainForHwnd(SharpDX.IUnknown deviceRef, System.IntPtr hWnd, ref SharpDX.DXGI.SwapChainDescription1 descRef, SharpDX.DXGI.SwapChainFullScreenDescription? fullscreenDescRef, SharpDX.DXGI.Output restrictToOutputRef, SharpDX.DXGI.SwapChain1 swapChainOut)
        {
            System.IntPtr deviceRef_ = System.IntPtr.Zero;
            SharpDX.DXGI.SwapChainFullScreenDescription fullscreenDescRef_;
            System.IntPtr restrictToOutputRef_ = System.IntPtr.Zero;
            System.IntPtr swapChainOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            deviceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(deviceRef);
            if (fullscreenDescRef != null)
                fullscreenDescRef_ = fullscreenDescRef.Value;
            restrictToOutputRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Output>(restrictToOutputRef);
            fixed (void *descRef_ = &descRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)deviceRef_, (void *)hWnd, descRef_, fullscreenDescRef == null ? (void *)0 : &fullscreenDescRef_, (void *)restrictToOutputRef_, &swapChainOut_, (*(void ***)this._nativePointer)[15]);
            (swapChainOut).NativePointer = swapChainOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a swap chain that is associated with the <strong>CoreWindow</strong> object for the output window for the swap chain.</p>
        /// </summary>
        /// <param name = "deviceRef">No documentation.</param>
        /// <param name = "windowRef">No documentation.</param>
        /// <param name = "descRef">No documentation.</param>
        /// <param name = "restrictToOutputRef">No documentation.</param>
        /// <param name = "swapChainOut">No documentation.</param>
        /// <returns><p><strong>CreateSwapChainForCoreWindow</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if it successfully created a swap chain.</li> <li>E_OUTOFMEMORY if memory is unavailable to complete the operation.</li> <li> <see cref = "InvalidCall"/> if the calling application provided invalid data, for example, if <em>pDesc</em> or <em>ppSwapChain</em> is <strong><c>null</c></strong>.</li> <li>Possibly other error codes that are described in the DXGI_ERROR topic that are defined by the type of device that you pass to <em>pDevice</em>.</li> </ul><p><strong>Platform Update for Windows?7:??</strong>On Windows?7 or Windows Server?2008?R2 with the Platform Update for Windows?7 installed, <strong>CreateSwapChainForCoreWindow</strong> fails with E_NOTIMPL. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p></returns>
        /// <remarks>
        /// <strong>Note</strong>??Use this method in Windows Store apps rather than <strong>IDXGIFactory2::CreateSwapChainForHwnd</strong>.?<p>If you specify the width, height, or both (<strong>Width</strong> and <strong>Height</strong> members of <strong><see cref = "SharpDX.DXGI.SwapChainDescription1"/></strong> that <em>pDesc</em> points to) of the swap chain as zero, the runtime obtains the size from the output window that the <em>pWindow</em> parameter specifies. You can subsequently call the <strong>IDXGISwapChain1::GetDesc1</strong> method to retrieve the assigned width or height value.</p><p>Because you can associate only one flip presentation model swap chain (per layer) at a time with a <strong>CoreWindow</strong>, the Microsoft Direct3D?11 policy of deferring the destruction of objects can cause problems if you attempt to destroy a flip presentation model swap chain and replace it with another swap chain. For more info about this situation, see <strong>Deferred Destruction Issues with Flip Presentation Swap Chains</strong>.</p><p>For info about how to choose a format for the swap chain's back buffer, see Converting data for the color space.</p>
        /// </remarks>
        /// <doc-id>hh404559</doc-id>
        /// <unmanaged>HRESULT IDXGIFactory2::CreateSwapChainForCoreWindow([In] IUnknown* pDevice,[In] IUnknown* pWindow,[In] const DXGI_SWAP_CHAIN_DESC1* pDesc,[In, Optional] IDXGIOutput* pRestrictToOutput,[Out, Fast] IDXGISwapChain1** ppSwapChain)</unmanaged>
        /// <unmanaged-short>IDXGIFactory2::CreateSwapChainForCoreWindow</unmanaged-short>
        internal unsafe void CreateSwapChainForCoreWindow(SharpDX.IUnknown deviceRef, SharpDX.IUnknown windowRef, ref SharpDX.DXGI.SwapChainDescription1 descRef, SharpDX.DXGI.Output restrictToOutputRef, SharpDX.DXGI.SwapChain1 swapChainOut)
        {
            System.IntPtr deviceRef_ = System.IntPtr.Zero;
            System.IntPtr windowRef_ = System.IntPtr.Zero;
            System.IntPtr restrictToOutputRef_ = System.IntPtr.Zero;
            System.IntPtr swapChainOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            deviceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(deviceRef);
            windowRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(windowRef);
            restrictToOutputRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Output>(restrictToOutputRef);
            fixed (void *descRef_ = &descRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)deviceRef_, (void *)windowRef_, descRef_, (void *)restrictToOutputRef_, &swapChainOut_, (*(void ***)this._nativePointer)[16]);
            (swapChainOut).NativePointer = swapChainOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Identifies the adapter on which a shared resource object was created.</p>
        /// </summary>
        /// <param name = "hResource"><dd> <p>A handle to a shared resource object. The <strong>IDXGIResource1::CreateSharedHandle</strong> method returns this handle.</p> </dd></param>
        /// <param name = "luidRef"><dd> <p>A reference to a variable that receives a locally unique identifier (<strong><see cref = "System.Int64"/></strong>) value that identifies the adapter. <strong><see cref = "System.Int64"/></strong> is defined in Dxgi.h. An <strong><see cref = "System.Int64"/></strong> is a 64-bit value that is guaranteed to be unique only on the operating system on which it was generated. The uniqueness of an <strong><see cref = "System.Int64"/></strong> is guaranteed only until the operating system is restarted.</p> </dd></param>
        /// <returns><p><strong>GetSharedResourceAdapterLuid</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if it  identified the adapter.</li> <li><see cref = "InvalidCall"/> if <em>hResource</em> is invalid.</li> <li>Possibly other error codes that are described in the DXGI_ERROR topic.</li> </ul><p><strong>Platform Update for Windows?7:??</strong>On Windows?7 or Windows Server?2008?R2 with the Platform Update for Windows?7 installed, <strong>GetSharedResourceAdapterLuid</strong> fails with E_NOTIMPL. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p></returns>
        /// <remarks>
        /// <p>You cannot share resources across adapters. Therefore, you cannot open a shared resource on an adapter other than the adapter on which the resource was created.  Call <strong>GetSharedResourceAdapterLuid</strong> before you open a shared resource to ensure that the resource was created on the appropriate adapter. To open a shared resource, call the <strong>ID3D11Device1::OpenSharedResource1</strong> or <strong>ID3D11Device1::OpenSharedResourceByName</strong> method.</p>
        /// </remarks>
        /// <doc-id>hh404560</doc-id>
        /// <unmanaged>HRESULT IDXGIFactory2::GetSharedResourceAdapterLuid([In] void* hResource,[Out] LUID* pLuid)</unmanaged>
        /// <unmanaged-short>IDXGIFactory2::GetSharedResourceAdapterLuid</unmanaged-short>
        public unsafe void GetSharedResourceAdapterLuid(System.IntPtr hResource, out System.Int64 luidRef)
        {
            SharpDX.Result __result__;
            fixed (void *luidRef_ = &luidRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)hResource, luidRef_, (*(void ***)this._nativePointer)[17]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Registers an application window to receive notification messages of changes of stereo status.</p>
        /// </summary>
        /// <param name = "windowHandle"><dd> <p>The handle of the window to send a notification message to when stereo status change occurs.</p> </dd></param>
        /// <param name = "wMsg"><dd> <p>Identifies the notification message to send. </p> </dd></param>
        /// <param name = "dwCookieRef"><dd> <p>A reference to a key value that an application can pass to the <strong>IDXGIFactory2::UnregisterStereoStatus</strong> method  to unregister the notification message that <em>wMsg</em> specifies.</p> </dd></param>
        /// <returns><p><strong>RegisterStereoStatusWindow</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if it successfully registered the window.</li> <li>E_OUTOFMEMORY if memory is unavailable to complete the operation.</li> <li>Possibly other error codes that are described in the DXGI_ERROR topic.</li> </ul><p><strong>Platform Update for Windows?7:??</strong>On Windows?7 or Windows Server?2008?R2 with the Platform Update for Windows?7 installed, <strong>RegisterStereoStatusWindow</strong> fails with E_NOTIMPL. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p></returns>
        /// <doc-id>hh404587</doc-id>
        /// <unmanaged>HRESULT IDXGIFactory2::RegisterStereoStatusWindow([In] HWND WindowHandle,[In] unsigned int wMsg,[Out] DWORD* pdwCookie)</unmanaged>
        /// <unmanaged-short>IDXGIFactory2::RegisterStereoStatusWindow</unmanaged-short>
        public unsafe void RegisterStereoStatusWindow(System.IntPtr windowHandle, System.Int32 wMsg, out System.Int32 dwCookieRef)
        {
            SharpDX.Result __result__;
            fixed (void *dwCookieRef_ = &dwCookieRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)windowHandle, wMsg, dwCookieRef_, (*(void ***)this._nativePointer)[18]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Registers to receive notification of changes in stereo status by using event signaling.</p>
        /// </summary>
        /// <param name = "hEvent"><dd> <p>A handle to the event object that the operating system sets when notification of stereo status change occurs. The <strong>CreateEvent</strong> or <strong>OpenEvent</strong> function returns this handle. </p> </dd></param>
        /// <param name = "dwCookieRef"><dd> <p>A reference to a key value that an application can pass to the <strong>IDXGIFactory2::UnregisterStereoStatus</strong> method  to unregister the notification event that <em>hEvent</em> specifies.</p> </dd></param>
        /// <returns><p><strong>RegisterStereoStatusEvent</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if it successfully registered the event.</li> <li>E_OUTOFMEMORY if memory is unavailable to complete the operation.</li> <li>Possibly other error codes that are described in the DXGI_ERROR topic.</li> </ul><p><strong>Platform Update for Windows?7:??</strong>On Windows?7 or Windows Server?2008?R2 with the Platform Update for Windows?7 installed, <strong>RegisterStereoStatusEvent</strong> fails with E_NOTIMPL. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p></returns>
        /// <doc-id>hh404584</doc-id>
        /// <unmanaged>HRESULT IDXGIFactory2::RegisterStereoStatusEvent([In] void* hEvent,[Out] DWORD* pdwCookie)</unmanaged>
        /// <unmanaged-short>IDXGIFactory2::RegisterStereoStatusEvent</unmanaged-short>
        public unsafe void RegisterStereoStatusEvent(System.IntPtr hEvent, out System.Int32 dwCookieRef)
        {
            SharpDX.Result __result__;
            fixed (void *dwCookieRef_ = &dwCookieRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)hEvent, dwCookieRef_, (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Unregisters a window or an event to stop it from receiving notification when stereo status changes.</p>
        /// </summary>
        /// <param name = "dwCookie"><dd> <p>A key value for the window or event to unregister. The  <strong>IDXGIFactory2::RegisterStereoStatusWindow</strong> or  <strong>IDXGIFactory2::RegisterStereoStatusEvent</strong> method returns this value. </p> </dd></param>
        /// <remarks>
        /// <p><strong>Platform Update for Windows?7:??</strong>On Windows?7 or Windows Server?2008?R2 with the Platform Update for Windows?7 installed, <strong>UnregisterStereoStatus</strong> has no effect. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p>
        /// </remarks>
        /// <doc-id>hh404593</doc-id>
        /// <unmanaged>void IDXGIFactory2::UnregisterStereoStatus([In] DWORD dwCookie)</unmanaged>
        /// <unmanaged-short>IDXGIFactory2::UnregisterStereoStatus</unmanaged-short>
        public unsafe void UnregisterStereoStatus(System.Int32 dwCookie)
        {
            SharpDX.DXGI.LocalInterop.CalliStdCallvoid(this._nativePointer, dwCookie, (*(void ***)this._nativePointer)[20]);
        }

        /// <summary>
        /// <p>Registers an application window to receive notification messages of changes of occlusion status.</p>
        /// </summary>
        /// <param name = "windowHandle"><dd> <p>The handle of the window to send a notification message to when occlusion status change occurs.</p> </dd></param>
        /// <param name = "wMsg"><dd> <p>Identifies the notification message to send. </p> </dd></param>
        /// <param name = "dwCookieRef"><dd> <p>A reference to a key value that an application can pass to the <strong>IDXGIFactory2::UnregisterOcclusionStatus</strong> method  to unregister the notification message that <em>wMsg</em> specifies.</p> </dd></param>
        /// <returns><p><strong>RegisterOcclusionStatusWindow</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if it successfully registered the window.</li> <li>E_OUTOFMEMORY if memory is unavailable to complete the operation.</li> <li> <see cref = "InvalidCall"/> if <em>WindowHandle</em> is not a valid window handle or not the window handle that the current process owns.</li> <li>Possibly other error codes that are described in the DXGI_ERROR topic.</li> </ul><p><strong>Platform Update for Windows?7:??</strong>On Windows?7 or Windows Server?2008?R2 with the Platform Update for Windows?7 installed, <strong>RegisterOcclusionStatusWindow</strong> fails with E_NOTIMPL. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p></returns>
        /// <remarks>
        /// <p>Apps choose the Windows message that Windows sends when occlusion status changes.</p>
        /// </remarks>
        /// <doc-id>hh404581</doc-id>
        /// <unmanaged>HRESULT IDXGIFactory2::RegisterOcclusionStatusWindow([In] HWND WindowHandle,[In] unsigned int wMsg,[Out] DWORD* pdwCookie)</unmanaged>
        /// <unmanaged-short>IDXGIFactory2::RegisterOcclusionStatusWindow</unmanaged-short>
        public unsafe void RegisterOcclusionStatusWindow(System.IntPtr windowHandle, System.Int32 wMsg, out System.Int32 dwCookieRef)
        {
            SharpDX.Result __result__;
            fixed (void *dwCookieRef_ = &dwCookieRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)windowHandle, wMsg, dwCookieRef_, (*(void ***)this._nativePointer)[21]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Registers to receive notification of  changes in occlusion status by using event signaling.</p>
        /// </summary>
        /// <param name = "hEvent"><dd> <p>A handle to the event object that the operating system sets when notification of occlusion status change occurs. The <strong>CreateEvent</strong> or <strong>OpenEvent</strong> function returns this handle.</p> </dd></param>
        /// <param name = "dwCookieRef"><dd> <p>A reference to a key value that an application can pass to the <strong>IDXGIFactory2::UnregisterOcclusionStatus</strong> method  to unregister the notification event that <em>hEvent</em> specifies.</p> </dd></param>
        /// <returns><p><strong>RegisterOcclusionStatusEvent</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if the method successfully registered the event.</li> <li>E_OUTOFMEMORY if memory is unavailable to complete the operation.</li> <li> <see cref = "InvalidCall"/> if <em>hEvent</em> is not a valid handle or not an event handle. </li> <li>Possibly other error codes that are described in the DXGI_ERROR topic.</li> </ul><p><strong>Platform Update for Windows?7:??</strong>On Windows?7 or Windows Server?2008?R2 with the Platform Update for Windows?7 installed, <strong>RegisterOcclusionStatusEvent</strong> fails with E_NOTIMPL. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p></returns>
        /// <remarks>
        /// <p>If you call <strong>RegisterOcclusionStatusEvent</strong> multiple times with the same event handle, <strong>RegisterOcclusionStatusEvent</strong> fails with <see cref = "InvalidCall"/>.</p><p>If you call <strong>RegisterOcclusionStatusEvent</strong> multiple times with the different event handles, <strong>RegisterOcclusionStatusEvent</strong> properly registers the events.</p>
        /// </remarks>
        /// <doc-id>hh404578</doc-id>
        /// <unmanaged>HRESULT IDXGIFactory2::RegisterOcclusionStatusEvent([In] void* hEvent,[Out] DWORD* pdwCookie)</unmanaged>
        /// <unmanaged-short>IDXGIFactory2::RegisterOcclusionStatusEvent</unmanaged-short>
        public unsafe void RegisterOcclusionStatusEvent(System.IntPtr hEvent, out System.Int32 dwCookieRef)
        {
            SharpDX.Result __result__;
            fixed (void *dwCookieRef_ = &dwCookieRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)hEvent, dwCookieRef_, (*(void ***)this._nativePointer)[22]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Unregisters a window or an event to stop it from receiving notification when occlusion status changes.</p>
        /// </summary>
        /// <param name = "dwCookie"><dd> <p>A key value for the window or event to unregister. The  <strong>IDXGIFactory2::RegisterOcclusionStatusWindow</strong> or  <strong>IDXGIFactory2::RegisterOcclusionStatusEvent</strong> method returns this value. </p> </dd></param>
        /// <remarks>
        /// <p><strong>Platform Update for Windows?7:??</strong>On Windows?7 or Windows Server?2008?R2 with the Platform Update for Windows?7 installed, <strong>UnregisterOcclusionStatus</strong> has no effect. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p>
        /// </remarks>
        /// <doc-id>hh404590</doc-id>
        /// <unmanaged>void IDXGIFactory2::UnregisterOcclusionStatus([In] DWORD dwCookie)</unmanaged>
        /// <unmanaged-short>IDXGIFactory2::UnregisterOcclusionStatus</unmanaged-short>
        public unsafe void UnregisterOcclusionStatus(System.Int32 dwCookie)
        {
            SharpDX.DXGI.LocalInterop.CalliStdCallvoid(this._nativePointer, dwCookie, (*(void ***)this._nativePointer)[23]);
        }

        /// <summary>
        /// <p>Creates a swap chain that you can use to send Direct3D content into the DirectComposition API or the <strong>Windows.UI.Xaml</strong> framework to compose in a window.</p>
        /// </summary>
        /// <param name = "deviceRef">No documentation.</param>
        /// <param name = "descRef">No documentation.</param>
        /// <param name = "restrictToOutputRef">No documentation.</param>
        /// <param name = "swapChainOut">No documentation.</param>
        /// <returns><p><strong>CreateSwapChainForComposition</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if it successfully created a swap chain.</li> <li>E_OUTOFMEMORY if memory is unavailable to complete the operation.</li> <li> <see cref = "InvalidCall"/> if the calling application provided invalid data, for example, if <em>pDesc</em> or <em>ppSwapChain</em> is <strong><c>null</c></strong>.</li> <li>Possibly other error codes that are described in the DXGI_ERROR topic that are defined by the type of device that you pass to <em>pDevice</em>.</li> </ul><p><strong>Platform Update for Windows?7:??</strong>On Windows?7 or Windows Server?2008?R2 with the Platform Update for Windows?7 installed, <strong>CreateSwapChainForComposition</strong> fails with E_NOTIMPL. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p></returns>
        /// <remarks>
        /// <p>You can use composition swap chains with either DirectComposition?s <strong><see cref = "SharpDX.DirectComposition.Visual"/></strong> interface or XAML?s <strong>SwapChainBackgroundPanel</strong> class. For DirectComposition, you can call the <strong>IDCompositionVisual::SetContent</strong> method to set the swap chain as the content of a visual object, which then allows you to bind the swap chain to the visual tree. For XAML, the <strong>SwapChainBackgroundPanel</strong> class exposes a classic COM interface <strong><see cref = "SharpDX.DXGI.ISwapChainBackgroundPanelNative"/></strong>. You can use the <strong>ISwapChainBackgroundPanelNative::SetSwapChain</strong> method to bind to the XAML UI graph. For info about how to use composition swap chains with XAML?s <strong>SwapChainBackgroundPanel</strong> class, see DirectX and XAML interop.</p><p>The <strong>IDXGISwapChain::SetFullscreenState</strong>, <strong>IDXGISwapChain::ResizeTarget</strong>, <strong>IDXGISwapChain::GetContainingOutput</strong>, <strong>IDXGISwapChain1::GetHwnd</strong>, and <strong>IDXGISwapChain::GetCoreWindow</strong> methods aren't valid on this type of swap chain. If you call any of these methods on this type of swap chain, they fail.</p><p>For info about how to choose a format for the swap chain's back buffer, see Converting data for the color space.</p>
        /// </remarks>
        /// <doc-id>hh404558</doc-id>
        /// <unmanaged>HRESULT IDXGIFactory2::CreateSwapChainForComposition([In] IUnknown* pDevice,[In] const DXGI_SWAP_CHAIN_DESC1* pDesc,[In, Optional] IDXGIOutput* pRestrictToOutput,[Out, Fast] IDXGISwapChain1** ppSwapChain)</unmanaged>
        /// <unmanaged-short>IDXGIFactory2::CreateSwapChainForComposition</unmanaged-short>
        internal unsafe void CreateSwapChainForComposition(SharpDX.IUnknown deviceRef, ref SharpDX.DXGI.SwapChainDescription1 descRef, SharpDX.DXGI.Output restrictToOutputRef, SharpDX.DXGI.SwapChain1 swapChainOut)
        {
            System.IntPtr deviceRef_ = System.IntPtr.Zero;
            System.IntPtr restrictToOutputRef_ = System.IntPtr.Zero;
            System.IntPtr swapChainOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            deviceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(deviceRef);
            restrictToOutputRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Output>(restrictToOutputRef);
            fixed (void *descRef_ = &descRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)deviceRef_, descRef_, (void *)restrictToOutputRef_, &swapChainOut_, (*(void ***)this._nativePointer)[24]);
            (swapChainOut).NativePointer = swapChainOut_;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("25483823-cd46-4c7d-86ca-47aa95b837bd")]
    public partial class Factory3 : SharpDX.DXGI.Factory2
    {
        public Factory3(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Factory3(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Factory3(nativePtr);
        /// <summary>
        /// <p>Gets the flags that were used when a Microsoft DirectX Graphics Infrastructure (DXGI) object was created.</p>
        /// </summary>
        /// <remarks>
        /// <p>The <strong>GetCreationFlags</strong> method returns flags that were passed to the  <strong>CreateDXGIFactory2</strong> function, or were implicitly constructed by <strong>CreateDXGIFactory</strong>, <strong>CreateDXGIFactory1</strong>,  <strong>D3D11CreateDevice</strong>, or <strong>D3D11CreateDeviceAndSwapChain</strong>.</p>
        /// </remarks>
        /// <doc-id>dn457943</doc-id>
        /// <unmanaged>GetCreationFlags</unmanaged>
        /// <unmanaged-short>GetCreationFlags</unmanaged-short>
        public System.Int32 CreationFlags
        {
            get => GetCreationFlags();
        }

        /// <summary>
        /// <p>Gets the flags that were used when a Microsoft DirectX Graphics Infrastructure (DXGI) object was created.</p>
        /// </summary>
        /// <returns><p>The creation flags.</p></returns>
        /// <remarks>
        /// <p>The <strong>GetCreationFlags</strong> method returns flags that were passed to the  <strong>CreateDXGIFactory2</strong> function, or were implicitly constructed by <strong>CreateDXGIFactory</strong>, <strong>CreateDXGIFactory1</strong>,  <strong>D3D11CreateDevice</strong>, or <strong>D3D11CreateDeviceAndSwapChain</strong>.</p>
        /// </remarks>
        /// <doc-id>dn457943</doc-id>
        /// <unmanaged>unsigned int IDXGIFactory3::GetCreationFlags()</unmanaged>
        /// <unmanaged-short>IDXGIFactory3::GetCreationFlags</unmanaged-short>
        internal unsafe System.Int32 GetCreationFlags()
        {
            System.Int32 __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[25]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("1bc6ea02-ef36-464f-bf0c-21ca39e5168a")]
    public partial class Factory4 : SharpDX.DXGI.Factory3
    {
        public Factory4(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Factory4(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Factory4(nativePtr);
        /// <summary>
        /// <p> Outputs the <strong><see cref = "SharpDX.DXGI.Adapter"/></strong> for the specified <see cref = "System.Int64"/>. </p>
        /// </summary>
        /// <param name = "adapterLuid">No documentation.</param>
        /// <param name = "riid">No documentation.</param>
        /// <param name = "vAdapterOut">No documentation.</param>
        /// <returns><p> Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR. See also Direct3D 12 Return Codes. </p></returns>
        /// <remarks>
        /// <p> For Direct3D 12, it's no longer possible to backtrack from a device to the <strong><see cref = "SharpDX.DXGI.Adapter"/></strong> that was used to create it. <strong>IDXGIFactory4::EnumAdapterByLuid</strong> enables an app to retrieve information about the adapter where a D3D12 device was created. <strong>IDXGIFactory4::EnumAdapterByLuid</strong> is designed to be paired with <strong>ID3D12Device::GetAdapterLuid</strong>. For more information, see DXGI 1.4 Improvements. </p>
        /// </remarks>
        /// <doc-id>mt427786</doc-id>
        /// <unmanaged>HRESULT IDXGIFactory4::EnumAdapterByLuid([In] LUID AdapterLuid,[In] const GUID&amp; riid,[Out] void** ppvAdapter)</unmanaged>
        /// <unmanaged-short>IDXGIFactory4::EnumAdapterByLuid</unmanaged-short>
        private unsafe void EnumAdapterByLuid(System.Int64 adapterLuid, System.Guid riid, out System.IntPtr vAdapterOut)
        {
            SharpDX.Result __result__;
            fixed (void *vAdapterOut_ = &vAdapterOut)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, adapterLuid, &riid, vAdapterOut_, (*(void ***)this._nativePointer)[26]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Provides an adapter which can be provided to D3D12CreateDevice to use the WARP renderer. </p>
        /// </summary>
        /// <param name = "riid"><dd>  <p> The globally unique identifier (<see cref = "System.Guid"/>) of the <strong><see cref = "SharpDX.DXGI.Factory4"/></strong> object referenced by the <em>ppvAdapter</em> parameter. </p> </dd></param>
        /// <param name = "vAdapterOut"><dd>  <p> The address of an <strong><see cref = "SharpDX.DXGI.Adapter"/></strong> interface reference to the adapter. This parameter must not be <c>null</c>. </p> </dd></param>
        /// <returns><p> Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR. See also Direct3D 12 Return Codes. </p></returns>
        /// <remarks>
        /// <p> For more information, see DXGI 1.4 Improvements. </p>
        /// </remarks>
        /// <doc-id>mt427787</doc-id>
        /// <unmanaged>HRESULT IDXGIFactory4::EnumWarpAdapter([In] const GUID&amp; riid,[Out] void** ppvAdapter)</unmanaged>
        /// <unmanaged-short>IDXGIFactory4::EnumWarpAdapter</unmanaged-short>
        private unsafe void EnumWarpAdapter(System.Guid riid, out System.IntPtr vAdapterOut)
        {
            SharpDX.Result __result__;
            fixed (void *vAdapterOut_ = &vAdapterOut)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &riid, vAdapterOut_, (*(void ***)this._nativePointer)[27]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("7632e1f5-ee65-4dca-87fd-84cd75f8838d")]
    public partial class Factory5 : SharpDX.DXGI.Factory4
    {
        public Factory5(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Factory5(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Factory5(nativePtr);
        /// <summary>
        /// <p>Used to check for hardware feature support.</p>
        /// </summary>
        /// <param name = "feature"><dd>  <p>Specifies one member of  <strong><see cref = "SharpDX.DXGI.Feature"/></strong> to query support for.</p> </dd></param>
        /// <param name = "featureSupportDataRef"><dd>  <p>Specifies a reference to a buffer that will be filled with data that describes the feature support.</p> </dd></param>
        /// <param name = "featureSupportDataSize"><dd>  <p>The size, in bytes, of <em>pFeatureSupportData</em>.</p> </dd></param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code.</p></returns>
        /// <remarks>
        /// <p>Refer to the description of <strong>DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING</strong>.</p>
        /// </remarks>
        /// <doc-id>mt722567</doc-id>
        /// <unmanaged>HRESULT IDXGIFactory5::CheckFeatureSupport([In] DXGI_FEATURE Feature,[Out, Buffer] void* pFeatureSupportData,[In] unsigned int FeatureSupportDataSize)</unmanaged>
        /// <unmanaged-short>IDXGIFactory5::CheckFeatureSupport</unmanaged-short>
        public unsafe void CheckFeatureSupport(SharpDX.DXGI.Feature feature, System.IntPtr featureSupportDataRef, System.Int32 featureSupportDataSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)feature), (void *)featureSupportDataRef, featureSupportDataSize, (*(void ***)this._nativePointer)[28]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("c1b6694f-ff09-44a9-b03c-77900a0a1d17")]
    public partial class Factory6 : SharpDX.DXGI.Factory5
    {
        public Factory6(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Factory6(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Factory6(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "adapter">No documentation.</param>
        /// <param name = "gpuPreference">No documentation.</param>
        /// <param name = "riid">No documentation.</param>
        /// <param name = "vAdapterOut">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT IDXGIFactory6::EnumAdapterByGpuPreference([In] unsigned int Adapter,[In] DXGI_GPU_PREFERENCE GpuPreference,[In] const GUID&amp; riid,[Out] void** ppvAdapter)</unmanaged>
        /// <unmanaged-short>IDXGIFactory6::EnumAdapterByGpuPreference</unmanaged-short>
        public unsafe void EnumAdapterByGpuPreference(System.Int32 adapter, SharpDX.DXGI.GpuPreferEnce gpuPreference, System.Guid riid, out System.IntPtr vAdapterOut)
        {
            SharpDX.Result __result__;
            fixed (void *vAdapterOut_ = &vAdapterOut)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, adapter, unchecked ((System.Int32)gpuPreference), &riid, vAdapterOut_, (*(void ***)this._nativePointer)[29]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("a4966eed-76db-44da-84c1-ee9a7afb20a8")]
    public partial class Factory7 : SharpDX.DXGI.Factory6
    {
        public Factory7(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Factory7(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Factory7(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "hEvent">No documentation.</param>
        /// <param name = "dwCookieRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT IDXGIFactory7::RegisterAdaptersChangedEvent([In] void* hEvent,[Out] DWORD* pdwCookie)</unmanaged>
        /// <unmanaged-short>IDXGIFactory7::RegisterAdaptersChangedEvent</unmanaged-short>
        public unsafe void RegisterAdaptersChangedEvent(System.IntPtr hEvent, out System.Int32 dwCookieRef)
        {
            SharpDX.Result __result__;
            fixed (void *dwCookieRef_ = &dwCookieRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)hEvent, dwCookieRef_, (*(void ***)this._nativePointer)[30]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "dwCookie">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT IDXGIFactory7::UnregisterAdaptersChangedEvent([In] DWORD dwCookie)</unmanaged>
        /// <unmanaged-short>IDXGIFactory7::UnregisterAdaptersChangedEvent</unmanaged-short>
        public unsafe void UnregisterAdaptersChangedEvent(System.Int32 dwCookie)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, dwCookie, (*(void ***)this._nativePointer)[31]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("41e7d1f2-a591-4f7b-a2e5-fa9c843e1c12")]
    public partial class FactoryMedia : SharpDX.ComObject
    {
        public FactoryMedia(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator FactoryMedia(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new FactoryMedia(nativePtr);
        /// <summary>
        /// <p>Creates a YUV swap chain for an existing DirectComposition surface handle.</p>
        /// </summary>
        /// <param name = "deviceRef">No documentation.</param>
        /// <param name = "hSurface">No documentation.</param>
        /// <param name = "descRef">No documentation.</param>
        /// <param name = "restrictToOutputRef">No documentation.</param>
        /// <param name = "swapChainOut">No documentation.</param>
        /// <returns><p><strong>CreateSwapChainForCompositionSurfaceHandle</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if it successfully created a swap chain.</li> <li>E_OUTOFMEMORY if memory is unavailable to complete the operation.</li> <li> <see cref = "InvalidCall"/> if the calling application provided invalid data, for example, if <em>pDesc</em>, <em>pYuvDecodeBuffers</em>, or <em>ppSwapChain</em> is <strong><c>null</c></strong>.</li> <li>Possibly other error codes that are described in the DXGI_ERROR topic that are defined by the type of device that you pass to <em>pDevice</em>.</li> </ul></returns>
        /// <doc-id>dn384130</doc-id>
        /// <unmanaged>HRESULT IDXGIFactoryMedia::CreateSwapChainForCompositionSurfaceHandle([In] IUnknown* pDevice,[In, Optional] void* hSurface,[In] const DXGI_SWAP_CHAIN_DESC1* pDesc,[In, Optional] IDXGIOutput* pRestrictToOutput,[Out] IDXGISwapChain1** ppSwapChain)</unmanaged>
        /// <unmanaged-short>IDXGIFactoryMedia::CreateSwapChainForCompositionSurfaceHandle</unmanaged-short>
        public unsafe void CreateSwapChainForCompositionSurfaceHandle(SharpDX.IUnknown deviceRef, System.IntPtr hSurface, ref SharpDX.DXGI.SwapChainDescription1 descRef, SharpDX.DXGI.Output restrictToOutputRef, out SharpDX.DXGI.SwapChain1 swapChainOut)
        {
            System.IntPtr deviceRef_ = System.IntPtr.Zero;
            System.IntPtr restrictToOutputRef_ = System.IntPtr.Zero;
            System.IntPtr swapChainOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            deviceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(deviceRef);
            restrictToOutputRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Output>(restrictToOutputRef);
            fixed (void *descRef_ = &descRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)deviceRef_, (void *)hSurface, descRef_, (void *)restrictToOutputRef_, &swapChainOut_, (*(void ***)this._nativePointer)[3]);
            if (swapChainOut_ != System.IntPtr.Zero)
                swapChainOut = new SharpDX.DXGI.SwapChain1(swapChainOut_);
            else
                swapChainOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a YUV swap chain for an existing DirectComposition surface handle. The swap chain is created with pre-existing buffers and very few descriptive elements are required. Instead, this method requires  a DirectComposition surface handle and an <strong><see cref = "SharpDX.DXGI.Resource"/></strong> buffer to hold decoded frame data. The swap chain format is determined by the format of the subresources of the <strong><see cref = "SharpDX.DXGI.Resource"/></strong>. </p>
        /// </summary>
        /// <param name = "deviceRef">No documentation.</param>
        /// <param name = "hSurface">No documentation.</param>
        /// <param name = "descRef">No documentation.</param>
        /// <param name = "yuvDecodeBuffersRef">No documentation.</param>
        /// <param name = "restrictToOutputRef">No documentation.</param>
        /// <param name = "swapChainOut">No documentation.</param>
        /// <returns><p><strong>CreateDecodeSwapChainForCompositionSurfaceHandle</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if it successfully created a swap chain.</li> <li>E_OUTOFMEMORY if memory is unavailable to complete the operation.</li> <li> <see cref = "InvalidCall"/> if the calling application provided invalid data, for example,  if <em>pDesc</em>, <em>pYuvDecodeBuffers</em>, or <em>ppSwapChain</em> is <strong><c>null</c></strong>. </li> <li> Possibly other error codes that are described in the DXGI_ERROR topic that are defined by the type of device that you pass to <em>pDevice</em>. </li> </ul></returns>
        /// <remarks>
        /// <p>The <strong><see cref = "SharpDX.DXGI.Resource"/></strong> provided via the <em>pYuvDecodeBuffers</em> parameter must point to at least one subresource, and all subresources must be created with the <strong>D3D11_BIND_DECODER</strong> flag.</p>
        /// </remarks>
        /// <doc-id>dn384129</doc-id>
        /// <unmanaged>HRESULT IDXGIFactoryMedia::CreateDecodeSwapChainForCompositionSurfaceHandle([In] IUnknown* pDevice,[In, Optional] void* hSurface,[In] DXGI_DECODE_SWAP_CHAIN_DESC* pDesc,[In] IDXGIResource* pYuvDecodeBuffers,[In, Optional] IDXGIOutput* pRestrictToOutput,[Out] IDXGIDecodeSwapChain** ppSwapChain)</unmanaged>
        /// <unmanaged-short>IDXGIFactoryMedia::CreateDecodeSwapChainForCompositionSurfaceHandle</unmanaged-short>
        public unsafe void CreateDecodeSwapChainForCompositionSurfaceHandle(SharpDX.IUnknown deviceRef, System.IntPtr hSurface, SharpDX.DXGI.DecodeSwapChainDescription descRef, SharpDX.DXGI.Resource yuvDecodeBuffersRef, SharpDX.DXGI.Output restrictToOutputRef, out SharpDX.DXGI.DecodeSwapChain swapChainOut)
        {
            System.IntPtr deviceRef_ = System.IntPtr.Zero;
            System.IntPtr yuvDecodeBuffersRef_ = System.IntPtr.Zero;
            System.IntPtr restrictToOutputRef_ = System.IntPtr.Zero;
            System.IntPtr swapChainOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            deviceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(deviceRef);
            yuvDecodeBuffersRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Resource>(yuvDecodeBuffersRef);
            restrictToOutputRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Output>(restrictToOutputRef);
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)deviceRef_, (void *)hSurface, &descRef, (void *)yuvDecodeBuffersRef_, (void *)restrictToOutputRef_, &swapChainOut_, (*(void ***)this._nativePointer)[4]);
            if (swapChainOut_ != System.IntPtr.Zero)
                swapChainOut = new SharpDX.DXGI.DecodeSwapChain(swapChainOut_);
            else
                swapChainOut = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("D67441C7-672A-476f-9E82-CD55B44949CE")]
    public partial class InfoQueue : SharpDX.ComObject
    {
        public InfoQueue(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator InfoQueue(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new InfoQueue(nativePtr);
        /// <summary>
        /// <p>Sets the maximum number of messages that can be added to the message queue.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that sets the limit on the number of messages.</p> </dd></param>
        /// <param name = "messageCountLimit"><dd> <p>The maximum number of messages that can be added to the queue. ?1 means no limit.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780391</doc-id>
        /// <unmanaged>HRESULT IDXGIInfoQueue::SetMessageCountLimit([In] GUID Producer,[In] unsigned longlong MessageCountLimit)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::SetMessageCountLimit</unmanaged-short>
        public unsafe void SetMessageCountLimit(System.Guid producer, System.Int64 messageCountLimit)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, producer, messageCountLimit, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Clears all messages from the message queue.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that clears the messages.</p> </dd></param>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780362</doc-id>
        /// <unmanaged>void IDXGIInfoQueue::ClearStoredMessages([In] GUID Producer)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::ClearStoredMessages</unmanaged-short>
        public unsafe void ClearStoredMessages(System.Guid producer)
        {
            SharpDX.DXGI.LocalInterop.CalliStdCallvoid(this._nativePointer, producer, (*(void ***)this._nativePointer)[4]);
        }

        /// <summary>
        /// <p>Gets a message from the message queue.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that gets the message.</p> </dd></param>
        /// <param name = "messageIndex"><dd> <p>An index into the message queue after an optional retrieval filter has been applied. This can be between 0 and the number of messages in the message queue that pass through the retrieval filter. Call <strong>IDXGIInfoQueue::GetNumStoredMessagesAllowedByRetrievalFilters</strong> to obtain this number. 0 is the message at the beginning of the message queue.</p> </dd></param>
        /// <param name = "messageRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.DXGI.InformationQueueMessage"/></strong> structure that describes the message.</p> </dd></param>
        /// <param name = "messageByteLengthRef"><dd> <p>A reference to a variable that receives the size, in bytes, of the message description  that <em>pMessage</em> points to. This size includes the size of the message string that <em>pMessage</em> points to.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <p>This method doesn't remove any messages from the message queue.</p><p>This method gets a message from the message queue after an optional retrieval filter has been applied.</p><p>Call this method twice to retrieve a message, first to obtain the size of the message and second to get the message. Here is a typical example:</p><pre> // Get the size of the message.
        /// <see cref = "SharpDX.PointerSize"/> messageLength = 0;
        /// <see cref = "SharpDX.Result"/> hr = pInfoQueue-&gt;GetMessage(DXGI_DEBUG_ALL, 0, <c>null</c>, &amp;messageLength); // Allocate space and get the message.
        /// <see cref = "SharpDX.DXGI.InformationQueueMessage"/> * pMessage = (<see cref = "SharpDX.DXGI.InformationQueueMessage"/>*)malloc(messageLength);
        /// hr = pInfoQueue-&gt;GetMessage(DXGI_DEBUG_ALL, 0, pMessage, &amp;messageLength);
        /// </pre><strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780366</doc-id>
        /// <unmanaged>HRESULT IDXGIInfoQueue::GetMessageW([In] GUID Producer,[In] unsigned longlong MessageIndex,[Out, Buffer, Optional] DXGI_INFO_QUEUE_MESSAGE* pMessage,[InOut] SIZE_T* pMessageByteLength)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::GetMessageW</unmanaged-short>
        public unsafe void GetMessage(System.Guid producer, System.Int64 messageIndex, SharpDX.DXGI.InformationQueueMessage[] messageRef, ref SharpDX.PointerSize messageByteLengthRef)
        {
            SharpDX.DXGI.InformationQueueMessage.__Native[] messageRef_ = messageRef == null ? null : new SharpDX.DXGI.InformationQueueMessage.__Native[messageRef.Length];
            SharpDX.Result __result__;
            fixed (void *messageByteLengthRef_ = &messageByteLengthRef)
                fixed (void *_messageRef = messageRef_)
                    __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, producer, messageIndex, _messageRef, messageByteLengthRef_, (*(void ***)this._nativePointer)[5]);
            if (messageRef != null)
                for (int i = 0; i < messageRef.Length; ++i)
                    if (messageRef != null)
                        messageRef[i].__MarshalFrom(ref (messageRef_)[i]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the number of messages that can pass through a retrieval filter.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that gets the number.</p> </dd></param>
        /// <returns><p>Returns the number of messages that can pass through a retrieval filter.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780373</doc-id>
        /// <unmanaged>unsigned longlong IDXGIInfoQueue::GetNumStoredMessagesAllowedByRetrievalFilters([In] GUID Producer)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::GetNumStoredMessagesAllowedByRetrievalFilters</unmanaged-short>
        public unsafe System.Int64 GetNumStoredMessagesAllowedByRetrievalFilters(System.Guid producer)
        {
            System.Int64 __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCalllong(this._nativePointer, producer, (*(void ***)this._nativePointer)[6]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the number of messages currently stored in the message queue.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that gets the number.</p> </dd></param>
        /// <returns><p>Returns the number of messages currently stored in the message queue.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780372</doc-id>
        /// <unmanaged>unsigned longlong IDXGIInfoQueue::GetNumStoredMessages([In] GUID Producer)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::GetNumStoredMessages</unmanaged-short>
        public unsafe System.Int64 GetNumStoredMessages(System.Guid producer)
        {
            System.Int64 __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCalllong(this._nativePointer, producer, (*(void ***)this._nativePointer)[7]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the number of messages that were discarded due to the message count limit.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that gets the number.</p> </dd></param>
        /// <returns><p>Returns the number of messages that were discarded.</p></returns>
        /// <remarks>
        /// <p>Get and set the message count limit with <strong>IDXGIInfoQueue::GetMessageCountLimit</strong> and <strong>IDXGIInfoQueue::SetMessageCountLimit</strong>, respectively. </p><strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780371</doc-id>
        /// <unmanaged>unsigned longlong IDXGIInfoQueue::GetNumMessagesDiscardedByMessageCountLimit([In] GUID Producer)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::GetNumMessagesDiscardedByMessageCountLimit</unmanaged-short>
        public unsafe System.Int64 GetNumMessagesDiscardedByMessageCountLimit(System.Guid producer)
        {
            System.Int64 __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCalllong(this._nativePointer, producer, (*(void ***)this._nativePointer)[8]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the maximum number of messages that can be added to the message queue.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that gets the number.</p> </dd></param>
        /// <returns><p>Returns the maximum number of messages that can be added to the queue. ?1 means no limit.</p></returns>
        /// <remarks>
        /// <p>When the number of messages in the message queue reaches the maximum limit, new messages coming in push old messages out.</p><strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780367</doc-id>
        /// <unmanaged>unsigned longlong IDXGIInfoQueue::GetMessageCountLimit([In] GUID Producer)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::GetMessageCountLimit</unmanaged-short>
        public unsafe System.Int64 GetMessageCountLimit(System.Guid producer)
        {
            System.Int64 __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCalllong(this._nativePointer, producer, (*(void ***)this._nativePointer)[9]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the number of messages that a storage filter allowed to pass through.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that gets the number.</p> </dd></param>
        /// <returns><p>Returns the number of messages allowed by a storage filter.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780369</doc-id>
        /// <unmanaged>unsigned longlong IDXGIInfoQueue::GetNumMessagesAllowedByStorageFilter([In] GUID Producer)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::GetNumMessagesAllowedByStorageFilter</unmanaged-short>
        public unsafe System.Int64 GetNumMessagesAllowedByStorageFilter(System.Guid producer)
        {
            System.Int64 __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCalllong(this._nativePointer, producer, (*(void ***)this._nativePointer)[10]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the number of messages that were denied passage through a storage filter.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that gets the number.</p> </dd></param>
        /// <returns><p>Returns the number of messages denied by a storage filter.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780370</doc-id>
        /// <unmanaged>unsigned longlong IDXGIInfoQueue::GetNumMessagesDeniedByStorageFilter([In] GUID Producer)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::GetNumMessagesDeniedByStorageFilter</unmanaged-short>
        public unsafe System.Int64 GetNumMessagesDeniedByStorageFilter(System.Guid producer)
        {
            System.Int64 __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCalllong(this._nativePointer, producer, (*(void ***)this._nativePointer)[11]);
            return __result__;
        }

        /// <summary>
        /// <p>Adds storage filters to the top of the storage-filter stack.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that produced the filters.</p> </dd></param>
        /// <param name = "filterRef"><dd> <p>An array of <strong><see cref = "SharpDX.DXGI.InfoQueueFilter"/></strong> structures that describe the filters.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780359</doc-id>
        /// <unmanaged>HRESULT IDXGIInfoQueue::AddStorageFilterEntries([In] GUID Producer,[In] DXGI_INFO_QUEUE_FILTER* pFilter)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::AddStorageFilterEntries</unmanaged-short>
        public unsafe void AddStorageFilterEntries(System.Guid producer, ref SharpDX.DXGI.InfoQueueFilter filterRef)
        {
            SharpDX.Result __result__;
            fixed (void *filterRef_ = &filterRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, producer, filterRef_, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the storage filter at the top of the storage-filter stack.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that gets the filter.</p> </dd></param>
        /// <param name = "filterRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.DXGI.InfoQueueFilter"/></strong> structure that describes the filter.</p> </dd></param>
        /// <param name = "filterByteLengthRef"><dd> <p>A reference to a variable that receives the size, in bytes, of the filter description to which <em>pFilter</em> points. If <em>pFilter</em> is <strong><c>null</c></strong>, <strong>GetStorageFilter</strong> outputs the size of the storage filter.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780376</doc-id>
        /// <unmanaged>HRESULT IDXGIInfoQueue::GetStorageFilter([In] GUID Producer,[Out, Buffer, Optional] DXGI_INFO_QUEUE_FILTER* pFilter,[InOut] SIZE_T* pFilterByteLength)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::GetStorageFilter</unmanaged-short>
        public unsafe void GetStorageFilter(System.Guid producer, SharpDX.DXGI.InfoQueueFilter[] filterRef, ref SharpDX.PointerSize filterByteLengthRef)
        {
            SharpDX.Result __result__;
            fixed (void *filterByteLengthRef_ = &filterByteLengthRef)
                fixed (void *filterRef_ = filterRef)
                    __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, producer, filterRef_, filterByteLengthRef_, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Removes a storage filter from the top of the storage-filter stack.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that removes the filter.</p> </dd></param>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780361</doc-id>
        /// <unmanaged>void IDXGIInfoQueue::ClearStorageFilter([In] GUID Producer)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::ClearStorageFilter</unmanaged-short>
        public unsafe void ClearStorageFilter(System.Guid producer)
        {
            SharpDX.DXGI.LocalInterop.CalliStdCallvoid(this._nativePointer, producer, (*(void ***)this._nativePointer)[14]);
        }

        /// <summary>
        /// <p>Pushes an empty storage filter onto the storage-filter stack.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that pushes the empty storage filter.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <p>An empty storage filter allows all messages to pass through.</p><strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780385</doc-id>
        /// <unmanaged>HRESULT IDXGIInfoQueue::PushEmptyStorageFilter([In] GUID Producer)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::PushEmptyStorageFilter</unmanaged-short>
        public unsafe void PushEmptyStorageFilter(System.Guid producer)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, producer, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Pushes a deny-all storage filter onto the storage-filter stack.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that pushes the filter.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <p>A deny-all storage filter prevents all messages from passing through.</p><strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780383</doc-id>
        /// <unmanaged>HRESULT IDXGIInfoQueue::PushDenyAllStorageFilter([In] GUID Producer)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::PushDenyAllStorageFilter</unmanaged-short>
        public unsafe void PushDenyAllStorageFilter(System.Guid producer)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, producer, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Pushes a copy of the storage filter that is currently on the top of the storage-filter stack onto the storage-filter stack.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that pushes the copy of the storage filter.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780381</doc-id>
        /// <unmanaged>HRESULT IDXGIInfoQueue::PushCopyOfStorageFilter([In] GUID Producer)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::PushCopyOfStorageFilter</unmanaged-short>
        public unsafe void PushCopyOfStorageFilter(System.Guid producer)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, producer, (*(void ***)this._nativePointer)[17]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Pushes a storage filter onto the storage-filter stack.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that pushes the filter.</p> </dd></param>
        /// <param name = "filterRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.DXGI.InfoQueueFilter"/></strong> structure that describes the filter.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780387</doc-id>
        /// <unmanaged>HRESULT IDXGIInfoQueue::PushStorageFilter([In] GUID Producer,[In] DXGI_INFO_QUEUE_FILTER* pFilter)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::PushStorageFilter</unmanaged-short>
        public unsafe void PushStorageFilter(System.Guid producer, ref SharpDX.DXGI.InfoQueueFilter filterRef)
        {
            SharpDX.Result __result__;
            fixed (void *filterRef_ = &filterRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, producer, filterRef_, (*(void ***)this._nativePointer)[18]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Pops a storage filter from the top of the storage-filter stack.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that pops the filter.</p> </dd></param>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780379</doc-id>
        /// <unmanaged>void IDXGIInfoQueue::PopStorageFilter([In] GUID Producer)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::PopStorageFilter</unmanaged-short>
        public unsafe void PopStorageFilter(System.Guid producer)
        {
            SharpDX.DXGI.LocalInterop.CalliStdCallvoid(this._nativePointer, producer, (*(void ***)this._nativePointer)[19]);
        }

        /// <summary>
        /// <p>Gets the size of the storage-filter stack in bytes.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that gets the size.</p> </dd></param>
        /// <returns><p>Returns the size of the storage-filter stack in bytes.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780377</doc-id>
        /// <unmanaged>unsigned int IDXGIInfoQueue::GetStorageFilterStackSize([In] GUID Producer)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::GetStorageFilterStackSize</unmanaged-short>
        public unsafe System.Int32 GetStorageFilterStackSize(System.Guid producer)
        {
            System.Int32 __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, producer, (*(void ***)this._nativePointer)[20]);
            return __result__;
        }

        /// <summary>
        /// <p>Adds retrieval filters to the top of the retrieval-filter stack.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that produced the filters.</p> </dd></param>
        /// <param name = "filterRef"><dd> <p>An array of <strong><see cref = "SharpDX.DXGI.InfoQueueFilter"/></strong> structures that describe the filters.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780358</doc-id>
        /// <unmanaged>HRESULT IDXGIInfoQueue::AddRetrievalFilterEntries([In] GUID Producer,[In] DXGI_INFO_QUEUE_FILTER* pFilter)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::AddRetrievalFilterEntries</unmanaged-short>
        public unsafe void AddRetrievalFilterEntries(System.Guid producer, ref SharpDX.DXGI.InfoQueueFilter filterRef)
        {
            SharpDX.Result __result__;
            fixed (void *filterRef_ = &filterRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, producer, filterRef_, (*(void ***)this._nativePointer)[21]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the retrieval filter at the top of the retrieval-filter stack.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that gets the filter.</p> </dd></param>
        /// <param name = "filterRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.DXGI.InfoQueueFilter"/></strong> structure that describes the filter.</p> </dd></param>
        /// <param name = "filterByteLengthRef"><dd> <p>A reference to a variable that receives the size, in bytes, of the filter description to which <em>pFilter</em> points. If <em>pFilter</em> is <strong><c>null</c></strong>, <strong>GetRetrievalFilter</strong> outputs the size of the retrieval filter.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780374</doc-id>
        /// <unmanaged>HRESULT IDXGIInfoQueue::GetRetrievalFilter([In] GUID Producer,[Out, Buffer, Optional] DXGI_INFO_QUEUE_FILTER* pFilter,[InOut] SIZE_T* pFilterByteLength)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::GetRetrievalFilter</unmanaged-short>
        public unsafe void GetRetrievalFilter(System.Guid producer, SharpDX.DXGI.InfoQueueFilter[] filterRef, ref SharpDX.PointerSize filterByteLengthRef)
        {
            SharpDX.Result __result__;
            fixed (void *filterByteLengthRef_ = &filterByteLengthRef)
                fixed (void *filterRef_ = filterRef)
                    __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, producer, filterRef_, filterByteLengthRef_, (*(void ***)this._nativePointer)[22]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Removes a retrieval filter from the top of the retrieval-filter stack.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that removes the filter.</p> </dd></param>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780360</doc-id>
        /// <unmanaged>void IDXGIInfoQueue::ClearRetrievalFilter([In] GUID Producer)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::ClearRetrievalFilter</unmanaged-short>
        public unsafe void ClearRetrievalFilter(System.Guid producer)
        {
            SharpDX.DXGI.LocalInterop.CalliStdCallvoid(this._nativePointer, producer, (*(void ***)this._nativePointer)[23]);
        }

        /// <summary>
        /// <p>Pushes an empty retrieval filter onto the retrieval-filter stack.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that pushes the empty retrieval filter.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <p>An empty retrieval filter allows all messages to pass through.</p><strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780384</doc-id>
        /// <unmanaged>HRESULT IDXGIInfoQueue::PushEmptyRetrievalFilter([In] GUID Producer)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::PushEmptyRetrievalFilter</unmanaged-short>
        public unsafe void PushEmptyRetrievalFilter(System.Guid producer)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, producer, (*(void ***)this._nativePointer)[24]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Pushes a deny-all retrieval filter onto the retrieval-filter stack.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that pushes the deny-all retrieval filter.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <p>A deny-all retrieval filter prevents all messages from passing through.</p><strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780382</doc-id>
        /// <unmanaged>HRESULT IDXGIInfoQueue::PushDenyAllRetrievalFilter([In] GUID Producer)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::PushDenyAllRetrievalFilter</unmanaged-short>
        public unsafe void PushDenyAllRetrievalFilter(System.Guid producer)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, producer, (*(void ***)this._nativePointer)[25]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Pushes a copy of the retrieval filter that is currently on the top of the retrieval-filter stack onto the retrieval-filter stack.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that pushes the copy of the retrieval filter.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780380</doc-id>
        /// <unmanaged>HRESULT IDXGIInfoQueue::PushCopyOfRetrievalFilter([In] GUID Producer)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::PushCopyOfRetrievalFilter</unmanaged-short>
        public unsafe void PushCopyOfRetrievalFilter(System.Guid producer)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, producer, (*(void ***)this._nativePointer)[26]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Pushes a retrieval filter onto the retrieval-filter stack.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that pushes the filter.</p> </dd></param>
        /// <param name = "filterRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.DXGI.InfoQueueFilter"/></strong> structure that describes the filter.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780386</doc-id>
        /// <unmanaged>HRESULT IDXGIInfoQueue::PushRetrievalFilter([In] GUID Producer,[In] DXGI_INFO_QUEUE_FILTER* pFilter)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::PushRetrievalFilter</unmanaged-short>
        public unsafe void PushRetrievalFilter(System.Guid producer, ref SharpDX.DXGI.InfoQueueFilter filterRef)
        {
            SharpDX.Result __result__;
            fixed (void *filterRef_ = &filterRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, producer, filterRef_, (*(void ***)this._nativePointer)[27]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Pops a retrieval filter from the top of the retrieval-filter stack.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that pops the filter.</p> </dd></param>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780378</doc-id>
        /// <unmanaged>void IDXGIInfoQueue::PopRetrievalFilter([In] GUID Producer)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::PopRetrievalFilter</unmanaged-short>
        public unsafe void PopRetrievalFilter(System.Guid producer)
        {
            SharpDX.DXGI.LocalInterop.CalliStdCallvoid(this._nativePointer, producer, (*(void ***)this._nativePointer)[28]);
        }

        /// <summary>
        /// <p>Gets the size of the retrieval-filter stack in bytes.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that gets the size.</p> </dd></param>
        /// <returns><p>Returns the size of the retrieval-filter stack in bytes.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780375</doc-id>
        /// <unmanaged>unsigned int IDXGIInfoQueue::GetRetrievalFilterStackSize([In] GUID Producer)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::GetRetrievalFilterStackSize</unmanaged-short>
        public unsafe System.Int32 GetRetrievalFilterStackSize(System.Guid producer)
        {
            System.Int32 __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, producer, (*(void ***)this._nativePointer)[29]);
            return __result__;
        }

        /// <summary>
        /// <p>Adds a debug message to the message queue and sends that message to the debug output.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that produced the message.</p> </dd></param>
        /// <param name = "category"><dd> <p>A <strong><see cref = "SharpDX.DXGI.InformationQueueMessageCategory"/></strong>-typed value that specifies the category of the message.</p> </dd></param>
        /// <param name = "severity"><dd> <p>A <strong><see cref = "SharpDX.DXGI.InformationQueueMessageSeverity"/></strong>-typed value that specifies the severity of the message.</p> </dd></param>
        /// <param name = "id"><dd> <p>An integer that uniquely identifies the message.</p> </dd></param>
        /// <param name = "descriptionRef"><dd> <p>The message string.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780357</doc-id>
        /// <unmanaged>HRESULT IDXGIInfoQueue::AddMessage([In] GUID Producer,[In] DXGI_INFO_QUEUE_MESSAGE_CATEGORY Category,[In] DXGI_INFO_QUEUE_MESSAGE_SEVERITY Severity,[In] int ID,[In] const char* pDescription)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::AddMessage</unmanaged-short>
        public unsafe void AddMessage(System.Guid producer, SharpDX.DXGI.InformationQueueMessageCategory category, SharpDX.DXGI.InformationQueueMessageSeverity severity, System.Int32 id, System.String descriptionRef)
        {
            System.IntPtr descriptionRef_;
            SharpDX.Result __result__;
            descriptionRef_ = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(descriptionRef);
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, producer, unchecked ((System.Int32)category), unchecked ((System.Int32)severity), id, (void *)descriptionRef_, (*(void ***)this._nativePointer)[30]);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(descriptionRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Adds a user-defined message to the message queue and sends that message to the debug output.</p>
        /// </summary>
        /// <param name = "severity"><dd> <p>A <strong><see cref = "SharpDX.DXGI.InformationQueueMessageSeverity"/></strong>-typed value that specifies the severity of the message.</p> </dd></param>
        /// <param name = "descriptionRef"><dd> <p>The message string.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780356</doc-id>
        /// <unmanaged>HRESULT IDXGIInfoQueue::AddApplicationMessage([In] DXGI_INFO_QUEUE_MESSAGE_SEVERITY Severity,[In] const char* pDescription)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::AddApplicationMessage</unmanaged-short>
        public unsafe void AddApplicationMessage(SharpDX.DXGI.InformationQueueMessageSeverity severity, System.String descriptionRef)
        {
            System.IntPtr descriptionRef_;
            SharpDX.Result __result__;
            descriptionRef_ = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(descriptionRef);
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)severity), (void *)descriptionRef_, (*(void ***)this._nativePointer)[31]);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(descriptionRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets a message category to break on when a message with that category passes through the storage filter.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that sets the breaking condition.</p> </dd></param>
        /// <param name = "category"><dd> <p>A <strong><see cref = "SharpDX.DXGI.InformationQueueMessageCategory"/></strong>-typed value that specifies the category of the message.</p> </dd></param>
        /// <param name = "bEnable"><dd> <p>A Boolean value that specifies whether <strong>SetBreakOnCategory</strong> turns on or off this breaking condition (<strong>TRUE</strong> for on, <strong><see cref = "SharpDX.Result.False"/></strong> for off).</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780388</doc-id>
        /// <unmanaged>HRESULT IDXGIInfoQueue::SetBreakOnCategory([In] GUID Producer,[In] DXGI_INFO_QUEUE_MESSAGE_CATEGORY Category,[In] BOOL bEnable)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::SetBreakOnCategory</unmanaged-short>
        public unsafe void SetBreakOnCategory(System.Guid producer, SharpDX.DXGI.InformationQueueMessageCategory category, SharpDX.Mathematics.Interop.RawBool bEnable)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint0(this._nativePointer, producer, unchecked ((System.Int32)category), bEnable, (*(void ***)this._nativePointer)[32]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets a message severity level to break on when a message with that severity level passes through the storage filter.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that sets the breaking condition.</p> </dd></param>
        /// <param name = "severity"><dd> <p>A <strong><see cref = "SharpDX.DXGI.InformationQueueMessageSeverity"/></strong>-typed value that specifies the severity of the message.</p> </dd></param>
        /// <param name = "bEnable"><dd> <p>A Boolean value that specifies whether <strong>SetBreakOnSeverity</strong> turns on or off this breaking condition (<strong>TRUE</strong> for on, <strong><see cref = "SharpDX.Result.False"/></strong> for off).</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780390</doc-id>
        /// <unmanaged>HRESULT IDXGIInfoQueue::SetBreakOnSeverity([In] GUID Producer,[In] DXGI_INFO_QUEUE_MESSAGE_SEVERITY Severity,[In] BOOL bEnable)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::SetBreakOnSeverity</unmanaged-short>
        public unsafe void SetBreakOnSeverity(System.Guid producer, SharpDX.DXGI.InformationQueueMessageSeverity severity, SharpDX.Mathematics.Interop.RawBool bEnable)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint0(this._nativePointer, producer, unchecked ((System.Int32)severity), bEnable, (*(void ***)this._nativePointer)[33]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets a message identifier to break on when a message with that identifier passes through the storage filter.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that sets the breaking condition.</p> </dd></param>
        /// <param name = "id"><dd> <p>An integer value that specifies the identifier of the message.</p> </dd></param>
        /// <param name = "bEnable"><dd> <p>A Boolean value that specifies whether <strong>SetBreakOnID</strong> turns on or off this breaking condition (<strong>TRUE</strong> for on, <strong><see cref = "SharpDX.Result.False"/></strong> for off).</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780389</doc-id>
        /// <unmanaged>HRESULT IDXGIInfoQueue::SetBreakOnID([In] GUID Producer,[In] int ID,[In] BOOL bEnable)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::SetBreakOnID</unmanaged-short>
        public unsafe void SetBreakOnID(System.Guid producer, System.Int32 id, SharpDX.Mathematics.Interop.RawBool bEnable)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint0(this._nativePointer, producer, id, bEnable, (*(void ***)this._nativePointer)[34]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Determines whether the break on a message category is turned on or off.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that gets the breaking status.</p> </dd></param>
        /// <param name = "category"><dd> <p>A <strong><see cref = "SharpDX.DXGI.InformationQueueMessageCategory"/></strong>-typed value that specifies the category of the message.</p> </dd></param>
        /// <returns><p>Returns a Boolean value that specifies whether this category of breaking condition is turned on or off (<strong>TRUE</strong> for on, <strong><see cref = "SharpDX.Result.False"/></strong> for off).</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780363</doc-id>
        /// <unmanaged>BOOL IDXGIInfoQueue::GetBreakOnCategory([In] GUID Producer,[In] DXGI_INFO_QUEUE_MESSAGE_CATEGORY Category)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::GetBreakOnCategory</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool GetBreakOnCategory(System.Guid producer, SharpDX.DXGI.InformationQueueMessageCategory category)
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, producer, unchecked ((System.Int32)category), (*(void ***)this._nativePointer)[35]);
            return __result__;
        }

        /// <summary>
        /// <p>Determines whether the break on a message severity level is turned on or off.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that gets the breaking status.</p> </dd></param>
        /// <param name = "severity"><dd> <p>A <strong><see cref = "SharpDX.DXGI.InformationQueueMessageSeverity"/></strong>-typed value that specifies the severity of the message.</p> </dd></param>
        /// <returns><p>Returns a Boolean value that specifies whether this severity of breaking condition is turned on or off (<strong>TRUE</strong> for on, <strong><see cref = "SharpDX.Result.False"/></strong> for off).</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780365</doc-id>
        /// <unmanaged>BOOL IDXGIInfoQueue::GetBreakOnSeverity([In] GUID Producer,[In] DXGI_INFO_QUEUE_MESSAGE_SEVERITY Severity)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::GetBreakOnSeverity</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool GetBreakOnSeverity(System.Guid producer, SharpDX.DXGI.InformationQueueMessageSeverity severity)
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, producer, unchecked ((System.Int32)severity), (*(void ***)this._nativePointer)[36]);
            return __result__;
        }

        /// <summary>
        /// <p>Determines whether the break on a message identifier is turned on or off.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that gets the breaking status.</p> </dd></param>
        /// <param name = "id"><dd> <p>An integer value that specifies the identifier of the message.</p> </dd></param>
        /// <returns><p>Returns a Boolean value that specifies whether this break on a message identifier is turned on or off (<strong>TRUE</strong> for on, <strong><see cref = "SharpDX.Result.False"/></strong> for off).</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780364</doc-id>
        /// <unmanaged>BOOL IDXGIInfoQueue::GetBreakOnID([In] GUID Producer,[In] int ID)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::GetBreakOnID</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool GetBreakOnID(System.Guid producer, System.Int32 id)
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, producer, id, (*(void ***)this._nativePointer)[37]);
            return __result__;
        }

        /// <summary>
        /// <p>Turns the debug output on or off.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that gets the mute status.</p> </dd></param>
        /// <param name = "bMute"><dd> <p>A Boolean value that specifies whether to turn the debug output on or off (<strong>TRUE</strong> for on, <strong><see cref = "SharpDX.Result.False"/></strong> for off).</p> </dd></param>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780392</doc-id>
        /// <unmanaged>void IDXGIInfoQueue::SetMuteDebugOutput([In] GUID Producer,[In] BOOL bMute)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::SetMuteDebugOutput</unmanaged-short>
        public unsafe void SetMuteDebugOutput(System.Guid producer, SharpDX.Mathematics.Interop.RawBool bMute)
        {
            SharpDX.DXGI.LocalInterop.CalliStdCallvoid0(this._nativePointer, producer, bMute, (*(void ***)this._nativePointer)[38]);
        }

        /// <summary>
        /// <p>Determines whether the debug output is turned on or off.</p>
        /// </summary>
        /// <param name = "producer"><dd> <p> A <strong>DXGI_DEBUG_ID</strong> value that identifies the entity that gets the mute status.</p> </dd></param>
        /// <returns><p>Returns a Boolean value that specifies whether the debug output is turned on or off (<strong>TRUE</strong> for on, <strong><see cref = "SharpDX.Result.False"/></strong> for off).</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh780368</doc-id>
        /// <unmanaged>BOOL IDXGIInfoQueue::GetMuteDebugOutput([In] GUID Producer)</unmanaged>
        /// <unmanaged-short>IDXGIInfoQueue::GetMuteDebugOutput</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool GetMuteDebugOutput(System.Guid producer)
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, producer, (*(void ***)this._nativePointer)[39]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("4C8798B7-1D88-4A0F-B59B-B93F600DE8C8")]
    public partial class ISurfaceImageSourceManagerNative : SharpDX.ComObject
    {
        public ISurfaceImageSourceManagerNative(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ISurfaceImageSourceManagerNative(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ISurfaceImageSourceManagerNative(nativePtr);
        /// <summary>
        /// <p>Flushes all current GPU work for all <strong>SurfaceImageSource</strong> or <strong>VirtualSurfaceImageSource</strong> objects associated with the given device.</p>
        /// </summary>
        /// <param name = "device">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The <strong>FlushAllSurfacesWithDevice</strong> method flushes current GPU work for all <strong>SurfaceImageSource</strong> objects that were created with <em>device</em>.  This GPU work includes Direct2D rendering work and internal GPU work done by the framework associated with rendering.  This is useful if an application has created multiple <strong>SurfaceImageSource</strong> objects and needs to flush the GPU work for all of these surfaces from the background rendering thread.  By flushing this work from the background thread the work can be better parallelized, with work being done on the UI thread to improve performance.</p><p>You can call the <strong>FlushAllSurfacesWithDevice</strong> method from a non-UI thread.  </p>
        /// </remarks>
        /// <doc-id>dn448960</doc-id>
        /// <unmanaged>HRESULT ISurfaceImageSourceManagerNative::FlushAllSurfacesWithDevice([In] IUnknown* device)</unmanaged>
        /// <unmanaged-short>ISurfaceImageSourceManagerNative::FlushAllSurfacesWithDevice</unmanaged-short>
        public unsafe void FlushAllSurfacesWithDevice(SharpDX.IUnknown device)
        {
            System.IntPtr device_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            device_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(device);
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)device_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("f2e9edc1-d307-4525-9886-0fafaa44163c")]
    public partial class ISurfaceImageSourceNative : SharpDX.ComObject
    {
        public ISurfaceImageSourceNative(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ISurfaceImageSourceNative(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ISurfaceImageSourceNative(nativePtr);
        /// <summary>
        /// <p>Sets the DXGI device, created with D3D11_CREATE_DEVICE_BGRA_SUPPORT, that will draw the surface.  This method must be called from the UI thread.</p>
        /// </summary>
        /// <doc-id>hh848325</doc-id>
        /// <unmanaged>SetDevice</unmanaged>
        /// <unmanaged-short>SetDevice</unmanaged-short>
        public SharpDX.DXGI.Device Device
        {
            set => SetDevice(value);
        }

        /// <summary>
        /// <p>Sets the DXGI device, created with D3D11_CREATE_DEVICE_BGRA_SUPPORT, that will draw the surface.  This method must be called from the UI thread.</p>
        /// </summary>
        /// <param name = "device"><dd> <p>Pointer to the DXGI device interface.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh848325</doc-id>
        /// <unmanaged>HRESULT ISurfaceImageSourceNative::SetDevice([In] IDXGIDevice* device)</unmanaged>
        /// <unmanaged-short>ISurfaceImageSourceNative::SetDevice</unmanaged-short>
        internal unsafe void SetDevice(SharpDX.DXGI.Device device)
        {
            System.IntPtr device_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            device_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Device>(device);
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)device_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Opens the supplied DXGI surface for drawing.</p>
        /// </summary>
        /// <param name = "updateRect"><dd> <p>The region of the surface that will be drawn into.</p> </dd></param>
        /// <param name = "offset"><dd> <p>Receives the point (x,y) offset of the surface that will be drawn into.</p> </dd></param>
        /// <returns><dd> <p>Receives a reference to the surface for drawing. </p> </dd></returns>
        /// <remarks>
        /// <p>If the app window that contains the <strong>SurfaceImageSource</strong> isn't active, like when it's suspended, calling the <strong>BeginDraw</strong> method returns an error.</p>
        /// </remarks>
        /// <doc-id>hh848323</doc-id>
        /// <unmanaged>HRESULT ISurfaceImageSourceNative::BeginDraw([In] RECT updateRect,[Out] IDXGISurface** surface,[Out] POINT* offset)</unmanaged>
        /// <unmanaged-short>ISurfaceImageSourceNative::BeginDraw</unmanaged-short>
        public unsafe SharpDX.DXGI.Surface BeginDraw(SharpDX.Mathematics.Interop.RawRectangle updateRect, out SharpDX.Mathematics.Interop.RawPoint offset)
        {
            SharpDX.DXGI.Surface surface;
            System.IntPtr surface_ = System.IntPtr.Zero;
            offset = default (SharpDX.Mathematics.Interop.RawPoint);
            SharpDX.Result __result__;
            fixed (void *offset_ = &offset)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint0(this._nativePointer, updateRect, &surface_, offset_, (*(void ***)this._nativePointer)[4]);
            if (surface_ != System.IntPtr.Zero)
                surface = new SharpDX.DXGI.Surface(surface_);
            else
                surface = null;
            __result__.CheckError();
            return surface;
        }

        /// <summary>
        /// <p>Closes the surface draw operation.</p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh848324</doc-id>
        /// <unmanaged>HRESULT ISurfaceImageSourceNative::EndDraw()</unmanaged>
        /// <unmanaged-short>ISurfaceImageSourceNative::EndDraw</unmanaged-short>
        public unsafe void EndDraw()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("54298223-41e1-4a41-9c08-02e8256864a1")]
    public partial class ISurfaceImageSourceNativeWithD2D : SharpDX.ComObject
    {
        public ISurfaceImageSourceNativeWithD2D(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ISurfaceImageSourceNativeWithD2D(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ISurfaceImageSourceNativeWithD2D(nativePtr);
        /// <summary>
        /// <p>Sets the Microsoft DirectX Graphics Infrastructure (DXGI) or Direct2D device, created with <strong>D3D11_CREATE_DEVICE_BGRA_SUPPORT</strong>, that will draw the surface.</p>
        /// </summary>
        /// <doc-id>dn302141</doc-id>
        /// <unmanaged>SetDevice</unmanaged>
        /// <unmanaged-short>SetDevice</unmanaged-short>
        public SharpDX.IUnknown Device
        {
            set => SetDevice(value);
        }

        /// <summary>
        /// <p>Sets the Microsoft DirectX Graphics Infrastructure (DXGI) or Direct2D device, created with <strong>D3D11_CREATE_DEVICE_BGRA_SUPPORT</strong>, that will draw the surface.</p>
        /// </summary>
        /// <param name = "device"><dd> <p>Pointer to the DXGI device interface. You can pass an <strong><see cref = "SharpDX.Direct2D1.Device"/></strong> to signal that this surface participates in Direct2D batching to improve performance when updating Direct2D content across multiple surfaces.  The device must have multithreading supported enabled if the app draws to the surface from a background thread. </p> </dd></param>
        /// <returns><p>This method fails when the SurfaceImageSource is larger than the maximum texture size supported by the Direct3D device. Apps should use VirtualSurfaceImageSource for surfaces larger than the maximum texture size supported by the Direct3D device.</p></returns>
        /// <doc-id>dn302141</doc-id>
        /// <unmanaged>HRESULT ISurfaceImageSourceNativeWithD2D::SetDevice([In] IUnknown* device)</unmanaged>
        /// <unmanaged-short>ISurfaceImageSourceNativeWithD2D::SetDevice</unmanaged-short>
        internal unsafe void SetDevice(SharpDX.IUnknown device)
        {
            System.IntPtr device_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            device_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(device);
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)device_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Initiates an update to the associated <strong>SurfaceImageSource</strong> or <strong>VirtualSurfaceImageSource</strong>.</p>
        /// </summary>
        /// <param name = "updateRect">No documentation.</param>
        /// <param name = "iid">No documentation.</param>
        /// <param name = "updateObject">No documentation.</param>
        /// <param name = "offset">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn302138</doc-id>
        /// <unmanaged>HRESULT ISurfaceImageSourceNativeWithD2D::BeginDraw([In] const RECT&amp; updateRect,[In] const GUID&amp; iid,[Out] void** updateObject,[Out] POINT* offset)</unmanaged>
        /// <unmanaged-short>ISurfaceImageSourceNativeWithD2D::BeginDraw</unmanaged-short>
        public unsafe void BeginDraw(SharpDX.Mathematics.Interop.RawRectangle updateRect, System.Guid iid, out System.IntPtr updateObject, out SharpDX.Mathematics.Interop.RawPoint offset)
        {
            offset = default (SharpDX.Mathematics.Interop.RawPoint);
            SharpDX.Result __result__;
            fixed (void *offset_ = &offset)
                fixed (void *updateObject_ = &updateObject)
                    __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &updateRect, &iid, updateObject_, offset_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Closes the surface draw operation.</p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Always call the <strong>EndDraw</strong> method on the UI thread in order to synchronize updating the Microsoft DirectX content with the current XAML UI thread frame.  </p>
        /// </remarks>
        /// <doc-id>dn302139</doc-id>
        /// <unmanaged>HRESULT ISurfaceImageSourceNativeWithD2D::EndDraw()</unmanaged>
        /// <unmanaged-short>ISurfaceImageSourceNativeWithD2D::EndDraw</unmanaged-short>
        public unsafe void EndDraw()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Suspends the drawing operation.</p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn302142</doc-id>
        /// <unmanaged>HRESULT ISurfaceImageSourceNativeWithD2D::SuspendDraw()</unmanaged>
        /// <unmanaged-short>ISurfaceImageSourceNativeWithD2D::SuspendDraw</unmanaged-short>
        public unsafe void SuspendDraw()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Resume the drawing operation.</p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn302140</doc-id>
        /// <unmanaged>HRESULT ISurfaceImageSourceNativeWithD2D::ResumeDraw()</unmanaged>
        /// <unmanaged-short>ISurfaceImageSourceNativeWithD2D::ResumeDraw</unmanaged-short>
        public unsafe void ResumeDraw()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("43bebd4e-add5-4035-8f85-5608d08e9dc9")]
    public partial class ISwapChainBackgroundPanelNative : SharpDX.ComObject
    {
        public ISwapChainBackgroundPanelNative(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ISwapChainBackgroundPanelNative(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ISwapChainBackgroundPanelNative(nativePtr);
        /// <summary>
        /// <p>Sets the DirectX swap chain for <strong>SwapChainBackgroundPanel</strong>.</p>
        /// </summary>
        /// <doc-id>hh848327</doc-id>
        /// <unmanaged>SetSwapChain</unmanaged>
        /// <unmanaged-short>SetSwapChain</unmanaged-short>
        public SharpDX.DXGI.SwapChain SwapChain
        {
            set => SetSwapChain(value);
        }

        /// <summary>
        /// <p>Sets the DirectX swap chain for <strong>SwapChainBackgroundPanel</strong>.</p>
        /// </summary>
        /// <param name = "swapChain">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh848327</doc-id>
        /// <unmanaged>HRESULT ISwapChainBackgroundPanelNative::SetSwapChain([In] IDXGISwapChain* swapChain)</unmanaged>
        /// <unmanaged-short>ISwapChainBackgroundPanelNative::SetSwapChain</unmanaged-short>
        internal unsafe void SetSwapChain(SharpDX.DXGI.SwapChain swapChain)
        {
            System.IntPtr swapChain_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            swapChain_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.SwapChain>(swapChain);
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)swapChain_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("F92F19D2-3ADE-45A6-A20C-F6F1EA90554B")]
    public partial class ISwapChainPanelNative : SharpDX.ComObject
    {
        public ISwapChainPanelNative(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ISwapChainPanelNative(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ISwapChainPanelNative(nativePtr);
        /// <summary>
        /// <p>Sets the DirectX swap chain for <strong>SwapChainPanel</strong>.</p>
        /// </summary>
        /// <doc-id>dn302144</doc-id>
        /// <unmanaged>SetSwapChain</unmanaged>
        /// <unmanaged-short>SetSwapChain</unmanaged-short>
        public SharpDX.DXGI.SwapChain SwapChain
        {
            set => SetSwapChain(value);
        }

        /// <summary>
        /// <p>Sets the DirectX swap chain for <strong>SwapChainPanel</strong>.</p>
        /// </summary>
        /// <param name = "swapChain">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn302144</doc-id>
        /// <unmanaged>HRESULT ISwapChainPanelNative::SetSwapChain([In] IDXGISwapChain* swapChain)</unmanaged>
        /// <unmanaged-short>ISwapChainPanelNative::SetSwapChain</unmanaged-short>
        internal unsafe void SetSwapChain(SharpDX.DXGI.SwapChain swapChain)
        {
            System.IntPtr swapChain_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            swapChain_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.SwapChain>(swapChain);
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)swapChain_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("D5A2F60C-37B2-44A2-937B-8D8EB9726821")]
    public partial class ISwapChainPanelNative2 : SharpDX.DXGI.ISwapChainPanelNative
    {
        public ISwapChainPanelNative2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ISwapChainPanelNative2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ISwapChainPanelNative2(nativePtr);
        /// <summary>
        /// <p>Sets the DirectX swap chain for <strong>SwapChainPanel</strong> using a handle to the swap chain.</p>
        /// </summary>
        /// <remarks>
        /// <p>SetSwapChain(HANDLE swapChainHandle) allows a swap chain to be rendered by referencing a shared handle to the swap chain.   This enables scenarios where a swap chain is created in one process and needs to be passed to another process.</p><p>XAML supports setting a DXGI swap chain as the content of a SwapChainPanel element.  Apps accomplish this by querying for  the <strong><see cref = "SharpDX.DXGI.ISwapChainPanelNative"/></strong> interface from a SwapChainPanel instance and calling <strong>SetSwapChain(<see cref = "SharpDX.DXGI.SwapChain"/> *swapChain)</strong>.   </p><p>This process works for references to in process swap chains.  However, this doesn?t work for VoIP apps, which use a two-process model to enable continuing calls on a background process  when a foreground process is suspended or shut down.  This two-process implementation requires the ability to pass a shared handle to a swap chain, rather than a reference, created on the  background process to the foreground process to be rendered in a XAML SwapChainPanel in the foreground app.</p><pre> &lt;!-- XAML markup --&gt; 
        /// &lt;Page&gt;  &lt;SwapChainPanel x:Name=?captureStreamDisplayPanel? /&gt; 
        /// &lt;/Page&gt;  // Definitions 
        /// ComPtr&lt;<see cref = "SharpDX.DXGI.SwapChain1"/>&gt; m_swapChain; 
        /// HANDLE m_swapChainHandle; 
        /// ComPtr&lt;<see cref = "SharpDX.Direct3D11.Device"/>&gt; m_d3dDevice; 
        /// ComPtr&lt;<see cref = "SharpDX.DXGI.Adapter"/>&gt; dxgiAdapter; 
        /// ComPtr&lt;<see cref = "SharpDX.DXGI.Factory2"/>&gt; dxgiFactory; 
        /// ComPtr&lt;<see cref = "SharpDX.DXGI.FactoryMedia"/>&gt; dxgiFactoryMedia; 
        /// ComPtr&lt;<see cref = "SharpDX.DXGI.Device"/>&gt; dxgiDevice; 
        /// <see cref = "SharpDX.DXGI.SwapChainDescription1"/> swapChainDesc = {0};  // Get DXGI factory (assume standard boilerplate has created D3D11Device) 
        /// m_d3dDevice.As(&amp;dxgiDevice); 
        /// dxgiDevice-&gt;GetAdapter(&amp;dxgiAdapter); 
        /// dxgiAdapter-&gt;GetParent(__uuidof(<see cref = "SharpDX.DXGI.Factory2"/>), &amp;dxgiFactory);  // Create swap chain and get handle 
        /// DCompositionCreateSurfaceHandle(GENERIC_ALL, nullptr, &amp;m_swapChainHandle); 
        /// dxgiFactory.As(&amp;dxgiFactoryMedia); 
        /// dxgiFactoryMedia-&gt;CreateSwapChainForCompositionSurfaceHandle(  m_d3dDevice.Get(),  m_swapChainHandle,  &amp;swapChainDesc,  nullptr,  &amp;m_swapChain 
        /// );  // Set swap chain to display in a SwapChainPanel 
        /// ComPtr&lt;<see cref = "SharpDX.DXGI.ISwapChainPanelNative2"/>&gt; panelNative; 
        /// reinterpret_cast&lt;<see cref = "SharpDX.IUnknown"/>*&gt;(captureStreamDisplayPanel)-&gt;QueryInterface(IID_PPV_ARGS(&amp;panelNative))); 
        /// panelNative-&gt;SetSwapChainHandle(m_swapChainHandle);  </pre>
        /// </remarks>
        /// <doc-id>dn858173</doc-id>
        /// <unmanaged>SetSwapChainHandle</unmanaged>
        /// <unmanaged-short>SetSwapChainHandle</unmanaged-short>
        public System.IntPtr SwapChainHandle
        {
            set => SetSwapChainHandle(value);
        }

        /// <summary>
        /// <p>Sets the DirectX swap chain for <strong>SwapChainPanel</strong> using a handle to the swap chain.</p>
        /// </summary>
        /// <param name = "swapChainHandle">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>SetSwapChain(HANDLE swapChainHandle) allows a swap chain to be rendered by referencing a shared handle to the swap chain.   This enables scenarios where a swap chain is created in one process and needs to be passed to another process.</p><p>XAML supports setting a DXGI swap chain as the content of a SwapChainPanel element.  Apps accomplish this by querying for  the <strong><see cref = "SharpDX.DXGI.ISwapChainPanelNative"/></strong> interface from a SwapChainPanel instance and calling <strong>SetSwapChain(<see cref = "SharpDX.DXGI.SwapChain"/> *swapChain)</strong>.   </p><p>This process works for references to in process swap chains.  However, this doesn?t work for VoIP apps, which use a two-process model to enable continuing calls on a background process  when a foreground process is suspended or shut down.  This two-process implementation requires the ability to pass a shared handle to a swap chain, rather than a reference, created on the  background process to the foreground process to be rendered in a XAML SwapChainPanel in the foreground app.</p><pre> &lt;!-- XAML markup --&gt; 
        /// &lt;Page&gt;  &lt;SwapChainPanel x:Name=?captureStreamDisplayPanel? /&gt; 
        /// &lt;/Page&gt;  // Definitions 
        /// ComPtr&lt;<see cref = "SharpDX.DXGI.SwapChain1"/>&gt; m_swapChain; 
        /// HANDLE m_swapChainHandle; 
        /// ComPtr&lt;<see cref = "SharpDX.Direct3D11.Device"/>&gt; m_d3dDevice; 
        /// ComPtr&lt;<see cref = "SharpDX.DXGI.Adapter"/>&gt; dxgiAdapter; 
        /// ComPtr&lt;<see cref = "SharpDX.DXGI.Factory2"/>&gt; dxgiFactory; 
        /// ComPtr&lt;<see cref = "SharpDX.DXGI.FactoryMedia"/>&gt; dxgiFactoryMedia; 
        /// ComPtr&lt;<see cref = "SharpDX.DXGI.Device"/>&gt; dxgiDevice; 
        /// <see cref = "SharpDX.DXGI.SwapChainDescription1"/> swapChainDesc = {0};  // Get DXGI factory (assume standard boilerplate has created D3D11Device) 
        /// m_d3dDevice.As(&amp;dxgiDevice); 
        /// dxgiDevice-&gt;GetAdapter(&amp;dxgiAdapter); 
        /// dxgiAdapter-&gt;GetParent(__uuidof(<see cref = "SharpDX.DXGI.Factory2"/>), &amp;dxgiFactory);  // Create swap chain and get handle 
        /// DCompositionCreateSurfaceHandle(GENERIC_ALL, nullptr, &amp;m_swapChainHandle); 
        /// dxgiFactory.As(&amp;dxgiFactoryMedia); 
        /// dxgiFactoryMedia-&gt;CreateSwapChainForCompositionSurfaceHandle(  m_d3dDevice.Get(),  m_swapChainHandle,  &amp;swapChainDesc,  nullptr,  &amp;m_swapChain 
        /// );  // Set swap chain to display in a SwapChainPanel 
        /// ComPtr&lt;<see cref = "SharpDX.DXGI.ISwapChainPanelNative2"/>&gt; panelNative; 
        /// reinterpret_cast&lt;<see cref = "SharpDX.IUnknown"/>*&gt;(captureStreamDisplayPanel)-&gt;QueryInterface(IID_PPV_ARGS(&amp;panelNative))); 
        /// panelNative-&gt;SetSwapChainHandle(m_swapChainHandle);  </pre>
        /// </remarks>
        /// <doc-id>dn858173</doc-id>
        /// <unmanaged>HRESULT ISwapChainPanelNative2::SetSwapChainHandle([In] void* swapChainHandle)</unmanaged>
        /// <unmanaged-short>ISwapChainPanelNative2::SetSwapChainHandle</unmanaged-short>
        internal unsafe void SetSwapChainHandle(System.IntPtr swapChainHandle)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)swapChainHandle, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("e9550983-360b-4f53-b391-afd695078691")]
    public partial class IVirtualSurfaceImageSourceNative : SharpDX.DXGI.ISurfaceImageSourceNative
    {
        public IVirtualSurfaceImageSourceNative(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator IVirtualSurfaceImageSourceNative(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new IVirtualSurfaceImageSourceNative(nativePtr);
        /// <summary>
        /// <p>Gets the boundaries of the visible region of the shared surface.</p>
        /// </summary>
        /// <doc-id>hh848331</doc-id>
        /// <unmanaged>GetVisibleBounds</unmanaged>
        /// <unmanaged-short>GetVisibleBounds</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawRectangle VisibleBounds
        {
            get
            {
                GetVisibleBounds(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Invalidates a specific region of the shared surface for drawing.</p>
        /// </summary>
        /// <param name = "updateRect"><dd> <p>The region of the surface to invalidate.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh848332</doc-id>
        /// <unmanaged>HRESULT IVirtualSurfaceImageSourceNative::Invalidate([In] RECT updateRect)</unmanaged>
        /// <unmanaged-short>IVirtualSurfaceImageSourceNative::Invalidate</unmanaged-short>
        public unsafe void Invalidate(SharpDX.Mathematics.Interop.RawRectangle updateRect)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint0(this._nativePointer, updateRect, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the total number of regions of the surface that must be updated.</p>
        /// </summary>
        /// <returns><dd> <p>Receives the number of regions to update.</p> </dd></returns>
        /// <doc-id>hh848329</doc-id>
        /// <unmanaged>HRESULT IVirtualSurfaceImageSourceNative::GetUpdateRectCount([Out] DWORD* count)</unmanaged>
        /// <unmanaged-short>IVirtualSurfaceImageSourceNative::GetUpdateRectCount</unmanaged-short>
        internal unsafe System.Int32 GetUpdateRectCount()
        {
            System.Int32 count;
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &count, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
            return count;
        }

        /// <summary>
        /// <p>Gets the set of regions that must be updated on the shared surface.</p>
        /// </summary>
        /// <param name = "updates"><dd> <p>The number of regions that must be updated. You obtain this by calling <strong>GetUpdateRectCount</strong>.</p> </dd></param>
        /// <param name = "count"><dd> <p>Receives a list of regions that must be updated.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh848330</doc-id>
        /// <unmanaged>HRESULT IVirtualSurfaceImageSourceNative::GetUpdateRects([Out, Buffer] RECT* updates,[In] DWORD count)</unmanaged>
        /// <unmanaged-short>IVirtualSurfaceImageSourceNative::GetUpdateRects</unmanaged-short>
        internal unsafe void GetUpdateRects(SharpDX.Mathematics.Interop.RawRectangle[] updates, System.Int32 count)
        {
            SharpDX.Result __result__;
            fixed (void *updates_ = updates)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, updates_, count, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the boundaries of the visible region of the shared surface.</p>
        /// </summary>
        /// <param name = "bounds"><dd> <p>Receives a rectangle that specifies the visible region of the shared surface.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh848331</doc-id>
        /// <unmanaged>HRESULT IVirtualSurfaceImageSourceNative::GetVisibleBounds([Out] RECT* bounds)</unmanaged>
        /// <unmanaged-short>IVirtualSurfaceImageSourceNative::GetVisibleBounds</unmanaged-short>
        internal unsafe void GetVisibleBounds(out SharpDX.Mathematics.Interop.RawRectangle bounds)
        {
            bounds = default (SharpDX.Mathematics.Interop.RawRectangle);
            SharpDX.Result __result__;
            fixed (void *bounds_ = &bounds)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, bounds_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Registers for the callback that will perform the drawing when an update to the shared surface is requested.</p>
        /// </summary>
        /// <param name = "callback"><dd> <p>Pointer to an implementation of <strong><see cref = "SharpDX.DXGI.IVirtualSurfaceUpdatesCallbackNative"/></strong>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh848334</doc-id>
        /// <unmanaged>HRESULT IVirtualSurfaceImageSourceNative::RegisterForUpdatesNeeded([In, Optional] IVirtualSurfaceUpdatesCallbackNative* callback)</unmanaged>
        /// <unmanaged-short>IVirtualSurfaceImageSourceNative::RegisterForUpdatesNeeded</unmanaged-short>
        internal unsafe void RegisterForUpdatesNeeded(SharpDX.DXGI.IVirtualSurfaceUpdatesCallbackNative callback)
        {
            System.IntPtr callback_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            callback_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.IVirtualSurfaceUpdatesCallbackNative>(callback);
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)callback_, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Resizes the surface.</p>
        /// </summary>
        /// <param name = "newWidth"><dd> <p>The updated width of the surface.</p> </dd></param>
        /// <param name = "newHeight"><dd> <p>The updated height of the surface.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh848335</doc-id>
        /// <unmanaged>HRESULT IVirtualSurfaceImageSourceNative::Resize([In] int newWidth,[In] int newHeight)</unmanaged>
        /// <unmanaged-short>IVirtualSurfaceImageSourceNative::Resize</unmanaged-short>
        public unsafe void Resize(System.Int32 newWidth, System.Int32 newHeight)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, newWidth, newHeight, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("dbf2e947-8e6c-4254-9eee-7738f71386c9")]
    internal partial interface IVirtualSurfaceUpdatesCallbackNative : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("dbf2e947-8e6c-4254-9eee-7738f71386c9")]
    internal partial class IVirtualSurfaceUpdatesCallbackNativeNative : SharpDX.ComObject, SharpDX.DXGI.IVirtualSurfaceUpdatesCallbackNative
    {
        public IVirtualSurfaceUpdatesCallbackNativeNative(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator IVirtualSurfaceUpdatesCallbackNativeNative(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new IVirtualSurfaceUpdatesCallbackNativeNative(nativePtr);
        /// <summary>
        /// <p>Performs the drawing behaviors when an update to <strong>VirtualSurfaceImageSource</strong> is requested.</p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This method is implemented by the developer.</p>
        /// </remarks>
        /// <doc-id>hh848337</doc-id>
        /// <unmanaged>HRESULT IVirtualSurfaceUpdatesCallbackNative::UpdatesNeeded()</unmanaged>
        /// <unmanaged-short>IVirtualSurfaceUpdatesCallbackNative::UpdatesNeeded</unmanaged-short>
        internal unsafe void UpdatesNeeded_()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("9d8e1289-d7b3-465f-8126-250e349af85d")]
    public partial class KeyedMutex : SharpDX.DXGI.DeviceChild
    {
        public KeyedMutex(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator KeyedMutex(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new KeyedMutex(nativePtr);
        /// <summary>
        /// <p>Using a key, acquires exclusive rendering access to a shared resource.</p>
        /// </summary>
        /// <param name = "key"><dd>  <p>A value that indicates which device to give access to. This method will succeed when the device that currently owns the surface calls  the <strong>IDXGIKeyedMutex::ReleaseSync</strong> method using the same value. This value can be any UINT64 value.</p> </dd></param>
        /// <param name = "dwMilliseconds"><dd>  <p>The time-out interval, in milliseconds. This method will return if the interval elapses, and the keyed mutex has not been released  using the specified <em>Key</em>.  If this value is set to zero, the <strong>AcquireSync</strong> method will test to see if the keyed mutex has been released and returns immediately.  If this value is set to INFINITE, the time-out interval will never elapse.</p> </dd></param>
        /// <returns><p>Return <see cref = "SharpDX.Result.Ok"/> if successful.</p><p>If the owning device attempted to create another keyed mutex on the same shared resource, <strong>AcquireSync</strong> returns E_FAIL.</p><p><strong>AcquireSync</strong> can also return the following <strong><see cref = "System.Int32"/></strong> constants. Therefore, you should explicitly check for these constants. If you only use the <strong>SUCCEEDED</strong> macro on the return value to determine if  <strong>AcquireSync</strong> succeeded, you will not catch these constants.</p><ul> <li>WAIT_ABANDONED - The shared surface and keyed mutex are no longer in a consistent state.  If <strong>AcquireSync</strong> returns this value, you should release and recreate both the keyed mutex and the shared surface.</li> <li>WAIT_TIMEOUT - The time-out interval elapsed before the specified key was released.</li> </ul></returns>
        /// <remarks>
        /// <p>The <strong>AcquireSync</strong> method creates a lock to a surface that is shared between multiple devices, allowing only one device to render to a surface at a time.   This method uses a key to determine which device currently has exclusive access to the surface.</p><p>When a surface is created using the <strong>D3D10_RESOURCE_MISC_SHARED_KEYEDMUTEX</strong> value of the <strong>D3D10_RESOURCE_MISC_FLAG</strong> enumeration,  you must call the <strong>AcquireSync</strong> method before rendering to the surface.  You must call the <strong>ReleaseSync</strong> method when you are done  rendering to a surface.</p><p>To acquire a reference to the keyed mutex object of a shared resource, call the <strong>QueryInterface</strong> method of the resource and pass in  the <strong>UUID</strong> of the <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> interface.  For more information about acquiring this reference, see the following code example.</p><p>The <strong>AcquireSync</strong> method uses the key as follows, depending on the state of the surface:</p><ul> <li>On initial creation, the surface is unowned and any device can call the <strong>AcquireSync</strong> method to gain access.  For an unowned device, only a key of 0 will succeed. Calling the <strong>AcquireSync</strong> method for any other key will stall the  calling CPU thread.</li> <li>If the surface is owned by a device when you call the <strong>AcquireSync</strong> method, the CPU thread that called  the <strong>AcquireSync</strong> method will stall until the owning device calls the <strong>ReleaseSync</strong> method  using the same Key.</li> <li>If the surface is unowned when you call the <strong>AcquireSync</strong> method (for example, the last owning device has already called  the <strong>ReleaseSync</strong> method), the <strong>AcquireSync</strong> method will succeed if you specify the same key  that was specified when the <strong>ReleaseSync</strong> method was last called. Calling the <strong>AcquireSync</strong> method using  any other key will cause a stall.</li> <li>When the owning device calls the <strong>ReleaseSync</strong> method with a particular key, and more than one device is waiting after  calling the  <strong>AcquireSync</strong> method using the same key, any one of the waiting devices could be woken up first.  The order in which devices are woken up is undefined.</li> <li>A keyed mutex does not support recursive calls to the <strong>AcquireSync</strong> method.</li> </ul>
        /// </remarks>
        /// <doc-id>ff471339</doc-id>
        /// <unmanaged>HRESULT IDXGIKeyedMutex::AcquireSync([In] unsigned longlong Key,[In] DWORD dwMilliseconds)</unmanaged>
        /// <unmanaged-short>IDXGIKeyedMutex::AcquireSync</unmanaged-short>
        public unsafe SharpDX.Result Acquire(System.Int64 key, System.Int32 dwMilliseconds)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, key, dwMilliseconds, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
            return __result__;
        }

        /// <summary>
        /// <p>Using a key, releases exclusive rendering access to a shared resource.</p>
        /// </summary>
        /// <param name = "key"><dd>  <p>A value that indicates which device to give access to. This method succeeds when the device that currently owns the surface calls the <strong>ReleaseSync</strong> method using the same value. This value can be any UINT64 value.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful.</p><p>If the device attempted to release a keyed mutex that is not valid or owned by the device, <strong>ReleaseSync</strong> returns E_FAIL.</p></returns>
        /// <remarks>
        /// <p>The <strong>ReleaseSync</strong> method releases a lock to a surface that is shared between multiple devices.  This method uses a key to determine which device currently has exclusive access to the surface.</p><p>When a surface is created using the <strong>D3D10_RESOURCE_MISC_SHARED_KEYEDMUTEX</strong> value of the <strong>D3D10_RESOURCE_MISC_FLAG</strong> enumeration,  you must call the <strong>IDXGIKeyedMutex::AcquireSync</strong> method before rendering to the surface.  You must call the <strong>ReleaseSync</strong> method when you are done  rendering to a surface.</p><p>After you call the <strong>ReleaseSync</strong> method, the shared resource is unset from the rendering pipeline. </p><p>To acquire a reference to the keyed mutex object of a shared resource, call the <strong>QueryInterface</strong> method of the resource and pass in  the <strong>UUID</strong> of the <strong><see cref = "SharpDX.DXGI.KeyedMutex"/></strong> interface.  For more information about acquiring this reference, see the following code example.</p>
        /// </remarks>
        /// <doc-id>ff471340</doc-id>
        /// <unmanaged>HRESULT IDXGIKeyedMutex::ReleaseSync([In] unsigned longlong Key)</unmanaged>
        /// <unmanaged-short>IDXGIKeyedMutex::ReleaseSync</unmanaged-short>
        public unsafe void Release(System.Int64 key)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, key, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("ae02eedb-c735-4690-8d52-5a8dc20213aa")]
    public partial class Output : SharpDX.DXGI.DXGIObject
    {
        public Output(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Output(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Output(nativePtr);
        /// <summary>
        /// <p>Get a description of the output.</p>
        /// </summary>
        /// <remarks>
        /// <p> On a high DPI desktop, <strong>GetDesc</strong> returns the visualized screen size unless the app is marked high DPI aware. For info about writing DPI-aware Win32 apps, see High DPI.</p>
        /// </remarks>
        /// <doc-id>bb174548</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.DXGI.OutputDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets a description of the gamma-control capabilities.</p>
        /// </summary>
        /// <remarks>
        /// <p> </p><strong>Note</strong>??Calling this method is only supported while in full-screen mode.?<p>For info about using gamma correction, see Using gamma correction. </p>
        /// </remarks>
        /// <doc-id>bb174553</doc-id>
        /// <unmanaged>GetGammaControlCapabilities</unmanaged>
        /// <unmanaged-short>GetGammaControlCapabilities</unmanaged-short>
        public SharpDX.DXGI.GammaControlCapabilities GammaControlCapabilities
        {
            get
            {
                GetGammaControlCapabilities(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets or sets the gamma control settings.</p>
        /// </summary>
        /// <remarks>
        /// <p> </p><strong>Note</strong>??Calling this method is only supported while in full-screen mode.?<p>For info about using gamma correction, see Using gamma correction. </p>
        /// </remarks>
        /// <doc-id>bb174552</doc-id>
        /// <unmanaged>GetGammaControl / SetGammaControl</unmanaged>
        /// <unmanaged-short>GetGammaControl</unmanaged-short>
        public SharpDX.DXGI.GammaControl GammaControl
        {
            get
            {
                GetGammaControl(out var __output__);
                return __output__;
            }

            set => SetGammaControl(ref value);
        }

        /// <summary>
        /// <p>Gets statistics about recently rendered frames.</p>
        /// </summary>
        /// <remarks>
        /// <p>This API is similar to <strong>IDXGISwapChain::GetFrameStatistics</strong>.</p><p> </p><strong>Note</strong>??Calling this method is only supported while in full-screen mode.?
        /// </remarks>
        /// <doc-id>bb174551</doc-id>
        /// <unmanaged>GetFrameStatistics</unmanaged>
        /// <unmanaged-short>GetFrameStatistics</unmanaged-short>
        public SharpDX.DXGI.FrameStatistics FrameStatistics
        {
            get
            {
                GetFrameStatistics(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Get a description of the output.</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p>A reference to the output description (see <strong><see cref = "SharpDX.DXGI.OutputDescription"/></strong>).</p> </dd></param>
        /// <returns><p>Returns a code that indicates success or failure. <see cref = "SharpDX.Result.Ok"/> if successful, <see cref = "InvalidCall"/> if <em>pDesc</em> is passed in as <strong><c>null</c></strong>.</p></returns>
        /// <remarks>
        /// <p> On a high DPI desktop, <strong>GetDesc</strong> returns the visualized screen size unless the app is marked high DPI aware. For info about writing DPI-aware Win32 apps, see High DPI.</p>
        /// </remarks>
        /// <doc-id>bb174548</doc-id>
        /// <unmanaged>HRESULT IDXGIOutput::GetDesc([Out] DXGI_OUTPUT_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>IDXGIOutput::GetDesc</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.DXGI.OutputDescription descRef)
        {
            SharpDX.DXGI.OutputDescription.__Native descRef_ = default (SharpDX.DXGI.OutputDescription.__Native);
            descRef = default (SharpDX.DXGI.OutputDescription);
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &descRef_, (*(void ***)this._nativePointer)[7]);
            descRef.__MarshalFrom(ref descRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>[Starting with Direct3D 11.1, we recommend not to use <strong>GetDisplayModeList</strong> anymore to retrieve the matching display mode. Instead, use <strong>IDXGIOutput1::GetDisplayModeList1</strong>, which supports stereo display mode.]</p><p>Gets the display modes that match the requested format and other input options.</p>
        /// </summary>
        /// <param name = "enumFormat">No documentation.</param>
        /// <param name = "flags">No documentation.</param>
        /// <param name = "numModesRef">No documentation.</param>
        /// <param name = "descRef">No documentation.</param>
        /// <returns><p>Returns one of the following DXGI_ERROR. It is rare, but possible, that the display modes available can change immediately after calling  this method, in which case <see cref = "MoreData"/> is returned (if there is not enough room for all the display modes).   If <strong>GetDisplayModeList</strong> is called from a Remote Desktop Services session (formerly Terminal Services session), <see cref = "NotCurrentlyAvailable"/> is returned.</p></returns>
        /// <remarks>
        /// <p>In general, when switching from windowed to full-screen mode, a swap chain automatically chooses a display mode that meets (or exceeds) the resolution, color  depth and refresh rate of the swap chain. To exercise more control over the display mode, use this API to poll the set of display modes that are validated  against monitor capabilities, or all modes that match the desktop (if the desktop settings are not validated against the monitor).</p><p>As shown, this API is designed to be called twice. First to get the number of modes available, and second to return a description of the modes.</p><pre> UINT num = 0;
        /// <see cref = "SharpDX.DXGI.Format"/> format = DXGI_FORMAT_R32G32B32A32_FLOAT;
        /// UINT flags         = DXGI_ENUM_MODES_INTERLACED; pOutput-&gt;GetDisplayModeList( format, flags, &amp;num, 0); ... <see cref = "SharpDX.DXGI.ModeDescription"/> * pDescs = new <see cref = "SharpDX.DXGI.ModeDescription"/>[num];
        /// pOutput-&gt;GetDisplayModeList( format, flags, &amp;num, pDescs); </pre>
        /// </remarks>
        /// <doc-id>bb174549</doc-id>
        /// <unmanaged>HRESULT IDXGIOutput::GetDisplayModeList([In] DXGI_FORMAT EnumFormat,[In] unsigned int Flags,[InOut] unsigned int* pNumModes,[Out, Buffer, Optional] DXGI_MODE_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>IDXGIOutput::GetDisplayModeList</unmanaged-short>
        internal unsafe void GetDisplayModeList(SharpDX.DXGI.Format enumFormat, System.Int32 flags, ref System.Int32 numModesRef, SharpDX.DXGI.ModeDescription[] descRef)
        {
            SharpDX.Result __result__;
            fixed (void *descRef_ = descRef)
                fixed (void *numModesRef_ = &numModesRef)
                    __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)enumFormat), flags, numModesRef_, descRef_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>[Starting with Direct3D 11.1, we recommend not to use <strong>FindClosestMatchingMode</strong> anymore to find the display mode that most closely matches the requested display mode. Instead, use <strong>IDXGIOutput1::FindClosestMatchingMode1</strong>, which supports stereo display mode.]</p><p>Finds the display mode that most closely matches the requested display mode.</p>
        /// </summary>
        /// <param name = "modeToMatchRef">No documentation.</param>
        /// <param name = "closestMatchRef">No documentation.</param>
        /// <param name = "concernedDeviceRef">No documentation.</param>
        /// <returns><p>Returns one of the following DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <p><strong>FindClosestMatchingMode</strong> behaves similarly to the <strong>IDXGIOutput1::FindClosestMatchingMode1</strong> except <strong>FindClosestMatchingMode</strong> considers only the mono display modes. <strong>IDXGIOutput1::FindClosestMatchingMode1</strong> considers only stereo modes if you set the <strong>Stereo</strong> member in the <strong><see cref = "SharpDX.DXGI.ModeDescription1"/></strong> structure that <em>pModeToMatch</em> points to, and considers only mono modes if <strong>Stereo</strong> is not set.</p><p> <strong>IDXGIOutput1::FindClosestMatchingMode1</strong> returns a matched display-mode set with only stereo modes or only mono modes.
        /// <strong>FindClosestMatchingMode</strong> behaves as though you specified the input mode as mono.</p>
        /// </remarks>
        /// <doc-id>bb174547</doc-id>
        /// <unmanaged>HRESULT IDXGIOutput::FindClosestMatchingMode([In] const DXGI_MODE_DESC* pModeToMatch,[Out] DXGI_MODE_DESC* pClosestMatch,[In, Optional] IUnknown* pConcernedDevice)</unmanaged>
        /// <unmanaged-short>IDXGIOutput::FindClosestMatchingMode</unmanaged-short>
        internal unsafe void FindClosestMatchingMode(ref SharpDX.DXGI.ModeDescription modeToMatchRef, out SharpDX.DXGI.ModeDescription closestMatchRef, SharpDX.IUnknown concernedDeviceRef)
        {
            closestMatchRef = default (SharpDX.DXGI.ModeDescription);
            System.IntPtr concernedDeviceRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            concernedDeviceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(concernedDeviceRef);
            fixed (void *closestMatchRef_ = &closestMatchRef)
                fixed (void *modeToMatchRef_ = &modeToMatchRef)
                    __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, modeToMatchRef_, closestMatchRef_, (void *)concernedDeviceRef_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Halt a thread until the next vertical blank occurs.</p>
        /// </summary>
        /// <returns><p>Returns one of the following DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <p>A vertical blank occurs when the raster moves from the lower right corner to the upper left corner to begin drawing the next frame.</p>
        /// </remarks>
        /// <doc-id>bb174559</doc-id>
        /// <unmanaged>HRESULT IDXGIOutput::WaitForVBlank()</unmanaged>
        /// <unmanaged-short>IDXGIOutput::WaitForVBlank</unmanaged-short>
        public unsafe void WaitForVerticalBlank()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Takes ownership of an output.</p>
        /// </summary>
        /// <param name = "deviceRef"><dd>  <p>A reference to the <strong><see cref = "SharpDX.IUnknown"/></strong> interface of a device (such as an <strong>ID3D10Device</strong>).</p> </dd></param>
        /// <param name = "exclusive"><dd>  <p>Set to <strong>TRUE</strong> to enable other threads or applications to take ownership of the device; otherwise, set to <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd></param>
        /// <returns><p>Returns one of the DXGI_ERROR values.</p></returns>
        /// <remarks>
        /// <p>When you are finished with the output, call <strong>IDXGIOutput::ReleaseOwnership</strong>.</p><p><strong>TakeOwnership</strong> should not be called directly by applications, since results will be unpredictable. It is called implicitly by the DXGI swap chain object during full-screen transitions, and should not be used as a substitute for swap-chain methods.</p>
        /// </remarks>
        /// <doc-id>bb174558</doc-id>
        /// <unmanaged>HRESULT IDXGIOutput::TakeOwnership([In] IUnknown* pDevice,[In] BOOL Exclusive)</unmanaged>
        /// <unmanaged-short>IDXGIOutput::TakeOwnership</unmanaged-short>
        public unsafe void TakeOwnership(SharpDX.IUnknown deviceRef, SharpDX.Mathematics.Interop.RawBool exclusive)
        {
            System.IntPtr deviceRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            deviceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(deviceRef);
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)deviceRef_, exclusive, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Releases ownership of the output.</p>
        /// </summary>
        /// <remarks>
        /// <p>If you are not using a swap chain, get access to an output by calling <strong>IDXGIOutput::TakeOwnership</strong> and release it when you are finished by calling <strong>IDXGIOutput::ReleaseOwnership</strong>. An application that uses a swap chain will typically not call either of these methods.</p>
        /// </remarks>
        /// <doc-id>bb174554</doc-id>
        /// <unmanaged>void IDXGIOutput::ReleaseOwnership()</unmanaged>
        /// <unmanaged-short>IDXGIOutput::ReleaseOwnership</unmanaged-short>
        public unsafe void ReleaseOwnership()
        {
            SharpDX.DXGI.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[12]);
        }

        /// <summary>
        /// <p>Gets a description of the gamma-control capabilities.</p>
        /// </summary>
        /// <param name = "gammaCapsRef"><dd>  <p>A reference to a  description of the gamma-control capabilities (see <strong><see cref = "SharpDX.DXGI.GammaControlCapabilities"/></strong>).</p> </dd></param>
        /// <returns><p>Returns one of the DXGI_ERROR values.</p></returns>
        /// <remarks>
        /// <p> </p><strong>Note</strong>??Calling this method is only supported while in full-screen mode.?<p>For info about using gamma correction, see Using gamma correction. </p>
        /// </remarks>
        /// <doc-id>bb174553</doc-id>
        /// <unmanaged>HRESULT IDXGIOutput::GetGammaControlCapabilities([Out] DXGI_GAMMA_CONTROL_CAPABILITIES* pGammaCaps)</unmanaged>
        /// <unmanaged-short>IDXGIOutput::GetGammaControlCapabilities</unmanaged-short>
        internal unsafe void GetGammaControlCapabilities(out SharpDX.DXGI.GammaControlCapabilities gammaCapsRef)
        {
            SharpDX.DXGI.GammaControlCapabilities.__Native gammaCapsRef_ = default (SharpDX.DXGI.GammaControlCapabilities.__Native);
            gammaCapsRef = default (SharpDX.DXGI.GammaControlCapabilities);
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &gammaCapsRef_, (*(void ***)this._nativePointer)[13]);
            gammaCapsRef.__MarshalFrom(ref gammaCapsRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the gamma controls.</p>
        /// </summary>
        /// <param name = "arrayRef"><dd>  <p>A reference to a <strong><see cref = "SharpDX.DXGI.GammaControl"/></strong> structure that describes the gamma curve to set.</p> </dd></param>
        /// <returns><p>Returns one of the DXGI_ERROR values.</p></returns>
        /// <remarks>
        /// <p> </p><strong>Note</strong>??Calling this method is only supported while in full-screen mode.?<p>For info about using gamma correction, see Using gamma correction. </p>
        /// </remarks>
        /// <doc-id>bb174557</doc-id>
        /// <unmanaged>HRESULT IDXGIOutput::SetGammaControl([In] const DXGI_GAMMA_CONTROL* pArray)</unmanaged>
        /// <unmanaged-short>IDXGIOutput::SetGammaControl</unmanaged-short>
        internal unsafe void SetGammaControl(ref SharpDX.DXGI.GammaControl arrayRef)
        {
            SharpDX.DXGI.GammaControl.__Native arrayRef_ = default (SharpDX.DXGI.GammaControl.__Native);
            SharpDX.Result __result__;
            arrayRef.__MarshalTo(ref arrayRef_);
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &arrayRef_, (*(void ***)this._nativePointer)[14]);
            arrayRef.__MarshalFree(ref arrayRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the gamma control settings.</p>
        /// </summary>
        /// <param name = "arrayRef"><dd>  <p>An array of gamma control settings (see <strong><see cref = "SharpDX.DXGI.GammaControl"/></strong>).</p> </dd></param>
        /// <returns><p>Returns one of the DXGI_ERROR values.</p></returns>
        /// <remarks>
        /// <p> </p><strong>Note</strong>??Calling this method is only supported while in full-screen mode.?<p>For info about using gamma correction, see Using gamma correction. </p>
        /// </remarks>
        /// <doc-id>bb174552</doc-id>
        /// <unmanaged>HRESULT IDXGIOutput::GetGammaControl([Out] DXGI_GAMMA_CONTROL* pArray)</unmanaged>
        /// <unmanaged-short>IDXGIOutput::GetGammaControl</unmanaged-short>
        internal unsafe void GetGammaControl(out SharpDX.DXGI.GammaControl arrayRef)
        {
            SharpDX.DXGI.GammaControl.__Native arrayRef_ = default (SharpDX.DXGI.GammaControl.__Native);
            arrayRef = default (SharpDX.DXGI.GammaControl);
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &arrayRef_, (*(void ***)this._nativePointer)[15]);
            arrayRef.__MarshalFrom(ref arrayRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the display mode.</p>
        /// </summary>
        /// <param name = "scanoutSurfaceRef"><dd>  <p>A reference to a surface (see <strong><see cref = "SharpDX.DXGI.Surface"/></strong>) used for rendering an image to the screen. The surface must have been created as a back buffer (DXGI_USAGE_BACKBUFFER).</p> </dd></param>
        /// <returns><p>Returns one of the DXGI_ERROR values.</p></returns>
        /// <remarks>
        /// <p><strong>IDXGIOutput::SetDisplaySurface</strong> should not be called directly by applications, since results will be unpredictable. It is called implicitly by the DXGI swap chain object during full-screen transitions, and should not be used as a substitute for swap-chain methods.</p><p>This method should only be called between <strong>IDXGIOutput::TakeOwnership</strong> and <strong>IDXGIOutput::ReleaseOwnership</strong> calls.</p>
        /// </remarks>
        /// <doc-id>bb174556</doc-id>
        /// <unmanaged>HRESULT IDXGIOutput::SetDisplaySurface([In] IDXGISurface* pScanoutSurface)</unmanaged>
        /// <unmanaged-short>IDXGIOutput::SetDisplaySurface</unmanaged-short>
        public unsafe void SetDisplaySurface(SharpDX.DXGI.Surface scanoutSurfaceRef)
        {
            System.IntPtr scanoutSurfaceRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            scanoutSurfaceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Surface>(scanoutSurfaceRef);
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)scanoutSurfaceRef_, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>[Starting with Direct3D 11.1, we recommend not to use <strong>GetDisplaySurfaceData</strong> anymore to retrieve the current display surface. Instead, use <strong>IDXGIOutput1::GetDisplaySurfaceData1</strong>, which supports stereo display mode.]</p><p>Gets a copy of the current display surface.</p>
        /// </summary>
        /// <param name = "destinationRef">No documentation.</param>
        /// <returns><p>Returns one of the DXGI_ERROR values.</p></returns>
        /// <remarks>
        /// <p><strong>IDXGIOutput::GetDisplaySurfaceData</strong> can only be called when an output is in full-screen mode. If the method succeeds, DXGI fills the destination surface.</p><p>Use <strong>IDXGIOutput::GetDesc</strong> to determine the size (width and height) of the output when you want to allocate space for the destination surface. This is true regardless of target monitor rotation. A destination surface created by a graphics component (such as Direct3D 10) must be created with CPU-write permission (see D3D10_CPU_ACCESS_WRITE). Other surfaces should be created with CPU read-write permission (see D3D10_CPU_ACCESS_READ_WRITE). This method will modify the surface data to fit the destination surface (stretch, shrink, convert format, rotate). The stretch and shrink is performed with point-sampling.</p>
        /// </remarks>
        /// <doc-id>bb174550</doc-id>
        /// <unmanaged>HRESULT IDXGIOutput::GetDisplaySurfaceData([In] IDXGISurface* pDestination)</unmanaged>
        /// <unmanaged-short>IDXGIOutput::GetDisplaySurfaceData</unmanaged-short>
        public unsafe void CopyDisplaySurfaceTo(SharpDX.DXGI.Surface destinationRef)
        {
            System.IntPtr destinationRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            destinationRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Surface>(destinationRef);
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)destinationRef_, (*(void ***)this._nativePointer)[17]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets statistics about recently rendered frames.</p>
        /// </summary>
        /// <param name = "statsRef"><dd>  <p>A reference to frame statistics (see <strong><see cref = "SharpDX.DXGI.FrameStatistics"/></strong>).</p> </dd></param>
        /// <returns><p>If this function succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it might return <see cref = "InvalidCall"/>.</p></returns>
        /// <remarks>
        /// <p>This API is similar to <strong>IDXGISwapChain::GetFrameStatistics</strong>.</p><p> </p><strong>Note</strong>??Calling this method is only supported while in full-screen mode.?
        /// </remarks>
        /// <doc-id>bb174551</doc-id>
        /// <unmanaged>HRESULT IDXGIOutput::GetFrameStatistics([Out] DXGI_FRAME_STATISTICS* pStats)</unmanaged>
        /// <unmanaged-short>IDXGIOutput::GetFrameStatistics</unmanaged-short>
        internal unsafe void GetFrameStatistics(out SharpDX.DXGI.FrameStatistics statsRef)
        {
            statsRef = default (SharpDX.DXGI.FrameStatistics);
            SharpDX.Result __result__;
            fixed (void *statsRef_ = &statsRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, statsRef_, (*(void ***)this._nativePointer)[18]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("00cddea8-939b-4b83-a340-a685226666cc")]
    public partial class Output1 : SharpDX.DXGI.Output
    {
        public Output1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Output1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Output1(nativePtr);
        /// <summary>
        /// <p>[Starting with Direct3D 11.1, we recommend not to use <strong>GetDisplayModeList</strong> anymore to retrieve the matching display mode. Instead, use <strong>IDXGIOutput1::GetDisplayModeList1</strong>, which supports stereo display mode.]</p><p>Gets the display modes that match the requested format and other input options.</p>
        /// </summary>
        /// <param name = "enumFormat">No documentation.</param>
        /// <param name = "flags">No documentation.</param>
        /// <param name = "numModesRef">No documentation.</param>
        /// <param name = "descRef">No documentation.</param>
        /// <returns><p>Returns one of the following DXGI_ERROR. It is rare, but possible, that the display modes available can change immediately after calling  this method, in which case <see cref = "MoreData"/> is returned (if there is not enough room for all the display modes).   If <strong>GetDisplayModeList</strong> is called from a Remote Desktop Services session (formerly Terminal Services session), <see cref = "NotCurrentlyAvailable"/> is returned.</p></returns>
        /// <remarks>
        /// <p>In general, when switching from windowed to full-screen mode, a swap chain automatically chooses a display mode that meets (or exceeds) the resolution, color  depth and refresh rate of the swap chain. To exercise more control over the display mode, use this API to poll the set of display modes that are validated  against monitor capabilities, or all modes that match the desktop (if the desktop settings are not validated against the monitor).</p><p>As shown, this API is designed to be called twice. First to get the number of modes available, and second to return a description of the modes.</p><pre> UINT num = 0;
        /// <see cref = "SharpDX.DXGI.Format"/> format = DXGI_FORMAT_R32G32B32A32_FLOAT;
        /// UINT flags         = DXGI_ENUM_MODES_INTERLACED; pOutput-&gt;GetDisplayModeList( format, flags, &amp;num, 0); ... <see cref = "SharpDX.DXGI.ModeDescription"/> * pDescs = new <see cref = "SharpDX.DXGI.ModeDescription"/>[num];
        /// pOutput-&gt;GetDisplayModeList( format, flags, &amp;num, pDescs); </pre>
        /// </remarks>
        /// <doc-id>bb174549</doc-id>
        /// <unmanaged>HRESULT IDXGIOutput1::GetDisplayModeList1([In] DXGI_FORMAT EnumFormat,[In] unsigned int Flags,[InOut] unsigned int* pNumModes,[Out, Buffer, Optional] DXGI_MODE_DESC1* pDesc)</unmanaged>
        /// <unmanaged-short>IDXGIOutput1::GetDisplayModeList1</unmanaged-short>
        internal unsafe void GetDisplayModeList1(SharpDX.DXGI.Format enumFormat, System.Int32 flags, ref System.Int32 numModesRef, SharpDX.DXGI.ModeDescription1[] descRef)
        {
            SharpDX.Result __result__;
            fixed (void *descRef_ = descRef)
                fixed (void *numModesRef_ = &numModesRef)
                    __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)enumFormat), flags, numModesRef_, descRef_, (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Finds the display mode that most closely matches the requested display mode.</p>
        /// </summary>
        /// <param name = "modeToMatchRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.DXGI.ModeDescription1"/></strong> structure that describes the display mode to match. Members of <strong><see cref = "SharpDX.DXGI.ModeDescription1"/></strong> can be unspecified, which indicates no preference for  that member.  A value of 0 for <strong>Width</strong> or <strong>Height</strong> indicates that the value is unspecified.  If either <strong>Width</strong> or  <strong>Height</strong> is 0, both must be 0.  A numerator and denominator of 0 in <strong>RefreshRate</strong> indicate it is unspecified. Other members  of <strong><see cref = "SharpDX.DXGI.ModeDescription1"/></strong> have enumeration values that indicate that the member is unspecified.  If <em>pConcernedDevice</em> is <strong><c>null</c></strong>, the <strong>Format</strong> member of <strong><see cref = "SharpDX.DXGI.ModeDescription1"/></strong> cannot be <strong>DXGI_FORMAT_UNKNOWN</strong>.</p> </dd></param>
        /// <param name = "closestMatchRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.DXGI.ModeDescription1"/></strong> structure that receives a description of the display mode that most closely matches the display mode described at <em>pModeToMatch</em>.</p> </dd></param>
        /// <param name = "concernedDeviceRef"><dd> <p>A reference to the Direct3D device interface. If this parameter is <strong><c>null</c></strong>, <strong>FindClosestMatchingMode1</strong> returns only modes whose format matches that of <em>pModeToMatch</em>; otherwise, <strong>FindClosestMatchingMode1</strong> returns only those formats that are supported for scan-out by the device. For info about the formats that are supported for scan-out by the device at each feature level:</p> <ul> <li> DXGI Format  Support for Direct3D Feature Level 12.1 Hardware </li> <li> DXGI Format  Support for Direct3D Feature Level 12.0 Hardware </li> <li> DXGI Format  Support for Direct3D Feature Level 11.1 Hardware </li> <li> DXGI Format  Support for Direct3D Feature Level 11.0 Hardware </li> <li> Hardware Support for Direct3D 10Level9 Formats </li> <li> Hardware Support for Direct3D 10.1 Formats </li> <li> Hardware Support for Direct3D 10 Formats </li> </ul> </dd></param>
        /// <returns><p>Returns one of the error codes described in the DXGI_ERROR topic.</p></returns>
        /// <remarks>
        /// <p>Direct3D devices require UNORM formats.</p><p><strong>FindClosestMatchingMode1</strong> finds the closest matching available display mode to the mode that you specify in <em>pModeToMatch</em>.</p><p>If you set the <strong>Stereo</strong> member in the <strong><see cref = "SharpDX.DXGI.ModeDescription1"/></strong> structure to which <em>pModeToMatch</em> points to specify a stereo mode as input, <strong>FindClosestMatchingMode1</strong> considers only stereo modes. <strong>FindClosestMatchingMode1</strong> considers only mono modes if <strong>Stereo</strong> is not set.</p><p><strong>FindClosestMatchingMode1</strong> resolves similarly ranked members of display modes (that is, all specified, or all unspecified, and so on) in the following order:</p><ol> <li><strong>ScanlineOrdering</strong></li> <li><strong>Scaling</strong></li> <li><strong>Format</strong></li> <li><strong>Resolution</strong></li> <li><strong>RefreshRate</strong></li> </ol><p>When <strong>FindClosestMatchingMode1</strong> determines the closest value for a particular member, it uses previously matched members to filter the display mode list choices, and  ignores other members. For example, when <strong>FindClosestMatchingMode1</strong> matches <strong>Resolution</strong>, it already filtered the display mode list by a certain <strong>ScanlineOrdering</strong>,  <strong>Scaling</strong>, and <strong>Format</strong>, while it ignores <strong>RefreshRate</strong>. This ordering doesn't define the absolute ordering for every usage scenario of <strong>FindClosestMatchingMode1</strong>, because  the application can choose some values initially, which effectively changes the order of resolving members.</p><p><strong>FindClosestMatchingMode1</strong> matches members of the display mode one at a time, generally in a specified order.</p><p>If a member is unspecified, <strong>FindClosestMatchingMode1</strong> gravitates toward the values for the desktop related to this output.  If this output is not part of the desktop, <strong>FindClosestMatchingMode1</strong> uses the default desktop output to find values. If an application uses a fully unspecified  display mode, <strong>FindClosestMatchingMode1</strong> typically returns a display mode that matches the desktop settings for this output.   Because unspecified members are lower priority than specified members, <strong>FindClosestMatchingMode1</strong> resolves unspecified members later than specified members.</p>
        /// </remarks>
        /// <doc-id>hh404603</doc-id>
        /// <unmanaged>HRESULT IDXGIOutput1::FindClosestMatchingMode1([In] const DXGI_MODE_DESC1* pModeToMatch,[Out] DXGI_MODE_DESC1* pClosestMatch,[In, Optional] IUnknown* pConcernedDevice)</unmanaged>
        /// <unmanaged-short>IDXGIOutput1::FindClosestMatchingMode1</unmanaged-short>
        public unsafe void FindClosestMatchingMode1(ref SharpDX.DXGI.ModeDescription1 modeToMatchRef, out SharpDX.DXGI.ModeDescription1 closestMatchRef, SharpDX.IUnknown concernedDeviceRef)
        {
            closestMatchRef = default (SharpDX.DXGI.ModeDescription1);
            System.IntPtr concernedDeviceRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            concernedDeviceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(concernedDeviceRef);
            fixed (void *closestMatchRef_ = &closestMatchRef)
                fixed (void *modeToMatchRef_ = &modeToMatchRef)
                    __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, modeToMatchRef_, closestMatchRef_, (void *)concernedDeviceRef_, (*(void ***)this._nativePointer)[20]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Copies the display surface (front buffer) to a user-provided resource.</p>
        /// </summary>
        /// <param name = "destinationRef"><dd> <p>A reference to a resource interface that represents the resource to which <strong>GetDisplaySurfaceData1</strong> copies the display surface.</p> </dd></param>
        /// <returns><p>Returns one of the error codes described in the DXGI_ERROR topic.</p></returns>
        /// <remarks>
        /// <p><strong>GetDisplaySurfaceData1</strong> is similar to <strong>IDXGIOutput::GetDisplaySurfaceData</strong> except <strong>GetDisplaySurfaceData1</strong> takes an <strong><see cref = "SharpDX.DXGI.Resource"/></strong> and <strong>IDXGIOutput::GetDisplaySurfaceData</strong> takes an <strong><see cref = "SharpDX.DXGI.Surface"/></strong>.</p><p><strong>GetDisplaySurfaceData1</strong> returns an error if the input resource is not a 2D texture (represented by the <strong><see cref = "SharpDX.Direct3D11.Texture2D"/></strong> interface) with an array size (<strong>ArraySize</strong> member of the <strong><see cref = "SharpDX.Direct3D11.Texture2DDescription"/></strong> structure) that is equal to the swap chain buffers.</p><p>The original <strong>IDXGIOutput::GetDisplaySurfaceData</strong> and the updated <strong>GetDisplaySurfaceData1</strong> behave exactly the same. <strong>GetDisplaySurfaceData1</strong> was required because textures with an array size equal to 2 (<strong>ArraySize</strong> = 2) do not implement <strong><see cref = "SharpDX.DXGI.Surface"/></strong>.</p><p> You can call <strong>GetDisplaySurfaceData1</strong> only when an output is in full-screen mode. If <strong>GetDisplaySurfaceData1</strong> succeeds, it fills the destination resource.</p><p>Use <strong>IDXGIOutput::GetDesc</strong> to determine the size (width and height) of the output when you want to allocate space for the destination resource. This is true regardless of target monitor rotation. A destination resource created by a graphics component (such as Direct3D 11) must be created with CPU write permission (see <strong>D3D11_CPU_ACCESS_WRITE</strong>). Other surfaces can be created with CPU read-write permission (<strong>D3D11_CPU_ACCESS_READ</strong> | <strong>D3D11_CPU_ACCESS_WRITE</strong>). <strong>GetDisplaySurfaceData1</strong> modifies the surface data to fit the destination resource (stretch, shrink, convert format, rotate). <strong>GetDisplaySurfaceData1</strong> performs the stretch and shrink with point sampling. </p>
        /// </remarks>
        /// <doc-id>hh404609</doc-id>
        /// <unmanaged>HRESULT IDXGIOutput1::GetDisplaySurfaceData1([In] IDXGIResource* pDestination)</unmanaged>
        /// <unmanaged-short>IDXGIOutput1::GetDisplaySurfaceData1</unmanaged-short>
        public unsafe void GetDisplaySurfaceData1(SharpDX.DXGI.Resource destinationRef)
        {
            System.IntPtr destinationRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            destinationRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Resource>(destinationRef);
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)destinationRef_, (*(void ***)this._nativePointer)[21]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a desktop duplication interface from the <strong><see cref = "SharpDX.DXGI.Output1"/></strong> interface that represents an adapter output.</p>
        /// </summary>
        /// <param name = "deviceRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <remarks>
        /// <p>If an application wants to duplicate the entire desktop, it must create a desktop duplication interface on each active output on the desktop. This interface does not provide an explicit way to synchronize the timing of each output image. Instead, the application must use the time stamp of each output, and then determine how to combine the images.</p><p>For <strong>DuplicateOutput</strong> to succeed, you must create <em>pDevice</em> from <strong><see cref = "SharpDX.DXGI.Factory1"/></strong> or a later version of a DXGI factory interface that inherits from <strong><see cref = "SharpDX.DXGI.Factory1"/></strong>.</p><p>If the current mode is a stereo mode, the desktop duplication interface provides the image for the left stereo image only.</p><p>By default, only four processes can use a <strong><see cref = "SharpDX.DXGI.OutputDuplication"/></strong> interface at the same time within a single session. A process can have only one desktop duplication interface on a single desktop output; however, that process can have a desktop duplication interface for each output that is part of the desktop. </p><p>For improved performance, consider using <strong>DuplicateOutput1</strong>.</p>
        /// </remarks>
        /// <doc-id>hh404600</doc-id>
        /// <unmanaged>HRESULT IDXGIOutput1::DuplicateOutput([In] IUnknown* pDevice,[Out] IDXGIOutputDuplication** ppOutputDuplication)</unmanaged>
        /// <unmanaged-short>IDXGIOutput1::DuplicateOutput</unmanaged-short>
        public unsafe SharpDX.DXGI.OutputDuplication DuplicateOutput(SharpDX.IUnknown deviceRef)
        {
            System.IntPtr deviceRef_ = System.IntPtr.Zero;
            SharpDX.DXGI.OutputDuplication outputDuplicationOut;
            System.IntPtr outputDuplicationOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            deviceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(deviceRef);
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)deviceRef_, &outputDuplicationOut_, (*(void ***)this._nativePointer)[22]);
            if (outputDuplicationOut_ != System.IntPtr.Zero)
                outputDuplicationOut = new SharpDX.DXGI.OutputDuplication(outputDuplicationOut_);
            else
                outputDuplicationOut = null;
            __result__.CheckError();
            return outputDuplicationOut;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("595e39d1-2724-4663-99b1-da969de28364")]
    public partial class Output2 : SharpDX.DXGI.Output1
    {
        public Output2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Output2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Output2(nativePtr);
        /// <summary>
        /// <p>Queries an adapter output for multiplane overlay support. If this API returns ?TRUE?, multiple swap chain composition takes place in a performant manner using overlay hardware. If this API returns false, apps should avoid using foreground swap chains (that is, avoid using swap chains created with the <strong>DXGI_SWAP_CHAIN_FLAG_FOREGROUND_LAYER</strong> flag).</p>
        /// </summary>
        /// <returns><p>TRUE if the output adapter is the primary adapter and it supports multiplane overlays, otherwise returns <see cref = "SharpDX.Result.False"/>.</p></returns>
        /// <remarks>
        /// <p>See <strong>CreateSwapChainForCoreWindow</strong> for info on creating a foreground swap chain.</p>
        /// </remarks>
        /// <doc-id>dn280411</doc-id>
        /// <unmanaged>BOOL IDXGIOutput2::SupportsOverlays()</unmanaged>
        /// <unmanaged-short>IDXGIOutput2::SupportsOverlays</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawBool SupportsOverlays_()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[23]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("8a6bb301-7e7e-41F4-a8e0-5b32f7f99b18")]
    public partial class Output3 : SharpDX.DXGI.Output2
    {
        public Output3(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Output3(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Output3(nativePtr);
        /// <summary>
        /// <p>Checks for overlay support.</p>
        /// </summary>
        /// <param name = "enumFormat"><dd>  <p>A <strong><see cref = "SharpDX.DXGI.Format"/></strong>-typed value for the color format.</p> </dd></param>
        /// <param name = "concernedDeviceRef"><dd>  <p>A reference to the Direct3D device interface. <strong>CheckOverlaySupport</strong> returns only support info about this scan-out device. </p> </dd></param>
        /// <returns><dd>  <p>A reference to a variable that receives a combination of <strong><see cref = "SharpDX.DXGI.OverlaySupportFlags"/></strong>-typed values that are combined by using a bitwise OR operation. The resulting value specifies options for overlay support. </p> </dd></returns>
        /// <doc-id>dn903670</doc-id>
        /// <unmanaged>HRESULT IDXGIOutput3::CheckOverlaySupport([In] DXGI_FORMAT EnumFormat,[In] IUnknown* pConcernedDevice,[Out] unsigned int* pFlags)</unmanaged>
        /// <unmanaged-short>IDXGIOutput3::CheckOverlaySupport</unmanaged-short>
        public unsafe SharpDX.DXGI.OverlaySupportFlags CheckOverlaySupport(SharpDX.DXGI.Format enumFormat, SharpDX.IUnknown concernedDeviceRef)
        {
            System.IntPtr concernedDeviceRef_ = System.IntPtr.Zero;
            SharpDX.DXGI.OverlaySupportFlags flagsRef;
            SharpDX.Result __result__;
            concernedDeviceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(concernedDeviceRef);
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)enumFormat), (void *)concernedDeviceRef_, &flagsRef, (*(void ***)this._nativePointer)[24]);
            __result__.CheckError();
            return flagsRef;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("dc7dca35-2196-414d-9F53-617884032a60")]
    public partial class Output4 : SharpDX.DXGI.Output3
    {
        public Output4(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Output4(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Output4(nativePtr);
        /// <summary>
        /// <p>Checks for overlay color space support.</p>
        /// </summary>
        /// <param name = "format"><dd>  <p>A <strong><see cref = "SharpDX.DXGI.Format"/></strong>-typed value for the color format.</p> </dd></param>
        /// <param name = "colorSpace"><dd>  <p>A <strong><see cref = "SharpDX.DXGI.ColorSpaceType"/></strong>-typed value that specifies color space type to check overlay support for.</p> </dd></param>
        /// <param name = "concernedDeviceRef"><dd>  <p>A reference to the Direct3D device interface. <strong>CheckOverlayColorSpaceSupport</strong> returns only support info about this scan-out device. </p> </dd></param>
        /// <returns><dd>  <p>A reference to a variable that receives a combination of <strong><see cref = "SharpDX.DXGI.OverlayColorSpaceSupportFlags"/></strong>-typed values that are combined by using a bitwise OR operation. The resulting value specifies options for overlay color space support. </p> </dd></returns>
        /// <doc-id>dn903672</doc-id>
        /// <unmanaged>HRESULT IDXGIOutput4::CheckOverlayColorSpaceSupport([In] DXGI_FORMAT Format,[In] DXGI_COLOR_SPACE_TYPE ColorSpace,[In] IUnknown* pConcernedDevice,[Out] unsigned int* pFlags)</unmanaged>
        /// <unmanaged-short>IDXGIOutput4::CheckOverlayColorSpaceSupport</unmanaged-short>
        public unsafe SharpDX.DXGI.OverlayColorSpaceSupportFlags CheckOverlayColorSpaceSupport(SharpDX.DXGI.Format format, SharpDX.DXGI.ColorSpaceType colorSpace, SharpDX.IUnknown concernedDeviceRef)
        {
            System.IntPtr concernedDeviceRef_ = System.IntPtr.Zero;
            SharpDX.DXGI.OverlayColorSpaceSupportFlags flagsRef;
            SharpDX.Result __result__;
            concernedDeviceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(concernedDeviceRef);
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)format), unchecked ((System.Int32)colorSpace), (void *)concernedDeviceRef_, &flagsRef, (*(void ***)this._nativePointer)[25]);
            __result__.CheckError();
            return flagsRef;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("80A07424-AB52-42EB-833C-0C42FD282D98")]
    public partial class Output5 : SharpDX.DXGI.Output4
    {
        public Output5(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Output5(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Output5(nativePtr);
        /// <summary>
        /// <p>Allows specifying a list of supported formats for fullscreen surfaces that can be returned by the <strong><see cref = "SharpDX.DXGI.OutputDuplication"/></strong> object.</p>
        /// </summary>
        /// <param name = "deviceRef">No documentation.</param>
        /// <param name = "flags">No documentation.</param>
        /// <param name = "supportedFormatsCount">No documentation.</param>
        /// <param name = "supportedFormatsRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <remarks>
        /// <p>This method allows directly receiving the original back buffer format used by a running fullscreen application. For comparison, using the original <strong>DuplicateOutput</strong> function always converts the fullscreen surface to a 32-bit BGRA format. In cases where the current fullscreen application is using a different buffer format, a conversion to 32-bit BGRA incurs a performance penalty. Besides the performance benefit of being able to skip format conversion, using <strong>DuplicateOutput1</strong> also allows receiving the full gamut of colors in cases where a high-color format (such as R10G10B10A2) is being presented. </p><p>The <em>pSupportedFormats</em> array should only contain display scan-out formats. See Format Support for Direct3D Feature Level 11.0 Hardware for  required scan-out formats at each feature level. If the current fullscreen buffer format is not contained in the <em>pSupportedFormats</em> array, DXGI will pick one of the supplied formats and convert the fullscreen buffer to that format before returning from <strong>IDXGIOutputDuplication::AcquireNextFrame</strong>. The list of supported formats should always contain DXGI_FORMAT_B8G8R8A8_UNORM, as this is the most common format for the desktop.
        /// </p>
        /// </remarks>
        /// <doc-id>mt679496</doc-id>
        /// <unmanaged>HRESULT IDXGIOutput5::DuplicateOutput1([In] IUnknown* pDevice,[In] unsigned int Flags,[In] unsigned int SupportedFormatsCount,[In, Buffer] const DXGI_FORMAT* pSupportedFormats,[Out] IDXGIOutputDuplication** ppOutputDuplication)</unmanaged>
        /// <unmanaged-short>IDXGIOutput5::DuplicateOutput1</unmanaged-short>
        public unsafe SharpDX.DXGI.OutputDuplication DuplicateOutput1(SharpDX.IUnknown deviceRef, System.Int32 flags, System.Int32 supportedFormatsCount, SharpDX.DXGI.Format[] supportedFormatsRef)
        {
            System.IntPtr deviceRef_ = System.IntPtr.Zero;
            SharpDX.DXGI.OutputDuplication outputDuplicationOut;
            System.IntPtr outputDuplicationOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            deviceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(deviceRef);
            fixed (void *supportedFormatsRef_ = supportedFormatsRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (void *)deviceRef_, flags, supportedFormatsCount, supportedFormatsRef_, &outputDuplicationOut_, (*(void ***)this._nativePointer)[26]);
            if (outputDuplicationOut_ != System.IntPtr.Zero)
                outputDuplicationOut = new SharpDX.DXGI.OutputDuplication(outputDuplicationOut_);
            else
                outputDuplicationOut = null;
            __result__.CheckError();
            return outputDuplicationOut;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("068346e8-aaec-4b84-add7-137f513f77a1")]
    public partial class Output6 : SharpDX.DXGI.Output5
    {
        public Output6(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Output6(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Output6(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetDesc1</unmanaged>
        /// <unmanaged-short>GetDesc1</unmanaged-short>
        public SharpDX.DXGI.OutputDescription1 Description1
        {
            get
            {
                GetDescription1(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "descRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT IDXGIOutput6::GetDesc1([Out] DXGI_OUTPUT_DESC1* pDesc)</unmanaged>
        /// <unmanaged-short>IDXGIOutput6::GetDesc1</unmanaged-short>
        internal unsafe void GetDescription1(out SharpDX.DXGI.OutputDescription1 descRef)
        {
            SharpDX.DXGI.OutputDescription1.__Native descRef_ = default (SharpDX.DXGI.OutputDescription1.__Native);
            descRef = default (SharpDX.DXGI.OutputDescription1);
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &descRef_, (*(void ***)this._nativePointer)[27]);
            descRef.__MarshalFrom(ref descRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "flagsRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT IDXGIOutput6::CheckHardwareCompositionSupport([Out] unsigned int* pFlags)</unmanaged>
        /// <unmanaged-short>IDXGIOutput6::CheckHardwareCompositionSupport</unmanaged-short>
        public unsafe void CheckHardwareCompositionSupport(out System.Int32 flagsRef)
        {
            SharpDX.Result __result__;
            fixed (void *flagsRef_ = &flagsRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, flagsRef_, (*(void ***)this._nativePointer)[28]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("191cfac3-a341-470d-b26e-a864f428319c")]
    public partial class OutputDuplication : SharpDX.DXGI.DXGIObject
    {
        public OutputDuplication(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator OutputDuplication(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new OutputDuplication(nativePtr);
        /// <summary>
        /// <p>Retrieves a description of a duplicated output. This description specifies the dimensions of the surface that contains the desktop image.</p>
        /// </summary>
        /// <remarks>
        /// <p>After an application creates an <strong><see cref = "SharpDX.DXGI.OutputDuplication"/></strong> interface, it calls <strong>GetDesc</strong> to retrieve the dimensions of the surface that contains the desktop image. The format of the desktop image is always <strong>DXGI_FORMAT_B8G8R8A8_UNORM</strong>.</p>
        /// </remarks>
        /// <doc-id>hh404618</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.DXGI.OutputDuplicateDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves a description of a duplicated output. This description specifies the dimensions of the surface that contains the desktop image.</p>
        /// </summary>
        /// <param name = "descRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.DXGI.OutputDuplicateDescription"/></strong> structure that describes the duplicated output. This parameter must not be <strong><c>null</c></strong>.</p> </dd></param>
        /// <remarks>
        /// <p>After an application creates an <strong><see cref = "SharpDX.DXGI.OutputDuplication"/></strong> interface, it calls <strong>GetDesc</strong> to retrieve the dimensions of the surface that contains the desktop image. The format of the desktop image is always <strong>DXGI_FORMAT_B8G8R8A8_UNORM</strong>.</p>
        /// </remarks>
        /// <doc-id>hh404618</doc-id>
        /// <unmanaged>void IDXGIOutputDuplication::GetDesc([Out] DXGI_OUTDUPL_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>IDXGIOutputDuplication::GetDesc</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.DXGI.OutputDuplicateDescription descRef)
        {
            descRef = default (SharpDX.DXGI.OutputDuplicateDescription);
            fixed (void *descRef_ = &descRef)
                SharpDX.DXGI.LocalInterop.CalliStdCallvoid(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[7]);
        }

        /// <summary>
        /// <p>Indicates that the application is ready to process the next desktop image.</p>
        /// </summary>
        /// <param name = "timeoutInMilliseconds"><dd> <p>The time-out interval, in milliseconds. This interval specifies the amount of time that this method waits for a new frame before it returns to the caller.  This method returns if the interval elapses, and a new desktop image is not available.</p> <p>For more information about the time-out interval, see Remarks.</p> </dd></param>
        /// <param name = "frameInfoRef"><dd> <p>A reference to a memory location that receives the <strong><see cref = "SharpDX.DXGI.OutputDuplicateFrameInformation"/></strong> structure that describes timing and presentation statistics for a frame.</p> </dd></param>
        /// <param name = "desktopResourceOut"><dd> <p>A reference to a variable that receives the <strong><see cref = "SharpDX.DXGI.Resource"/></strong> interface of the surface that contains the desktop bitmap.</p> </dd></param>
        /// <returns><p><strong>AcquireNextFrame</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if it successfully received the next desktop image.</li> <li><see cref = "AccessLost"/> if the desktop duplication interface is invalid. The desktop duplication interface typically becomes invalid when a different type of image is displayed on the desktop.  Examples of this situation are: <ul> <li>Desktop switch</li> <li>Mode change</li> <li>Switch from DWM on, DWM off, or other full-screen application</li> </ul>In this situation, the application must release the <strong><see cref = "SharpDX.DXGI.OutputDuplication"/></strong> interface and create a new <strong><see cref = "SharpDX.DXGI.OutputDuplication"/></strong> for the new content.</li> <li><see cref = "WaitTimeout"/> if the time-out interval elapsed before the next desktop frame was available.</li> <li><see cref = "InvalidCall"/> if the application called <strong>AcquireNextFrame</strong> without releasing the previous frame.</li> <li>E_INVALIDARG if one of the parameters to <strong>AcquireNextFrame</strong> is incorrect; for example, if <em>pFrameInfo</em> is <c>null</c>.</li> <li>Possibly other error codes that are described in the DXGI_ERROR topic.</li> </ul></returns>
        /// <remarks>
        /// <p>When <strong>AcquireNextFrame</strong> returns successfully, the calling application can access the desktop image that <strong>AcquireNextFrame</strong> returns in the variable at <em>ppDesktopResource</em>.
        /// If the caller specifies a zero time-out interval in the <em>TimeoutInMilliseconds</em> parameter, <strong>AcquireNextFrame</strong> verifies whether there is a new desktop image available, returns immediately, and indicates its outcome with the return value.  If the caller specifies an <strong>INFINITE</strong> time-out interval in the <em>TimeoutInMilliseconds</em> parameter, the time-out interval never elapses.</p><strong>Note</strong>??You cannot cancel the wait that you specified in the <em>TimeoutInMilliseconds</em> parameter. Therefore, if you must periodically check for other conditions (for example, a terminate signal), you should specify a non-<strong>INFINITE</strong> time-out interval. After the time-out interval elapses, you can check for these other conditions and then call <strong>AcquireNextFrame</strong> again to wait for the next frame.?<p><strong>AcquireNextFrame</strong> acquires a new desktop frame when the operating system either updates the desktop bitmap image or changes the shape or position of a hardware reference.  The new frame that <strong>AcquireNextFrame</strong> acquires might have only the desktop image updated, only the reference shape or position updated, or both.</p>
        /// </remarks>
        /// <doc-id>hh404615</doc-id>
        /// <unmanaged>HRESULT IDXGIOutputDuplication::AcquireNextFrame([In] unsigned int TimeoutInMilliseconds,[Out] DXGI_OUTDUPL_FRAME_INFO* pFrameInfo,[Out] IDXGIResource** ppDesktopResource)</unmanaged>
        /// <unmanaged-short>IDXGIOutputDuplication::AcquireNextFrame</unmanaged-short>
        public unsafe SharpDX.Result TryAcquireNextFrame(System.Int32 timeoutInMilliseconds, out SharpDX.DXGI.OutputDuplicateFrameInformation frameInfoRef, out SharpDX.DXGI.Resource desktopResourceOut)
        {
            frameInfoRef = default (SharpDX.DXGI.OutputDuplicateFrameInformation);
            System.IntPtr desktopResourceOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *frameInfoRef_ = &frameInfoRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, timeoutInMilliseconds, frameInfoRef_, &desktopResourceOut_, (*(void ***)this._nativePointer)[8]);
            if (desktopResourceOut_ != System.IntPtr.Zero)
                desktopResourceOut = new SharpDX.DXGI.Resource(desktopResourceOut_);
            else
                desktopResourceOut = null;
            return __result__;
        }

        /// <summary>
        /// <p>Gets information about dirty rectangles for the current desktop frame.</p>
        /// </summary>
        /// <param name = "dirtyRectsBufferSize"><dd> <p>The size in bytes of the buffer that the caller passed to the  <em>pDirtyRectsBuffer</em> parameter.</p> </dd></param>
        /// <param name = "dirtyRectsBufferRef"><dd> <p>A reference to an array of <strong><see cref = "SharpDX.Mathematics.Interop.RawRectangle"/></strong> structures  that identifies the dirty rectangle regions for the desktop frame.</p> </dd></param>
        /// <param name = "dirtyRectsBufferSizeRequiredRef"><dd> <p>Pointer to a variable that receives the number of bytes that  <strong>GetFrameDirtyRects</strong> needs to store information about dirty regions in the buffer at  <em>pDirtyRectsBuffer</em>.</p> <p>For more information about returning the required buffer size, see Remarks.</p> </dd></param>
        /// <returns><p><strong>GetFrameDirtyRects</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if it successfully retrieved information about dirty rectangles.</li> <li><see cref = "AccessLost"/> if the desktop duplication interface is invalid. The desktop duplication  interface typically becomes invalid when a different type of image is displayed on the desktop. Examples of  this situation are:  <ul> <li>Desktop switch</li> <li>Mode change</li> <li>Switch from DWM on, DWM off, or other full-screen application</li> </ul> In this situation, the application must release the  <strong><see cref = "SharpDX.DXGI.OutputDuplication"/></strong> interface and  create a new  <strong><see cref = "SharpDX.DXGI.OutputDuplication"/></strong> for the new  content.</li> <li><see cref = "MoreData"/> if the buffer that the calling application provided was not big enough.</li> <li><see cref = "InvalidCall"/> if the application called  <strong>GetFrameDirtyRects</strong> without owning the desktop image.</li> <li>E_INVALIDARG if one of the parameters to  <strong>GetFrameDirtyRects</strong> is incorrect; for example, if <em>pDirtyRectsBuffer</em> is <c>null</c>.</li> <li>Possibly other error codes that are described in the DXGI_ERROR topic.</li> </ul></returns>
        /// <remarks>
        /// <p><strong>GetFrameDirtyRects</strong> stores a size value in the variable at <em>pDirtyRectsBufferSizeRequired</em>. This  value specifies the number of bytes that <strong>GetFrameDirtyRects</strong> needs to store information about dirty regions. You can use this value  in the following situations to determine the amount of memory to allocate for future buffers that you pass to <em>pDirtyRectsBuffer</em>:</p><ul> <li><strong>GetFrameDirtyRects</strong> fails with <see cref = "MoreData"/> because the buffer is not big enough.</li> <li><strong>GetFrameDirtyRects</strong> supplies a buffer that is bigger than necessary. The size value returned at  <em>pDirtyRectsBufferSizeRequired</em> informs the caller how much buffer space was actually  used compared to how much buffer space the caller allocated and specified in the  <em>DirtyRectsBufferSize</em> parameter.</li> </ul><p>The caller can also use the value returned at <em>pDirtyRectsBufferSizeRequired</em> to  determine the number of <strong><see cref = "SharpDX.Mathematics.Interop.RawRectangle"/></strong>s returned in the <em>pDirtyRectsBuffer</em> array.</p><p>The buffer contains the list of dirty <strong><see cref = "SharpDX.Mathematics.Interop.RawRectangle"/></strong>s for the current frame.</p><strong>Note</strong>??To produce a visually accurate copy of the desktop, an application must first process all move <strong><see cref = "SharpDX.Mathematics.Interop.RawRectangle"/></strong>s before  it processes dirty <strong><see cref = "SharpDX.Mathematics.Interop.RawRectangle"/></strong>s.?
        /// </remarks>
        /// <doc-id>hh404619</doc-id>
        /// <unmanaged>HRESULT IDXGIOutputDuplication::GetFrameDirtyRects([In] unsigned int DirtyRectsBufferSize,[Out, Buffer] RECT* pDirtyRectsBuffer,[Out] unsigned int* pDirtyRectsBufferSizeRequired)</unmanaged>
        /// <unmanaged-short>IDXGIOutputDuplication::GetFrameDirtyRects</unmanaged-short>
        public unsafe void GetFrameDirtyRects(System.Int32 dirtyRectsBufferSize, SharpDX.Mathematics.Interop.RawRectangle[] dirtyRectsBufferRef, out System.Int32 dirtyRectsBufferSizeRequiredRef)
        {
            SharpDX.Result __result__;
            fixed (void *dirtyRectsBufferSizeRequiredRef_ = &dirtyRectsBufferSizeRequiredRef)
                fixed (void *dirtyRectsBufferRef_ = dirtyRectsBufferRef)
                    __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, dirtyRectsBufferSize, dirtyRectsBufferRef_, dirtyRectsBufferSizeRequiredRef_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets information about the moved rectangles for the current desktop frame.</p>
        /// </summary>
        /// <param name = "moveRectsBufferSize"><dd> <p>The size in bytes of the buffer that the caller passed to the  <em>pMoveRectBuffer</em> parameter.</p> </dd></param>
        /// <param name = "moveRectBufferRef"><dd> <p>A reference to an array of  <strong><see cref = "SharpDX.DXGI.OutputDuplicateMoveRectangle"/></strong> structures  that identifies the moved rectangle regions for the desktop frame.</p> </dd></param>
        /// <param name = "moveRectsBufferSizeRequiredRef"><dd> <p>Pointer to a variable that receives the number of bytes that  <strong>GetFrameMoveRects</strong> needs to store information about moved regions in the buffer at <em>pMoveRectBuffer</em>.</p> <p>For more information about returning the required buffer size, see Remarks.</p> </dd></param>
        /// <returns><p><strong>GetFrameMoveRects</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if it successfully retrieved information about moved rectangles.</li> <li><see cref = "AccessLost"/> if the desktop duplication interface is invalid. The desktop duplication interface typically becomes invalid when a different type of image is displayed on the desktop.  Examples of this situation are:  <ul> <li>Desktop switch</li> <li>Mode change</li> <li>Switch from DWM on, DWM off, or other full-screen application</li> </ul> In this situation, the application must release the  <strong><see cref = "SharpDX.DXGI.OutputDuplication"/></strong> interface and  create a new <strong><see cref = "SharpDX.DXGI.OutputDuplication"/></strong> for the new content.</li> <li><see cref = "MoreData"/> if the buffer that the calling application provided  is not big enough.</li> <li><see cref = "InvalidCall"/> if the application called  <strong>GetFrameMoveRects</strong> without owning the desktop image.</li> <li>E_INVALIDARG if one of the parameters to  <strong>GetFrameMoveRects</strong> is incorrect; for example, if  <em>pMoveRectBuffer</em> is <c>null</c>.</li> <li>Possibly other error codes that are described in the  DXGI_ERROR topic.</li> </ul></returns>
        /// <remarks>
        /// <p><strong>GetFrameMoveRects</strong> stores a size value in the variable at <em>pMoveRectsBufferSizeRequired</em>. This  value specifies the number of bytes that <strong>GetFrameMoveRects</strong> needs to store information about moved regions. You can use  this value in the following situations to determine the amount of memory to allocate for future buffers that you pass to <em>pMoveRectBuffer</em>:</p><ul> <li><strong>GetFrameMoveRects</strong> fails with <see cref = "MoreData"/> because the buffer is not big enough.</li> <li><strong>GetFrameMoveRects</strong> supplies a buffer that is bigger than necessary. The size value returned at <em>pMoveRectsBufferSizeRequired</em> informs the caller how much buffer space was actually used compared to how much buffer space the caller allocated and specified in the  <em>MoveRectsBufferSize</em> parameter.</li> </ul><p>The caller can also use the value returned at <em>pMoveRectsBufferSizeRequired</em> to determine the number of <strong><see cref = "SharpDX.DXGI.OutputDuplicateMoveRectangle"/></strong> structures returned.</p><p>The buffer contains the list of move RECTs for the current frame.</p><strong>Note</strong>??To produce a visually accurate copy of the desktop, an application must first process all move RECTs before it processes dirty RECTs.?
        /// </remarks>
        /// <doc-id>hh404620</doc-id>
        /// <unmanaged>HRESULT IDXGIOutputDuplication::GetFrameMoveRects([In] unsigned int MoveRectsBufferSize,[Out, Buffer] DXGI_OUTDUPL_MOVE_RECT* pMoveRectBuffer,[Out] unsigned int* pMoveRectsBufferSizeRequired)</unmanaged>
        /// <unmanaged-short>IDXGIOutputDuplication::GetFrameMoveRects</unmanaged-short>
        public unsafe void GetFrameMoveRects(System.Int32 moveRectsBufferSize, SharpDX.DXGI.OutputDuplicateMoveRectangle[] moveRectBufferRef, out System.Int32 moveRectsBufferSizeRequiredRef)
        {
            SharpDX.Result __result__;
            fixed (void *moveRectsBufferSizeRequiredRef_ = &moveRectsBufferSizeRequiredRef)
                fixed (void *moveRectBufferRef_ = moveRectBufferRef)
                    __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, moveRectsBufferSize, moveRectBufferRef_, moveRectsBufferSizeRequiredRef_, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets information about the new reference shape for the current desktop frame.</p>
        /// </summary>
        /// <param name = "pointerShapeBufferSize"><dd> <p>The size in bytes of the buffer that the caller passed to the  <em>pPointerShapeBuffer</em> parameter.</p> </dd></param>
        /// <param name = "pointerShapeBufferRef"><dd> <p>A reference to a buffer to which <strong>GetFramePointerShape</strong> copies and returns pixel data for the new reference shape.</p> </dd></param>
        /// <param name = "pointerShapeBufferSizeRequiredRef"><dd> <p>Pointer to a variable that receives the number of bytes that <strong>GetFramePointerShape</strong> needs to store the new reference shape pixel data in the buffer at <em>pPointerShapeBuffer</em>.</p> <p>For more information about returning the required buffer size, see Remarks.</p> </dd></param>
        /// <param name = "pointerShapeInfoRef"><dd> <p>Pointer to a <strong><see cref = "SharpDX.DXGI.OutputDuplicatePointerShapeInformation"/></strong> structure that receives the reference shape information.</p> </dd></param>
        /// <returns><p><strong>GetFramePointerShape</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if it successfully retrieved information about the new reference shape.</li> <li><see cref = "AccessLost"/> if the desktop duplication interface is invalid. The desktop duplication interface typically becomes invalid when a different type of image is displayed on the desktop.  Examples of this situation are: <ul> <li>Desktop switch</li> <li>Mode change</li> <li>Switch from DWM on, DWM off, or other full-screen application</li> </ul>In this situation, the application must release the <strong><see cref = "SharpDX.DXGI.OutputDuplication"/></strong> interface and create a new <strong><see cref = "SharpDX.DXGI.OutputDuplication"/></strong> for the new content.</li> <li><see cref = "MoreData"/> if the buffer that the calling application provided was not big enough.</li> <li><see cref = "InvalidCall"/> if the application called <strong>GetFramePointerShape</strong> without owning the desktop image.</li> <li>E_INVALIDARG if one of the parameters to <strong>GetFramePointerShape</strong> is incorrect; for example, if <em>pPointerShapeInfo</em> is <c>null</c>.</li> <li>Possibly other error codes that are described in the DXGI_ERROR topic.</li> </ul></returns>
        /// <remarks>
        /// <p><strong>GetFramePointerShape</strong> stores a size value in the variable at <em>pPointerShapeBufferSizeRequired</em>. This  value specifies the number of bytes that <em>pPointerShapeBufferSizeRequired</em> needs to store the new reference shape pixel data. You can use the value in the following situations to determine the amount of memory to allocate for future buffers that you pass to <em>pPointerShapeBuffer</em>:</p><ul> <li><strong>GetFramePointerShape</strong> fails with <see cref = "MoreData"/> because the buffer is not big enough.</li> <li><strong>GetFramePointerShape</strong> supplies a bigger than necessary buffer. The size value returned at <em>pPointerShapeBufferSizeRequired</em> informs the caller how much buffer space was actually used compared to how much buffer space the caller allocated and specified in the  <em>PointerShapeBufferSize</em> parameter.</li> </ul><p>The <em>pPointerShapeInfo</em> parameter describes the new reference shape.</p>
        /// </remarks>
        /// <doc-id>hh404621</doc-id>
        /// <unmanaged>HRESULT IDXGIOutputDuplication::GetFramePointerShape([In] unsigned int PointerShapeBufferSize,[Out, Buffer] void* pPointerShapeBuffer,[Out] unsigned int* pPointerShapeBufferSizeRequired,[Out] DXGI_OUTDUPL_POINTER_SHAPE_INFO* pPointerShapeInfo)</unmanaged>
        /// <unmanaged-short>IDXGIOutputDuplication::GetFramePointerShape</unmanaged-short>
        public unsafe void GetFramePointerShape(System.Int32 pointerShapeBufferSize, System.IntPtr pointerShapeBufferRef, out System.Int32 pointerShapeBufferSizeRequiredRef, out SharpDX.DXGI.OutputDuplicatePointerShapeInformation pointerShapeInfoRef)
        {
            pointerShapeInfoRef = default (SharpDX.DXGI.OutputDuplicatePointerShapeInformation);
            SharpDX.Result __result__;
            fixed (void *pointerShapeInfoRef_ = &pointerShapeInfoRef)
                fixed (void *pointerShapeBufferSizeRequiredRef_ = &pointerShapeBufferSizeRequiredRef)
                    __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, pointerShapeBufferSize, (void *)pointerShapeBufferRef, pointerShapeBufferSizeRequiredRef_, pointerShapeInfoRef_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Provides the CPU with efficient access to a desktop image if that desktop image is already in system memory.</p>
        /// </summary>
        /// <param name = "lockedRectRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.DXGI.MappedRectangle"/></strong> structure that receives the surface data that the CPU needs to directly access the surface data. </p> </dd></param>
        /// <returns><p><strong>MapDesktopSurface</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if it successfully retrieved the surface data.</li> <li><see cref = "AccessLost"/> if the desktop duplication interface is invalid. The desktop duplication interface typically becomes invalid when a different type of image is displayed on the desktop.  Examples of this situation are: <ul> <li>Desktop switch</li> <li>Mode change</li> <li>Switch from DWM on, DWM off, or other full-screen application</li> </ul>In this situation, the application must release the <strong><see cref = "SharpDX.DXGI.OutputDuplication"/></strong> interface and create a new <strong><see cref = "SharpDX.DXGI.OutputDuplication"/></strong> for the new content.</li> <li><see cref = "InvalidCall"/> if the application already has an outstanding map on the desktop image.  The application must call <strong>UnMapDesktopSurface</strong> before it calls <strong>MapDesktopSurface</strong> again. <see cref = "InvalidCall"/> is also returned if the application did not own the desktop image when it called <strong>MapDesktopSurface</strong>.</li> <li><see cref = "Unsupported"/> if the desktop image is not in system memory. In this situation, the application must first transfer the image to a staging surface and then lock the image by calling the <strong>IDXGISurface::Map</strong> method.</li> <li>E_INVALIDARG if the <em>pLockedRect</em> parameter is incorrect; for example, if <em>pLockedRect</em> is <strong><c>null</c></strong>.</li> <li>Possibly other error codes that are described in the DXGI_ERROR topic.</li> </ul></returns>
        /// <remarks>
        /// <p>You can successfully call <strong>MapDesktopSurface</strong> if the  <strong>DesktopImageInSystemMemory</strong> member of the <strong><see cref = "SharpDX.DXGI.OutputDuplicateDescription"/></strong> structure is set to <strong>TRUE</strong>. If <strong>DesktopImageInSystemMemory</strong> is <strong><see cref = "SharpDX.Result.False"/></strong>, <strong>MapDesktopSurface</strong> returns <see cref = "Unsupported"/>. Call <strong>IDXGIOutputDuplication::GetDesc</strong> to retrieve the <strong><see cref = "SharpDX.DXGI.OutputDuplicateDescription"/></strong> structure.</p>
        /// </remarks>
        /// <doc-id>hh404622</doc-id>
        /// <unmanaged>HRESULT IDXGIOutputDuplication::MapDesktopSurface([Out] DXGI_MAPPED_RECT* pLockedRect)</unmanaged>
        /// <unmanaged-short>IDXGIOutputDuplication::MapDesktopSurface</unmanaged-short>
        internal unsafe void MapDesktopSurface(out SharpDX.DXGI.MappedRectangle lockedRectRef)
        {
            lockedRectRef = default (SharpDX.DXGI.MappedRectangle);
            SharpDX.Result __result__;
            fixed (void *lockedRectRef_ = &lockedRectRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, lockedRectRef_, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Invalidates the reference to the desktop image that was retrieved by using <strong>IDXGIOutputDuplication::MapDesktopSurface</strong>.</p>
        /// </summary>
        /// <returns><p><strong>UnMapDesktopSurface</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if it successfully completed.</li> <li><see cref = "InvalidCall"/> if the application did not map the desktop surface by calling <strong>IDXGIOutputDuplication::MapDesktopSurface</strong>.</li> <li>Possibly other error codes that are described in the DXGI_ERROR topic.</li> </ul></returns>
        /// <doc-id>hh404624</doc-id>
        /// <unmanaged>HRESULT IDXGIOutputDuplication::UnMapDesktopSurface()</unmanaged>
        /// <unmanaged-short>IDXGIOutputDuplication::UnMapDesktopSurface</unmanaged-short>
        public unsafe void UnMapDesktopSurface()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Indicates that the application finished processing the frame.</p>
        /// </summary>
        /// <returns><p><strong>ReleaseFrame</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if it successfully completed.</li> <li><see cref = "InvalidCall"/> if the application already released the frame.</li> <li><see cref = "AccessLost"/> if the desktop duplication interface is invalid. The desktop duplication interface typically becomes invalid when a different type of image is displayed on the desktop.  Examples of this situation are: <ul> <li>Desktop switch</li> <li>Mode change</li> <li>Switch from DWM on, DWM off, or other full-screen application</li> </ul>In this situation, the application must release the <strong><see cref = "SharpDX.DXGI.OutputDuplication"/></strong> interface and create a new <strong><see cref = "SharpDX.DXGI.OutputDuplication"/></strong> for the new content.</li> <li>Possibly other error codes that are described in the DXGI_ERROR topic.</li> </ul></returns>
        /// <remarks>
        /// <p>The application must release the frame before it acquires the next frame.  After the frame is released, the surface that contains the desktop bitmap becomes invalid; you will not be able to use the surface in a DirectX graphics operation.</p><p>For performance reasons, we recommend that you release the frame just before you call the <strong>IDXGIOutputDuplication::AcquireNextFrame</strong> method to acquire the next frame.  When the client does not own the frame, the operating system copies all desktop updates to the surface. This can result in wasted GPU cycles if the operating system updates the same region for each frame that occurs.  When the client acquires the frame, the client is aware of only the final update to this region; therefore, any overlapping updates during previous frames are wasted. When the client acquires a frame, the client owns the surface; therefore, the operating system can track only the updated regions and cannot copy desktop updates to the surface. Because of this behavior, we recommend that you minimize the time between the call to release the current frame and the call to acquire the next frame.</p>
        /// </remarks>
        /// <doc-id>hh404623</doc-id>
        /// <unmanaged>HRESULT IDXGIOutputDuplication::ReleaseFrame()</unmanaged>
        /// <unmanaged-short>IDXGIOutputDuplication::ReleaseFrame</unmanaged-short>
        public unsafe void ReleaseFrame()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("035f3ab4-482e-4e50-b41f-8a7f8bd8960b")]
    public partial class Resource : SharpDX.DXGI.DeviceChild
    {
        public Resource(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Resource(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Resource(nativePtr);
        /// <summary>
        /// <p>[Starting with Direct3D 11.1, we recommend not to use <strong>GetSharedHandle</strong> anymore to retrieve the handle to a shared resource. Instead, use <strong>IDXGIResource1::CreateSharedHandle</strong> to get a handle for sharing. To use <strong>IDXGIResource1::CreateSharedHandle</strong>, you  must create the resource as shared and specify that it uses NT handles (that is, you set the <strong>D3D11_RESOURCE_MISC_SHARED_NTHANDLE</strong> flag). We also recommend that you create shared resources that use NT handles so you can use <strong>CloseHandle</strong>, <strong>DuplicateHandle</strong>, and so on on those shared resources.]</p><p>Gets the handle to a shared resource.</p>
        /// </summary>
        /// <remarks>
        /// <p><strong>GetSharedHandle</strong> returns a handle for the resource that you created as shared (that is, you set the <strong>D3D11_RESOURCE_MISC_SHARED</strong> with or without the <strong>D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX</strong> flag). You can pass this handle to the <strong>ID3D11Device::OpenSharedResource</strong> method to give another device access to the shared resource. You can also marshal this handle to another process to share a resource with a device in another process. However, this handle is not an NT handle. Therefore, don't use the handle with <strong>CloseHandle</strong>, <strong>DuplicateHandle</strong>, and so on.</p><p>The creator of a shared resource must not destroy the resource until all intended entities have opened the resource. The validity of the handle is tied to the lifetime of the underlying video memory. If no resource objects exist on any devices that refer to this resource, the handle is no longer valid. To extend the lifetime of the handle and video memory, you must open the shared resource on a device.</p><p><strong>GetSharedHandle</strong> can also return handles for resources that were passed into <strong>ID3D11Device::OpenSharedResource</strong> to open those resources.</p><p><strong>GetSharedHandle</strong> fails if the resource to which it wants to get a handle is not shared.</p>
        /// </remarks>
        /// <doc-id>bb174562</doc-id>
        /// <unmanaged>GetSharedHandle</unmanaged>
        /// <unmanaged-short>GetSharedHandle</unmanaged-short>
        public System.IntPtr SharedHandle
        {
            get
            {
                GetSharedHandle(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Get or sets the eviction priority.</p>
        /// </summary>
        /// <remarks>
        /// <p>The eviction priority is a memory-management variable that is used by DXGI to determine how to manage overcommitted memory.</p><p>Priority levels other than the defined values are used when appropriate. For example, a resource with a priority level of 0x78000001 indicates that the resource is slightly above normal.</p>
        /// </remarks>
        /// <doc-id>bb174561</doc-id>
        /// <unmanaged>GetEvictionPriority / SetEvictionPriority</unmanaged>
        /// <unmanaged-short>GetEvictionPriority</unmanaged-short>
        public System.Int32 EvictionPriority
        {
            get
            {
                GetEvictionPriority(out var __output__);
                return __output__;
            }

            set => SetEvictionPriority(value);
        }

        /// <summary>
        /// <p>[Starting with Direct3D 11.1, we recommend not to use <strong>GetSharedHandle</strong> anymore to retrieve the handle to a shared resource. Instead, use <strong>IDXGIResource1::CreateSharedHandle</strong> to get a handle for sharing. To use <strong>IDXGIResource1::CreateSharedHandle</strong>, you  must create the resource as shared and specify that it uses NT handles (that is, you set the <strong>D3D11_RESOURCE_MISC_SHARED_NTHANDLE</strong> flag). We also recommend that you create shared resources that use NT handles so you can use <strong>CloseHandle</strong>, <strong>DuplicateHandle</strong>, and so on on those shared resources.]</p><p>Gets the handle to a shared resource.</p>
        /// </summary>
        /// <param name = "sharedHandleRef">No documentation.</param>
        /// <returns><p>Returns one of the DXGI_ERROR values.</p></returns>
        /// <remarks>
        /// <p><strong>GetSharedHandle</strong> returns a handle for the resource that you created as shared (that is, you set the <strong>D3D11_RESOURCE_MISC_SHARED</strong> with or without the <strong>D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX</strong> flag). You can pass this handle to the <strong>ID3D11Device::OpenSharedResource</strong> method to give another device access to the shared resource. You can also marshal this handle to another process to share a resource with a device in another process. However, this handle is not an NT handle. Therefore, don't use the handle with <strong>CloseHandle</strong>, <strong>DuplicateHandle</strong>, and so on.</p><p>The creator of a shared resource must not destroy the resource until all intended entities have opened the resource. The validity of the handle is tied to the lifetime of the underlying video memory. If no resource objects exist on any devices that refer to this resource, the handle is no longer valid. To extend the lifetime of the handle and video memory, you must open the shared resource on a device.</p><p><strong>GetSharedHandle</strong> can also return handles for resources that were passed into <strong>ID3D11Device::OpenSharedResource</strong> to open those resources.</p><p><strong>GetSharedHandle</strong> fails if the resource to which it wants to get a handle is not shared.</p>
        /// </remarks>
        /// <doc-id>bb174562</doc-id>
        /// <unmanaged>HRESULT IDXGIResource::GetSharedHandle([Out] void** pSharedHandle)</unmanaged>
        /// <unmanaged-short>IDXGIResource::GetSharedHandle</unmanaged-short>
        internal unsafe void GetSharedHandle(out System.IntPtr sharedHandleRef)
        {
            SharpDX.Result __result__;
            fixed (void *sharedHandleRef_ = &sharedHandleRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, sharedHandleRef_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Get the expected resource usage.</p>
        /// </summary>
        /// <param name = "usageRef"><dd>  <p>A reference to a usage flag (see DXGI_USAGE). For Direct3D 10, a surface can be used as a shader input or a render-target output.</p> </dd></param>
        /// <returns><p>Returns one of the following DXGI_ERROR.</p></returns>
        /// <doc-id>bb174563</doc-id>
        /// <unmanaged>HRESULT IDXGIResource::GetUsage([In] unsigned int* pUsage)</unmanaged>
        /// <unmanaged-short>IDXGIResource::GetUsage</unmanaged-short>
        public unsafe void GetUsage(System.Int32 usageRef)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &usageRef, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Set the priority for evicting the resource from memory.</p>
        /// </summary>
        /// <param name = "evictionPriority"><dd>  <p>The priority is one of the following values: </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>DXGI_RESOURCE_PRIORITY_MINIMUM (0x28000000)</strong></dt> </dl> </td><td> <p>The resource is unused and can be evicted as soon as another resource requires the memory that the resource occupies.</p> </td></tr> <tr><td><dl> <dt><strong>DXGI_RESOURCE_PRIORITY_LOW (0x50000000)</strong></dt> </dl> </td><td> <p>The eviction priority of the resource is low. The placement of the resource is not critical, and minimal work is performed to find a location for the resource. For example, if a GPU can render with a vertex buffer from either local or non-local memory with little difference in performance, that vertex buffer is low priority. Other more critical resources (for example, a render target or texture) can then occupy the faster memory.</p> </td></tr> <tr><td><dl> <dt><strong>DXGI_RESOURCE_PRIORITY_NORMAL (0x78000000)</strong></dt> </dl> </td><td> <p>The eviction priority of the resource is normal. The placement of the resource is important, but not critical, for performance. The resource is placed in its preferred location instead of a low-priority resource. </p> </td></tr> <tr><td><dl> <dt><strong>DXGI_RESOURCE_PRIORITY_HIGH (0xa0000000)</strong></dt> </dl> </td><td> <p>The eviction priority of the resource is high. The resource is placed in its preferred location instead of a low-priority or normal-priority resource.</p> </td></tr> <tr><td><dl> <dt><strong>DXGI_RESOURCE_PRIORITY_MAXIMUM (0xc8000000)</strong></dt> </dl> </td><td> <p>The resource is evicted from memory only if there is no other way of resolving the memory requirement.</p> </td></tr> </table> <p>?</p> </dd></param>
        /// <returns><p>Returns one of the following DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <p>The eviction priority is a memory-management variable that is used by DXGI for determining how to populate overcommitted memory.</p><p>You can set priority levels other than the defined values when appropriate. For example, you can set a resource with a priority level of 0x78000001 to indicate that the resource is slightly above normal.</p>
        /// </remarks>
        /// <doc-id>bb174564</doc-id>
        /// <unmanaged>HRESULT IDXGIResource::SetEvictionPriority([In] unsigned int EvictionPriority)</unmanaged>
        /// <unmanaged-short>IDXGIResource::SetEvictionPriority</unmanaged-short>
        internal unsafe void SetEvictionPriority(System.Int32 evictionPriority)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, evictionPriority, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Get the eviction priority.</p>
        /// </summary>
        /// <param name = "evictionPriorityRef"><dd>  <p>A reference to the eviction priority, which determines when a resource can be evicted from memory.  </p> <p>The following defined values are possible.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>DXGI_RESOURCE_PRIORITY_MINIMUM (0x28000000)</strong></dt> </dl> </td><td> <p>The resource is unused and can be evicted as soon as another resource requires the memory that the resource occupies.</p> </td></tr> <tr><td><dl> <dt><strong>DXGI_RESOURCE_PRIORITY_LOW (0x50000000)</strong></dt> </dl> </td><td> <p>The eviction priority of the resource is low. The placement of the resource is not critical, and minimal work is performed to find a location for the resource. For example, if a GPU can render with a vertex buffer from either local or non-local memory with little difference in performance, that vertex buffer is low priority. Other more critical resources (for example, a render target or texture) can then occupy the faster memory.</p> </td></tr> <tr><td><dl> <dt><strong>DXGI_RESOURCE_PRIORITY_NORMAL (0x78000000)</strong></dt> </dl> </td><td> <p>The eviction priority of the resource is normal. The placement of the resource is important, but not critical, for performance. The resource is placed in its preferred location instead of a low-priority resource. </p> </td></tr> <tr><td><dl> <dt><strong>DXGI_RESOURCE_PRIORITY_HIGH (0xa0000000)</strong></dt> </dl> </td><td> <p>The eviction priority of the resource is high. The resource is placed in its preferred location instead of a low-priority or normal-priority resource.</p> </td></tr> <tr><td><dl> <dt><strong>DXGI_RESOURCE_PRIORITY_MAXIMUM (0xc8000000)</strong></dt> </dl> </td><td> <p>The resource is evicted from memory only if there is no other way of resolving the memory requirement.</p> </td></tr> </table> <p>?</p> </dd></param>
        /// <returns><p>Returns one of the following DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <p>The eviction priority is a memory-management variable that is used by DXGI to determine how to manage overcommitted memory.</p><p>Priority levels other than the defined values are used when appropriate. For example, a resource with a priority level of 0x78000001 indicates that the resource is slightly above normal.</p>
        /// </remarks>
        /// <doc-id>bb174561</doc-id>
        /// <unmanaged>HRESULT IDXGIResource::GetEvictionPriority([Out] unsigned int* pEvictionPriority)</unmanaged>
        /// <unmanaged-short>IDXGIResource::GetEvictionPriority</unmanaged-short>
        internal unsafe void GetEvictionPriority(out System.Int32 evictionPriorityRef)
        {
            SharpDX.Result __result__;
            fixed (void *evictionPriorityRef_ = &evictionPriorityRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, evictionPriorityRef_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("30961379-4609-4a41-998e-54fe567ee0c1")]
    public partial class Resource1 : SharpDX.DXGI.Resource
    {
        public Resource1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Resource1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Resource1(nativePtr);
        /// <summary>
        /// <p>Creates a subresource surface object.</p>
        /// </summary>
        /// <param name = "index"><dd> <p>The index of the subresource surface object to enumerate.</p> </dd></param>
        /// <param name = "surfaceOut"><dd> <p>The address of a reference to a <strong><see cref = "SharpDX.DXGI.Surface2"/></strong> interface that represents the created subresource surface object at the position specified by the <em>index</em> parameter.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns one of the following values:</p><ul> <li><see cref = "InvalidCall"/> if the index is out of range or if the subresource is not a valid surface.</li> <li>E_OUTOFMEMORY if insufficient memory is available to create the subresource surface object.</li> </ul><p>A subresource is a valid surface if the original resource would have been a valid surface had its array size been equal to 1.</p></returns>
        /// <remarks>
        /// <p>Subresource surface objects implement the <strong><see cref = "SharpDX.DXGI.Surface2"/></strong> interface, which inherits from  <strong><see cref = "SharpDX.DXGI.Surface1"/></strong> and indirectly <strong><see cref = "SharpDX.DXGI.Surface"/></strong>.  Therefore, the GDI-interoperable methods of <strong><see cref = "SharpDX.DXGI.Surface1"/></strong> work if the original resource interface object was created with the GDI-interoperable flag (<strong>D3D11_RESOURCE_MISC_GDI_COMPATIBLE</strong>).</p><p><strong>CreateSubresourceSurface</strong> creates a subresource surface that is based on the resource interface on which <strong>CreateSubresourceSurface</strong> is called. For example, if the original resource interface object is a 2D texture, the created subresource surface is also a 2D texture.</p><p>You can use <strong>CreateSubresourceSurface</strong> to create parts of  a stereo resource so you can use Direct2D on either the left or right part of the stereo resource.</p>
        /// </remarks>
        /// <doc-id>hh404627</doc-id>
        /// <unmanaged>HRESULT IDXGIResource1::CreateSubresourceSurface([In] unsigned int index,[Out, Fast] IDXGISurface2** ppSurface)</unmanaged>
        /// <unmanaged-short>IDXGIResource1::CreateSubresourceSurface</unmanaged-short>
        internal unsafe void CreateSubresourceSurface(System.Int32 index, SharpDX.DXGI.Surface2 surfaceOut)
        {
            System.IntPtr surfaceOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, index, &surfaceOut_, (*(void ***)this._nativePointer)[12]);
            (surfaceOut).NativePointer = surfaceOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a handle to a shared resource. You can then use the returned handle with multiple Direct3D devices. </p>
        /// </summary>
        /// <param name = "attributesRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Win32.SecurityAttributes"/></strong> structure that contains two separate but related data members: an optional security descriptor, and a Boolean  value that determines whether child processes can inherit the returned handle.</p> <p>Set this parameter to <strong><c>null</c></strong> if you want child processes that the  application might create to not  inherit  the handle returned by  <strong>CreateSharedHandle</strong>, and if you want the resource that is associated with the returned handle to get a default security  descriptor.</p> <p>The <strong>lpSecurityDescriptor</strong> member of the structure specifies a  <strong>SECURITY_DESCRIPTOR</strong> for the resource. Set  this member to <strong><c>null</c></strong> if you want the runtime to assign a default security descriptor to the resource that is associated with the returned handle. The ACLs in the default security descriptor for the resource come from the primary or impersonation token of the creator. For more info, see Synchronization Object Security and Access Rights.</p> </dd></param>
        /// <param name = "dwAccess"><dd> <p>The requested access rights to the resource.  In addition to the generic access rights, DXGI defines the following values:</p> <ul> <li><strong>DXGI_SHARED_RESOURCE_READ</strong> ( 0x80000000L ) - specifies read access to the resource.</li> <li><strong>DXGI_SHARED_RESOURCE_WRITE</strong> ( 1 ) - specifies  write access to the resource.</li> </ul> <p>You can combine these values by using a bitwise OR operation.</p> </dd></param>
        /// <param name = "lpName"><dd> <p>The name of the resource to share. The name is limited to MAX_PATH characters. Name comparison is case sensitive.  You will need the  resource name if you  call the <strong>ID3D11Device1::OpenSharedResourceByName</strong> method to access the shared resource by name. If you instead  call the <strong>ID3D11Device1::OpenSharedResource1</strong> method to access the shared resource by handle, set this parameter to <strong><c>null</c></strong>.</p> <p>If <em>lpName</em> matches the name of an existing resource, <strong>CreateSharedHandle</strong> fails with <see cref = "NameAlreadyExists"/>. This occurs because these objects share the same namespace.</p> <p>The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see Kernel Object Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</p> <p>The object can be created in a private namespace. For more information, see Object Namespaces.</p> </dd></param>
        /// <returns><dd> <p>A reference to a variable that receives the NT HANDLE value to the resource to share.  You can  use this handle in calls to access the resource.</p> </dd></returns>
        /// <remarks>
        /// <p><strong>CreateSharedHandle</strong> only returns the NT handle when you  created the resource as shared and specified that it uses NT handles (that is, you set the <strong>D3D11_RESOURCE_MISC_SHARED_NTHANDLE</strong> and <strong>D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX</strong> flags). If you  created the resource as shared and specified that it uses NT handles, you must use <strong>CreateSharedHandle</strong> to get a handle for sharing.  In this situation, you can't use the <strong>IDXGIResource::GetSharedHandle</strong> method because it will fail.</p><p>You can pass the handle that  <strong>CreateSharedHandle</strong> returns in a call to the <strong>ID3D11Device1::OpenSharedResource1</strong> method to give a device access to a shared resource that you created on a different device.</p><p>Because the handle that  <strong>CreateSharedHandle</strong> returns is an NT handle, you can use the handle with <strong>CloseHandle</strong>, <strong>DuplicateHandle</strong>, and so on. You can call <strong>CreateSharedHandle</strong> only once for a shared resource; later calls fail.  If you need more handles to the same shared resource, call <strong>DuplicateHandle</strong>. When you no longer need the shared resource handle, call <strong>CloseHandle</strong> to close the handle, in order to avoid memory leaks.</p><p>If you pass a name for the resource to <em>lpName</em> when you call <strong>CreateSharedHandle</strong> to share the resource, you can subsequently pass this name in a call to the <strong>ID3D11Device1::OpenSharedResourceByName</strong> method to give another device access to the shared resource. If you use a named resource, a malicious user can use this named resource before you do and prevent your app from starting. To prevent this situation, create a randomly named resource and store the name so that it can only be obtained by an authorized user. Alternatively, you can use a file for this purpose. To limit your app to one instance per user, create a locked file in the user's profile directory.</p><p>If you  created the resource as shared and did not specify that it uses NT handles, you cannot use <strong>CreateSharedHandle</strong> to get a handle for sharing because <strong>CreateSharedHandle</strong> will fail.</p>
        /// </remarks>
        /// <doc-id>hh404626</doc-id>
        /// <unmanaged>HRESULT IDXGIResource1::CreateSharedHandle([In, Optional] const SECURITY_ATTRIBUTES* pAttributes,[In] DWORD dwAccess,[In, Optional] const wchar_t* lpName,[Out] void** pHandle)</unmanaged>
        /// <unmanaged-short>IDXGIResource1::CreateSharedHandle</unmanaged-short>
        internal unsafe System.IntPtr CreateSharedHandle(SharpDX.Win32.SecurityAttributes? attributesRef, SharpDX.DXGI.SharedResourceFlags dwAccess, System.String lpName)
        {
            SharpDX.Win32.SecurityAttributes attributesRef_;
            System.IntPtr handleRef;
            SharpDX.Result __result__;
            if (attributesRef != null)
                attributesRef_ = attributesRef.Value;
            fixed (char *lpName_ = lpName)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, attributesRef == null ? (void *)0 : &attributesRef_, unchecked ((System.Int32)dwAccess), (void *)lpName_, &handleRef, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
            return handleRef;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("cafcb56c-6ac3-4889-bf47-9e23bbd260ec")]
    public partial class Surface : SharpDX.DXGI.DeviceChild
    {
        public Surface(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Surface(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Surface(nativePtr);
        /// <summary>
        /// <p>Get a description of the surface.</p>
        /// </summary>
        /// <doc-id>bb174566</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.DXGI.SurfaceDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Get a description of the surface.</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p>A reference to the surface description (see <strong><see cref = "SharpDX.DXGI.SurfaceDescription"/></strong>).</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns one of the error codes that are described in the DXGI_ERROR topic.</p></returns>
        /// <doc-id>bb174566</doc-id>
        /// <unmanaged>HRESULT IDXGISurface::GetDesc([Out] DXGI_SURFACE_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>IDXGISurface::GetDesc</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.DXGI.SurfaceDescription descRef)
        {
            descRef = default (SharpDX.DXGI.SurfaceDescription);
            SharpDX.Result __result__;
            fixed (void *descRef_ = &descRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Get a reference to the data contained in the surface, and deny GPU access to the surface.</p>
        /// </summary>
        /// <param name = "lockedRectRef"><dd>  <p>A reference to the surface data (see <strong><see cref = "SharpDX.DXGI.MappedRectangle"/></strong>).</p> </dd></param>
        /// <param name = "mapFlags"><dd>  <p>CPU read-write flags. These flags can be combined with a logical OR. </p> <ul> <li>DXGI_MAP_READ - Allow CPU read access.</li> <li>DXGI_MAP_WRITE - Allow CPU write access.</li> <li>DXGI_MAP_DISCARD - Discard the previous contents of a resource when it is mapped.</li> </ul> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns one of the error codes that are described in the DXGI_ERROR topic.</p></returns>
        /// <remarks>
        /// <p>Use <strong>IDXGISurface::Map</strong> to access a surface from the CPU. To release a mapped surface (and allow GPU access) call <strong>IDXGISurface::Unmap</strong>.</p>
        /// </remarks>
        /// <doc-id>bb174567</doc-id>
        /// <unmanaged>HRESULT IDXGISurface::Map([Out] DXGI_MAPPED_RECT* pLockedRect,[In] unsigned int MapFlags)</unmanaged>
        /// <unmanaged-short>IDXGISurface::Map</unmanaged-short>
        internal unsafe void Map(out SharpDX.DXGI.MappedRectangle lockedRectRef, System.Int32 mapFlags)
        {
            lockedRectRef = default (SharpDX.DXGI.MappedRectangle);
            SharpDX.Result __result__;
            fixed (void *lockedRectRef_ = &lockedRectRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, lockedRectRef_, mapFlags, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Get a reference to the data contained in the surface, and deny GPU access to the surface.</p>
        /// </summary>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns one of the error codes that are described in the DXGI_ERROR topic.</p></returns>
        /// <remarks>
        /// <p>Use <strong>IDXGISurface::Map</strong> to access a surface from the CPU. To release a mapped surface (and allow GPU access) call <strong>IDXGISurface::Unmap</strong>.</p>
        /// </remarks>
        /// <doc-id>bb174567</doc-id>
        /// <unmanaged>HRESULT IDXGISurface::Unmap()</unmanaged>
        /// <unmanaged-short>IDXGISurface::Unmap</unmanaged-short>
        public unsafe void Unmap()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("4AE63092-6327-4c1b-80AE-BFE12EA32B86")]
    public partial class Surface1 : SharpDX.DXGI.Surface
    {
        public Surface1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Surface1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Surface1(nativePtr);
        /// <summary>
        /// <p>Returns a device context (DC) that allows you to render to a Microsoft DirectX Graphics Infrastructure (DXGI) surface using Windows Graphics Device Interface (GDI).</p>
        /// </summary>
        /// <param name = "discard"><dd>  <p>A Boolean value that specifies whether to preserve Direct3D contents in the GDI DC. <strong>TRUE</strong> directs the runtime not to preserve Direct3D contents in the GDI DC; that is, the runtime discards the Direct3D contents. <strong><see cref = "SharpDX.Result.False"/></strong> guarantees that Direct3D contents are available in the GDI DC.</p> </dd></param>
        /// <returns><dd>  <p>A reference to an <strong><see cref = "System.IntPtr"/></strong> handle that represents the current device context for GDI rendering.</p> </dd></returns>
        /// <remarks>
        /// <p>This method is not supported by DXGI 1.0, which shipped in Windows?Vista and Windows Server?2008. DXGI 1.1 support is required, which is available on  Windows?7, Windows Server?2008?R2, and as an update to Windows?Vista with Service Pack?2 (SP2) (KB 971644) and Windows Server?2008 (KB 971512).</p><p>After you use the <strong>GetDC</strong> method to retrieve a DC, you can render to the DXGI surface by using GDI.   The <strong>GetDC</strong> method readies the surface for GDI rendering and allows inter-operation between DXGI and GDI technologies.  </p><p>Keep the following in mind when using this method:</p><ul> <li>You must create the surface by using the <strong>D3D11_RESOURCE_MISC_GDI_COMPATIBLE</strong> flag for a surface or by using the <strong>DXGI_SWAP_CHAIN_FLAG_GDI_COMPATIBLE</strong> flag for swap chains,  otherwise this method fails.</li> <li>You must release the device and call the <strong>IDXGISurface1::ReleaseDC</strong> method before you issue any new Direct3D commands.</li> <li>This method fails if an outstanding DC has already been created by this method.</li> <li>The format for the surface or swap chain must be <strong>DXGI_FORMAT_B8G8R8A8_UNORM_SRGB</strong> or <strong>DXGI_FORMAT_B8G8R8A8_UNORM</strong>.</li> <li>On <strong>GetDC</strong>, the render target in the output merger of the Direct3D pipeline is unbound from the surface.   You must call the <strong>ID3D11DeviceContext::OMSetRenderTargets</strong> method on the device prior to Direct3D rendering after GDI rendering.</li> <li>Prior to resizing buffers you must release all outstanding DCs.</li> </ul><p> You can also call <strong>GetDC</strong> on the back buffer at index 0 of a swap chain by obtaining an <strong><see cref = "SharpDX.DXGI.Surface1"/></strong> from the swap chain.   The following code illustrates the process.</p><pre> <see cref = "SharpDX.DXGI.SwapChain"/>* g_pSwapChain = <c>null</c>;
        /// <see cref = "SharpDX.DXGI.Surface1"/>* g_pSurface1 = <c>null</c>;
        /// ...
        /// //Setup the device and and swapchain
        /// g_pSwapChain-&gt;GetBuffer(0, __uuidof(<see cref = "SharpDX.DXGI.Surface1"/>), (void**) &amp;g_pSurface1);
        /// g_pSurface1-&gt;GetDC( <see cref = "SharpDX.Result.False"/>, &amp;g_hDC );
        /// ...      
        /// //Draw on the DC using GDI
        /// ...
        /// //When finish drawing release the DC
        /// g_pSurface1-&gt;ReleaseDC( <c>null</c> ); </pre>
        /// </remarks>
        /// <doc-id>ff471345</doc-id>
        /// <unmanaged>HRESULT IDXGISurface1::GetDC([In] BOOL Discard,[Out] HDC* phdc)</unmanaged>
        /// <unmanaged-short>IDXGISurface1::GetDC</unmanaged-short>
        public unsafe System.IntPtr GetDC(SharpDX.Mathematics.Interop.RawBool discard)
        {
            System.IntPtr hdcRef;
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint0(this._nativePointer, discard, &hdcRef, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
            return hdcRef;
        }

        /// <summary>
        /// <p>Releases the GDI device context (DC) that is associated with the current surface and allows you to use Direct3D to render.</p>
        /// </summary>
        /// <param name = "dirtyRectRef"><dd>  <p>A reference to a <strong><see cref = "SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure that identifies the dirty region of the surface.   A dirty region is any part of the surface that you used for GDI rendering and that you want to preserve.  This area is used as a performance hint to graphics subsystem in certain scenarios.  Do not use this parameter to restrict rendering to the specified rectangular region.  If you pass in <strong><c>null</c></strong>, <strong>ReleaseDC</strong> considers the whole surface as dirty.  Otherwise, <strong>ReleaseDC</strong> uses the area specified by the <see cref = "SharpDX.Mathematics.Interop.RawRectangle"/> as a performance hint to indicate what areas have been manipulated by GDI rendering.</p> <p>You can pass a reference to an empty <strong><see cref = "SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure (a rectangle with no position or area) if you didn't change any content.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This method is not supported by DXGI 1.0, which shipped in Windows?Vista and Windows Server?2008. DXGI 1.1 support is required, which is available on  Windows?7, Windows Server?2008?R2, and as an update to Windows?Vista with Service Pack?2 (SP2) (KB 971644) and Windows Server?2008 (KB 971512).</p><p>Use the <strong>ReleaseDC</strong> method to release the DC and indicate that your application finished all GDI rendering to this surface.   You must call the <strong>ReleaseDC</strong> method before you can use Direct3D to perform additional rendering.</p><p>Prior to resizing buffers you must release all outstanding DCs.</p>
        /// </remarks>
        /// <doc-id>ff471346</doc-id>
        /// <unmanaged>HRESULT IDXGISurface1::ReleaseDC([In, Optional] RECT* pDirtyRect)</unmanaged>
        /// <unmanaged-short>IDXGISurface1::ReleaseDC</unmanaged-short>
        internal unsafe void ReleaseDC_(SharpDX.Mathematics.Interop.RawRectangle? dirtyRectRef)
        {
            SharpDX.Mathematics.Interop.RawRectangle dirtyRectRef_;
            SharpDX.Result __result__;
            if (dirtyRectRef != null)
                dirtyRectRef_ = dirtyRectRef.Value;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, dirtyRectRef == null ? (void *)0 : &dirtyRectRef_, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("aba496dd-b617-4cb8-a866-bc44d7eb1fa2")]
    public partial class Surface2 : SharpDX.DXGI.Surface1
    {
        public Surface2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Surface2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Surface2(nativePtr);
        /// <summary>
        /// <p>Gets the parent resource and subresource index that support a subresource surface.</p>
        /// </summary>
        /// <param name = "riid"><dd> <p>The globally unique identifier (<see cref = "System.Guid"/>)  of the requested interface type.</p> </dd></param>
        /// <param name = "parentResourceOut"><dd> <p>A reference to a buffer that receives a reference to the parent resource object for the subresource surface.</p> </dd></param>
        /// <param name = "subresourceIndexRef"><dd> <p>A reference to a variable that receives the index of the subresource surface.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns one of the following values:</p><ul> <li>E_NOINTERFACE if the object does not implement the <see cref = "System.Guid"/> that the <em>riid</em> parameter specifies.</li> <li>Possibly other error codes that are described in the DXGI_ERROR topic.</li> </ul></returns>
        /// <remarks>
        /// <p>For subresource surface objects that the <strong>IDXGIResource1::CreateSubresourceSurface</strong> method creates, <strong>GetResource</strong> simply returns the values that were used to create the subresource surface.</p><p>Current objects that implement <strong><see cref = "SharpDX.DXGI.Surface"/></strong> are either resources or views.  <strong>GetResource</strong> for these objects returns ?this? or the resource that supports the view respectively.  In this situation, the subresource index is 0.</p>
        /// </remarks>
        /// <doc-id>hh404629</doc-id>
        /// <unmanaged>HRESULT IDXGISurface2::GetResource([In] const GUID&amp; riid,[Out] void** ppParentResource,[Out] unsigned int* pSubresourceIndex)</unmanaged>
        /// <unmanaged-short>IDXGISurface2::GetResource</unmanaged-short>
        public unsafe void GetResource(System.Guid riid, out System.IntPtr parentResourceOut, out System.Int32 subresourceIndexRef)
        {
            SharpDX.Result __result__;
            fixed (void *subresourceIndexRef_ = &subresourceIndexRef)
                fixed (void *parentResourceOut_ = &parentResourceOut)
                    __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &riid, parentResourceOut_, subresourceIndexRef_, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("310d36a0-d2e7-4c0a-aa04-6a9d23b8886a")]
    public partial class SwapChain : SharpDX.DXGI.DeviceChild
    {
        public SwapChain(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SwapChain(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SwapChain(nativePtr);
        /// <summary>
        /// <p>[Starting with Direct3D 11.1, we recommend not to use <strong>GetDesc</strong> anymore to get a description of the swap chain. Instead, use <strong>IDXGISwapChain1::GetDesc1</strong>.]</p><p>Get a description of the swap chain.</p>
        /// </summary>
        /// <doc-id>bb174572</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.DXGI.SwapChainDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Get the output (the display monitor) that contains the majority of the client area of the target window.</p>
        /// </summary>
        /// <remarks>
        /// <p>If the method succeeds, the output interface will be filled and its reference count incremented. When you are finished with it, be sure to release the interface to avoid a memory leak.</p><p>The output is also owned by the adapter on which the swap chain's device was created.</p><p>You cannot call <strong>GetContainingOutput</strong> on a swap chain that you created with <strong>IDXGIFactory2::CreateSwapChainForComposition</strong>.</p>
        /// </remarks>
        /// <doc-id>bb174571</doc-id>
        /// <unmanaged>GetContainingOutput</unmanaged>
        /// <unmanaged-short>GetContainingOutput</unmanaged-short>
        public SharpDX.DXGI.Output ContainingOutput
        {
            get
            {
                GetContainingOutput(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the number of times  that <strong>IDXGISwapChain::Present</strong> or <strong>IDXGISwapChain1::Present1</strong> has been called.</p>
        /// </summary>
        /// <remarks>
        /// <p>For info about presentation statistics for a frame, see <strong><see cref = "SharpDX.DXGI.FrameStatistics"/></strong>.</p>
        /// </remarks>
        /// <doc-id>bb174575</doc-id>
        /// <unmanaged>GetLastPresentCount</unmanaged>
        /// <unmanaged-short>GetLastPresentCount</unmanaged-short>
        public System.Int32 LastPresentCount
        {
            get
            {
                GetLastPresentCount(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Presents a rendered image to the user.</p>
        /// </summary>
        /// <param name = "syncInterval"><dd>  <p>An integer that specifies how to synchronize presentation of a frame with the vertical blank.</p> <p>For the bit-block transfer (bitblt) model (<strong>DXGI_SWAP_EFFECT_DISCARD</strong> or <strong>DXGI_SWAP_EFFECT_SEQUENTIAL</strong>), values are:</p> <ul> <li>0 - The presentation occurs immediately, there is no synchronization.</li> <li>1 through 4 - Synchronize presentation after the <em>n</em>th vertical blank.</li> </ul> <p>For the flip model (<strong>DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL</strong>), values are:</p> <ul> <li>0 - Cancel the remaining time on the previously presented frame and discard this frame if a newer frame is queued.</li> <li>1 through 4 - Synchronize presentation for at least <em>n</em> vertical blanks. </li> </ul> <p>For an example that shows how sync-interval values affect a flip presentation queue, see Remarks.</p> <p>If the update region straddles more than one output (each represented by <strong><see cref = "SharpDX.DXGI.Output"/></strong>), <strong>Present</strong> performs the synchronization to the output that contains the largest sub-rectangle of the target window's client area.</p> </dd></param>
        /// <param name = "flags"><dd>  <p>An integer value that contains swap-chain presentation options. These options are defined by the DXGI_PRESENT constants.</p> </dd></param>
        /// <returns><p>Possible return values include: <see cref = "SharpDX.Result.Ok"/>, <see cref = "DeviceReset"/> or <see cref = "DeviceRemoved"/> (see DXGI_ERROR), DXGI_STATUS_OCCLUDED (see <see cref = "SharpDX.DXGI.DXGIStatus"/>), or D3DDDIERR_DEVICEREMOVED.  </p><strong>Note</strong>??The <strong>Present</strong> method can return either <see cref = "DeviceRemoved"/> or D3DDDIERR_DEVICEREMOVED if a video card has been physically removed from the computer, or a driver upgrade for the video card has occurred.?</returns>
        /// <remarks>
        /// <p>Starting with Direct3D 11.1, consider using <strong>IDXGISwapChain1::Present1</strong> because you can then use dirty rectangles and the scroll rectangle in the swap chain presentation and as such use less memory bandwidth and as a result less system power. For more info about using dirty rectangles and the scroll rectangle in swap chain presentation, see Using dirty rectangles and the scroll rectangle in swap chain presentation.</p><p>For the best performance when flipping swap-chain buffers in a full-screen application, see Full-Screen Application Performance Hints.</p><p>Because calling <strong>Present</strong> might cause the render thread to wait on the message-pump thread, be careful when calling this method in an application that uses multiple threads. For more details, see Multithreading Considerations.</p><table> <tr><td> <p>Differences between Direct3D 9 and Direct3D 10:</p> <p>Specifying <strong>DXGI_PRESENT_TEST</strong> in the <em>Flags</em> parameter is analogous to <strong>IDirect3DDevice9::TestCooperativeLevel</strong> in Direct3D 9.</p> </td></tr> </table><p>?</p><p>For flip presentation model swap chains that you create with the <strong>DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL</strong> value set, a successful presentation unbinds back buffer 0 from the graphics pipeline, except for when you pass the <strong>DXGI_PRESENT_DO_NOT_SEQUENCE</strong> flag in the <em>Flags</em> parameter.</p><p>For info about how data values change when you present content to the screen, see Converting data for the color space.</p>
        /// </remarks>
        /// <doc-id>bb174576</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain::Present([In] unsigned int SyncInterval,[In] unsigned int Flags)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain::Present</unmanaged-short>
        public unsafe SharpDX.Result TryPresent(System.Int32 syncInterval, SharpDX.DXGI.PresentFlags flags)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, syncInterval, unchecked ((System.Int32)flags), (*(void ***)this._nativePointer)[8]);
            return __result__;
        }

        /// <summary>
        /// <p>Accesses one of the swap-chain's back buffers.</p>
        /// </summary>
        /// <param name = "buffer"><dd>  <p>A zero-based buffer index. </p> <p>If the swap chain's swap effect is <strong>DXGI_SWAP_EFFECT_DISCARD</strong>, this method can only access the first buffer; for this situation, set the index to zero.</p> <p>If the swap chain's swap effect is either <strong>DXGI_SWAP_EFFECT_SEQUENTIAL</strong> or <strong>DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL</strong>, only the swap chain's zero-index buffer can be read from and written to. The swap chain's buffers with indexes greater than zero can only be read from; so if you call the <strong>IDXGIResource::GetUsage</strong> method for such buffers, they have the <strong>DXGI_USAGE_READ_ONLY</strong> flag set.</p> </dd></param>
        /// <param name = "riid"><dd>  <p>The type of interface used to manipulate the buffer.</p> </dd></param>
        /// <param name = "surfaceOut"><dd>  <p>A reference to a back-buffer interface.</p> </dd></param>
        /// <returns><p>Returns one of the following DXGI_ERROR.</p></returns>
        /// <doc-id>bb174570</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain::GetBuffer([In] unsigned int Buffer,[In] const GUID&amp; riid,[Out] void** ppSurface)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain::GetBuffer</unmanaged-short>
        internal unsafe void GetBuffer(System.Int32 buffer, System.Guid riid, out System.IntPtr surfaceOut)
        {
            SharpDX.Result __result__;
            fixed (void *surfaceOut_ = &surfaceOut)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, buffer, &riid, surfaceOut_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the display state to windowed or full screen.</p>
        /// </summary>
        /// <param name = "fullscreen"><dd>  <p>A Boolean value that specifies whether to set the display state to windowed or full screen. <strong>TRUE</strong> for full screen, and <strong><see cref = "SharpDX.Result.False"/></strong> for windowed.</p> </dd></param>
        /// <param name = "targetRef"><dd>  <p>If you pass <strong>TRUE</strong> to the <em>Fullscreen</em> parameter to set the display state to full screen, you can optionally set this parameter to a reference to an <strong><see cref = "SharpDX.DXGI.Output"/></strong> interface for the output target that contains the swap chain. If you set this parameter to <strong><c>null</c></strong>, DXGI will choose the output based on the swap-chain's device and the output window's  placement. If you pass <strong><see cref = "SharpDX.Result.False"/></strong> to <em>Fullscreen</em>, you must set this parameter to <strong><c>null</c></strong>.</p> </dd></param>
        /// <returns><p>This methods returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if the action succeeded and the swap chain was placed in the requested state.</li> <li><see cref = "NotCurrentlyAvailable"/> if the action failed. There are many reasons why a windowed-mode swap chain cannot switch to full-screen mode. For instance: <ul> <li>The application is running over Terminal Server.</li> <li>The output window is occluded.</li> <li>The output window does not have keyboard focus.</li> <li>Another application is already in full-screen mode.</li> </ul> <p>When this error is returned, an application can continue to run in windowed mode and try to switch to full-screen mode later.</p> </li> <li>DXGI_STATUS_MODE_CHANGE_IN_PROGRESS is returned if a fullscreen/windowed mode transition is occurring when this API is called.</li> <li>Other error codes if you run out of memory or encounter another unexpected fault; these codes may be treated as hard, non-continuable errors.</li> </ul></returns>
        /// <remarks>
        /// <p>DXGI may change the display state of a swap chain in response to end user or system requests.</p><p>We recommend that you create a windowed swap chain and allow the end user to change the swap chain to full screen through <strong>SetFullscreenState</strong>; that is, do not set the <strong>Windowed</strong> member of <strong><see cref = "SharpDX.DXGI.SwapChainDescription"/></strong> to <see cref = "SharpDX.Result.False"/> to force the swap chain to be full screen. However, if you create the swap chain as full screen, also provide the end user with a list of supported display modes because a swap chain that is created with an unsupported display mode might cause the display to go black and prevent the end user from seeing anything. Also, we recommend that you have a time-out confirmation screen or other fallback mechanism when you allow the end user to change display modes.</p>
        /// </remarks>
        /// <doc-id>bb174579</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain::SetFullscreenState([In] BOOL Fullscreen,[In, Optional] IDXGIOutput* pTarget)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain::SetFullscreenState</unmanaged-short>
        public unsafe void SetFullscreenState(SharpDX.Mathematics.Interop.RawBool fullscreen, SharpDX.DXGI.Output targetRef)
        {
            System.IntPtr targetRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            targetRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Output>(targetRef);
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint0(this._nativePointer, fullscreen, (void *)targetRef_, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Get the state associated with full-screen mode.</p>
        /// </summary>
        /// <param name = "fullscreenRef"><dd>  <p>A reference to a boolean whose value is either:</p> <ul> <li><strong>TRUE</strong> if the swap chain is in full-screen mode</li> <li><strong><see cref = "SharpDX.Result.False"/></strong> if the swap chain is in windowed mode</li> </ul> </dd></param>
        /// <param name = "targetOut"><dd>  <p>A reference to the output target (see <strong><see cref = "SharpDX.DXGI.Output"/></strong>) when the mode is full screen; otherwise <strong><c>null</c></strong>.</p> </dd></param>
        /// <returns><p>Returns one of the following DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <p>When the swap chain is in full-screen mode, a reference to the  target output will be returned and its reference count will be incremented.</p>
        /// </remarks>
        /// <doc-id>bb174574</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain::GetFullscreenState([Out, Optional] BOOL* pFullscreen,[Out, Optional] IDXGIOutput** ppTarget)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain::GetFullscreenState</unmanaged-short>
        public unsafe void GetFullscreenState(out SharpDX.Mathematics.Interop.RawBool fullscreenRef, out SharpDX.DXGI.Output targetOut)
        {
            fullscreenRef = default (SharpDX.Mathematics.Interop.RawBool);
            System.IntPtr targetOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *fullscreenRef_ = &fullscreenRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, fullscreenRef_, &targetOut_, (*(void ***)this._nativePointer)[11]);
            if (targetOut_ != System.IntPtr.Zero)
                targetOut = new SharpDX.DXGI.Output(targetOut_);
            else
                targetOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>[Starting with Direct3D 11.1, we recommend not to use <strong>GetDesc</strong> anymore to get a description of the swap chain. Instead, use <strong>IDXGISwapChain1::GetDesc1</strong>.]</p><p>Get a description of the swap chain.</p>
        /// </summary>
        /// <param name = "descRef">No documentation.</param>
        /// <returns><p>Returns one of the following DXGI_ERROR.</p></returns>
        /// <doc-id>bb174572</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain::GetDesc([Out] DXGI_SWAP_CHAIN_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain::GetDesc</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.DXGI.SwapChainDescription descRef)
        {
            descRef = default (SharpDX.DXGI.SwapChainDescription);
            SharpDX.Result __result__;
            fixed (void *descRef_ = &descRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Changes the swap chain's back buffer size, format, and number of buffers.  This should be called when the application window is resized. </p>
        /// </summary>
        /// <param name = "bufferCount"><dd>  <p> The number of buffers in the swap chain (including all back and front buffers).  This number can be different from the number of buffers with which you created the swap chain.  This number can't be greater than <strong>DXGI_MAX_SWAP_CHAIN_BUFFERS</strong>.  Set this number to zero to preserve the existing number of buffers in the swap chain.  You can't specify less than two buffers for the flip presentation model. </p> </dd></param>
        /// <param name = "width"><dd>  <p> The new width of the back buffer.  If you specify zero, DXGI will use the width of the client area of the target window.  You can't specify the width as zero if you called the <strong>IDXGIFactory2::CreateSwapChainForComposition</strong> method to create the swap chain for a composition surface. </p> </dd></param>
        /// <param name = "height"><dd>  <p> The new height of the back buffer.  If you specify zero, DXGI will use the height of the client area of the target window.  You can't specify the height as zero if you called the <strong>IDXGIFactory2::CreateSwapChainForComposition</strong> method to create the swap chain for a composition surface. </p> </dd></param>
        /// <param name = "newFormat"><dd>  <p> A <strong><see cref = "SharpDX.DXGI.Format"/></strong>-typed value for the new format of the back buffer.  Set this value to <strong>DXGI_FORMAT_UNKNOWN</strong> to preserve the existing format of the back buffer.  The flip presentation model supports a more restricted set of formats than the bit-block transfer (bitblt) model. </p> </dd></param>
        /// <param name = "swapChainFlags"><dd>  <p> A combination of <strong><see cref = "SharpDX.DXGI.SwapChainFlags"/></strong>-typed values that are combined by using a bitwise OR operation.  The resulting value specifies options for swap-chain behavior. </p> </dd></param>
        /// <returns><p> Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise.  For a list of error codes, see DXGI_ERROR. </p></returns>
        /// <remarks>
        /// <p> You can't resize a swap chain unless you release all outstanding references to its back buffers. You must release all of its direct and indirect references on the back buffers in order for <strong>ResizeBuffers</strong> to succeed. </p><p> Direct references are held by the application after it calls <strong>AddRef</strong> on a resource. </p><p> Indirect references are held by views to a resource, binding a view of the resource to a device context, a command list that used the resource, a command list that used a view to that resource, a command list that executed another command list that used the resource, and so on. </p><p> Before you call <strong>ResizeBuffers</strong>, ensure that the application releases all references  (by calling the appropriate number of <strong>Release</strong> invocations) on the resources, any views to the resource, and any command lists that use either the resources or views,  and ensure that neither the resource nor a view is still bound to a device context. You can use <strong>ID3D11DeviceContext::ClearState</strong> to ensure that all references are released.  If a view is bound to a deferred context, you must discard the partially built command list as well (by calling  <strong>ID3D11DeviceContext::ClearState</strong>, then <strong>ID3D11DeviceContext::FinishCommandList</strong>, then  <strong>Release</strong> on the command list). After you call <strong>ResizeBuffers</strong>, you can re-query interfaces via <strong>IDXGISwapChain::GetBuffer</strong>. </p><p> For swap chains that you created with <strong>DXGI_SWAP_CHAIN_FLAG_GDI_COMPATIBLE</strong>,  before you call <strong>ResizeBuffers</strong>, also call <strong>IDXGISurface1::ReleaseDC</strong> on the swap chain's back-buffer surface  to ensure that you have no outstanding GDI device contexts (DCs) open. </p><p> We recommend that you call <strong>ResizeBuffers</strong> when a client window is resized (that is, when an application receives a WM_SIZE message). </p><p> The only difference between <strong>IDXGISwapChain::ResizeBuffers</strong> in Windows?8 versus Windows?7 is with  flip presentation model swap chains that you create with the <strong>DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL</strong> or DXGI_SWAP_EFFECT_FLIP_DISCARD value set. In Windows?8, you must call <strong>ResizeBuffers</strong> to realize a transition between full-screen mode and windowed mode;  otherwise, your next call to the <strong>IDXGISwapChain::Present</strong> method fails. </p>
        /// </remarks>
        /// <doc-id>bb174577</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain::ResizeBuffers([In] unsigned int BufferCount,[In] unsigned int Width,[In] unsigned int Height,[In] DXGI_FORMAT NewFormat,[In] unsigned int SwapChainFlags)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain::ResizeBuffers</unmanaged-short>
        public unsafe void ResizeBuffers(System.Int32 bufferCount, System.Int32 width, System.Int32 height, SharpDX.DXGI.Format newFormat, SharpDX.DXGI.SwapChainFlags swapChainFlags)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, bufferCount, width, height, unchecked ((System.Int32)newFormat), unchecked ((System.Int32)swapChainFlags), (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Resizes the output target.</p>
        /// </summary>
        /// <param name = "newTargetParametersRef"><dd>  <p>A reference to a <strong><see cref = "SharpDX.DXGI.ModeDescription"/></strong> structure that describes the mode, which specifies the new width, height, format, and refresh rate of the target.  If the format is <strong>DXGI_FORMAT_UNKNOWN</strong>, <strong>ResizeTarget</strong> uses the existing format. We only recommend that you use <strong>DXGI_FORMAT_UNKNOWN</strong> when the swap chain is in full-screen  mode as this method is not thread safe.</p> </dd></param>
        /// <returns><p>Returns a code that indicates success or failure. <strong>DXGI_STATUS_MODE_CHANGE_IN_PROGRESS</strong> is returned if a full-screen/windowed mode transition is occurring  when this API is called. See DXGI_ERROR for additional DXGI error codes.</p></returns>
        /// <remarks>
        /// <p><strong>ResizeTarget</strong> resizes the target window when the swap chain is in windowed mode, and changes the display mode on the target output when the swap  chain is in full-screen mode. Therefore, apps can call <strong>ResizeTarget</strong> to resize the target window (rather than a Microsoft Win32API such as <strong>SetWindowPos</strong>)  without knowledge of the swap chain display mode.</p><p>If a Windows Store app calls <strong>ResizeTarget</strong>, it fails with <see cref = "NotCurrentlyAvailable"/>.</p><p>You cannot call <strong>ResizeTarget</strong> on a swap chain that you created with <strong>IDXGIFactory2::CreateSwapChainForComposition</strong>.</p><p>Apps must still call <strong>IDXGISwapChain::ResizeBuffers</strong> after they call <strong>ResizeTarget</strong> because only <strong>ResizeBuffers</strong> can change the back buffers. But, if those apps have implemented window resize processing to call <strong>ResizeBuffers</strong>, they don't need to explicitly call <strong>ResizeBuffers</strong> after they call <strong>ResizeTarget</strong> because the window resize processing will achieve what the app requires.</p>
        /// </remarks>
        /// <doc-id>bb174578</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain::ResizeTarget([In] const DXGI_MODE_DESC* pNewTargetParameters)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain::ResizeTarget</unmanaged-short>
        public unsafe void ResizeTarget(ref SharpDX.DXGI.ModeDescription newTargetParametersRef)
        {
            SharpDX.Result __result__;
            fixed (void *newTargetParametersRef_ = &newTargetParametersRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, newTargetParametersRef_, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Get the output (the display monitor) that contains the majority of the client area of the target window.</p>
        /// </summary>
        /// <param name = "outputOut"><dd>  <p>A reference to the output interface (see <strong><see cref = "SharpDX.DXGI.Output"/></strong>).</p> </dd></param>
        /// <returns><p>Returns one of the following DXGI_ERROR.</p></returns>
        /// <remarks>
        /// <p>If the method succeeds, the output interface will be filled and its reference count incremented. When you are finished with it, be sure to release the interface to avoid a memory leak.</p><p>The output is also owned by the adapter on which the swap chain's device was created.</p><p>You cannot call <strong>GetContainingOutput</strong> on a swap chain that you created with <strong>IDXGIFactory2::CreateSwapChainForComposition</strong>.</p>
        /// </remarks>
        /// <doc-id>bb174571</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain::GetContainingOutput([Out] IDXGIOutput** ppOutput)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain::GetContainingOutput</unmanaged-short>
        internal unsafe void GetContainingOutput(out SharpDX.DXGI.Output outputOut)
        {
            System.IntPtr outputOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &outputOut_, (*(void ***)this._nativePointer)[15]);
            if (outputOut_ != System.IntPtr.Zero)
                outputOut = new SharpDX.DXGI.Output(outputOut_);
            else
                outputOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets performance statistics about the last render frame.</p>
        /// </summary>
        /// <param name = "statsRef"><dd>  <p>A reference to a <strong><see cref = "SharpDX.DXGI.FrameStatistics"/></strong> structure for the frame statistics.</p> </dd></param>
        /// <returns><p>Returns one of the DXGI_ERROR values.</p></returns>
        /// <remarks>
        /// <p>You cannot use <strong>GetFrameStatistics</strong> for swap chains that both use the bit-block transfer (bitblt) presentation model and draw in windowed mode.</p><p>You can only use <strong>GetFrameStatistics</strong> for swap chains that either use the flip presentation model or draw in full-screen mode. You set the <strong>DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL</strong> value in the <strong>SwapEffect</strong> member of the <strong><see cref = "SharpDX.DXGI.SwapChainDescription1"/></strong> structure to specify that the swap chain uses the flip presentation model.</p>
        /// </remarks>
        /// <doc-id>bb174573</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain::GetFrameStatistics([Out] DXGI_FRAME_STATISTICS* pStats)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain::GetFrameStatistics</unmanaged-short>
        public unsafe SharpDX.Result TryGetFrameStatistics(out SharpDX.DXGI.FrameStatistics statsRef)
        {
            statsRef = default (SharpDX.DXGI.FrameStatistics);
            SharpDX.Result __result__;
            fixed (void *statsRef_ = &statsRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, statsRef_, (*(void ***)this._nativePointer)[16]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the number of times  that <strong>IDXGISwapChain::Present</strong> or <strong>IDXGISwapChain1::Present1</strong> has been called.</p>
        /// </summary>
        /// <param name = "lastPresentCountRef">No documentation.</param>
        /// <returns><p>Returns one of the DXGI_ERROR values.</p></returns>
        /// <remarks>
        /// <p>For info about presentation statistics for a frame, see <strong><see cref = "SharpDX.DXGI.FrameStatistics"/></strong>.</p>
        /// </remarks>
        /// <doc-id>bb174575</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain::GetLastPresentCount([Out] unsigned int* pLastPresentCount)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain::GetLastPresentCount</unmanaged-short>
        internal unsafe void GetLastPresentCount(out System.Int32 lastPresentCountRef)
        {
            SharpDX.Result __result__;
            fixed (void *lastPresentCountRef_ = &lastPresentCountRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, lastPresentCountRef_, (*(void ***)this._nativePointer)[17]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("790a45f7-0d42-4876-983a-0a55cfe6f4aa")]
    public partial class SwapChain1 : SharpDX.DXGI.SwapChain
    {
        public SwapChain1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SwapChain1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SwapChain1(nativePtr);
        /// <summary>
        /// <p>Gets a description of the swap chain.</p>
        /// </summary>
        /// <doc-id>hh404640</doc-id>
        /// <unmanaged>GetDesc1</unmanaged>
        /// <unmanaged-short>GetDesc1</unmanaged-short>
        public SharpDX.DXGI.SwapChainDescription1 Description1
        {
            get
            {
                GetDescription1(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets a description of a full-screen swap chain.</p>
        /// </summary>
        /// <remarks>
        /// <p>The semantics of <strong>GetFullscreenDesc</strong> are identical to that of the <strong>IDXGISwapchain::GetDesc</strong> method for <strong><see cref = "System.IntPtr"/></strong>-based swap chains.</p>
        /// </remarks>
        /// <doc-id>hh404644</doc-id>
        /// <unmanaged>GetFullscreenDesc</unmanaged>
        /// <unmanaged-short>GetFullscreenDesc</unmanaged-short>
        public SharpDX.DXGI.SwapChainFullScreenDescription FullscreenDescription
        {
            get
            {
                GetFullscreenDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves the underlying <strong><see cref = "System.IntPtr"/></strong> for this swap-chain object.</p>
        /// </summary>
        /// <remarks>
        /// <p>Applications call the  <strong>IDXGIFactory2::CreateSwapChainForHwnd</strong> method to create a swap chain that is associated with an <strong><see cref = "System.IntPtr"/></strong>.</p>
        /// </remarks>
        /// <doc-id>hh404647</doc-id>
        /// <unmanaged>GetHwnd</unmanaged>
        /// <unmanaged-short>GetHwnd</unmanaged-short>
        public System.IntPtr Hwnd
        {
            get
            {
                GetHwnd(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Determines whether a swap chain supports ?temporary mono.?</p>
        /// </summary>
        /// <remarks>
        /// <p>Temporary mono is a feature where a stereo swap chain can be presented using only the content in the left buffer.  To present using the left buffer as a mono buffer, an application calls the  <strong>IDXGISwapChain1::Present1</strong> method with the <strong>DXGI_PRESENT_STEREO_TEMPORARY_MONO</strong> flag.  All windowed swap chains support temporary mono. However, full-screen swap chains optionally support temporary mono because not all hardware supports temporary mono on full-screen swap chains efficiently.</p>
        /// </remarks>
        /// <doc-id>hh446794</doc-id>
        /// <unmanaged>IsTemporaryMonoSupported</unmanaged>
        /// <unmanaged-short>IsTemporaryMonoSupported</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsTemporaryMonoSupported
        {
            get => IsTemporaryMonoSupported_();
        }

        /// <summary>
        /// <p>Gets the output (the display monitor) to which you can restrict the contents of a present operation.</p>
        /// </summary>
        /// <remarks>
        /// <p>If the method succeeds, the runtime fills the buffer at <em>ppRestrictToOutput</em> with a reference to the restrict-to output interface. This restrict-to output interface has its reference count incremented. When you are finished with it, be sure to release the interface to avoid a memory leak.</p><p>The output is also owned by the adapter on which the swap chain's device was created.</p>
        /// </remarks>
        /// <doc-id>hh446788</doc-id>
        /// <unmanaged>GetRestrictToOutput</unmanaged>
        /// <unmanaged-short>GetRestrictToOutput</unmanaged-short>
        public SharpDX.DXGI.Output RestrictToOutput
        {
            get
            {
                GetRestrictToOutput(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves or sets the background color of the swap chain.</p>
        /// </summary>
        /// <remarks>
        /// <strong>Note</strong>??The background color that <strong>GetBackgroundColor</strong> retrieves does not indicate what the screen currently displays. The background color indicates what the screen will display with your next call to the <strong>IDXGISwapChain1::Present1</strong> method. The default value of the background color is black with full opacity: 0,0,0,1.?
        /// </remarks>
        /// <doc-id>hh404634</doc-id>
        /// <unmanaged>GetBackgroundColor / SetBackgroundColor</unmanaged>
        /// <unmanaged-short>GetBackgroundColor</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawColor4 BackgroundColor
        {
            get
            {
                GetBackgroundColor(out var __output__);
                return __output__;
            }

            set => SetBackgroundColor(value);
        }

        /// <summary>
        /// <p>Gets or sets the rotation of the back buffers for the swap chain.</p>
        /// </summary>
        /// <doc-id>hh446791</doc-id>
        /// <unmanaged>GetRotation / SetRotation</unmanaged>
        /// <unmanaged-short>GetRotation</unmanaged-short>
        public SharpDX.DXGI.DisplayModeRotation Rotation
        {
            get
            {
                GetRotation(out var __output__);
                return __output__;
            }

            set => SetRotation(value);
        }

        /// <summary>
        /// <p>Gets a description of the swap chain.</p>
        /// </summary>
        /// <param name = "descRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.DXGI.SwapChainDescription1"/></strong> structure that describes the swap chain.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise.  For a list of error codes, see DXGI_ERROR.</p></returns>
        /// <doc-id>hh404640</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain1::GetDesc1([Out] DXGI_SWAP_CHAIN_DESC1* pDesc)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain1::GetDesc1</unmanaged-short>
        internal unsafe void GetDescription1(out SharpDX.DXGI.SwapChainDescription1 descRef)
        {
            descRef = default (SharpDX.DXGI.SwapChainDescription1);
            SharpDX.Result __result__;
            fixed (void *descRef_ = &descRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[18]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets a description of a full-screen swap chain.</p>
        /// </summary>
        /// <param name = "descRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.DXGI.SwapChainFullScreenDescription"/></strong> structure that describes the full-screen swap chain.</p> </dd></param>
        /// <returns><p><strong>GetFullscreenDesc</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if it successfully retrieved the description of the full-screen swap chain.</li> <li> <see cref = "InvalidCall"/> for non-<strong><see cref = "System.IntPtr"/></strong> swap chains or if <em>pDesc</em> is <strong><c>null</c></strong>.</li> <li>Possibly other error codes that are described in the DXGI_ERROR topic. </li> </ul></returns>
        /// <remarks>
        /// <p>The semantics of <strong>GetFullscreenDesc</strong> are identical to that of the <strong>IDXGISwapchain::GetDesc</strong> method for <strong><see cref = "System.IntPtr"/></strong>-based swap chains.</p>
        /// </remarks>
        /// <doc-id>hh404644</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain1::GetFullscreenDesc([Out] DXGI_SWAP_CHAIN_FULLSCREEN_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain1::GetFullscreenDesc</unmanaged-short>
        internal unsafe void GetFullscreenDescription(out SharpDX.DXGI.SwapChainFullScreenDescription descRef)
        {
            descRef = default (SharpDX.DXGI.SwapChainFullScreenDescription);
            SharpDX.Result __result__;
            fixed (void *descRef_ = &descRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the underlying <strong><see cref = "System.IntPtr"/></strong> for this swap-chain object.</p>
        /// </summary>
        /// <param name = "hwndRef">No documentation.</param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise.  For a list of error codes, see DXGI_ERROR.</p><p>If <em>pHwnd</em> receives <strong><c>null</c></strong> (that is, the swap chain is not <strong><see cref = "System.IntPtr"/></strong>-based), <strong>GetHwnd</strong> returns <see cref = "InvalidCall"/>.</p></returns>
        /// <remarks>
        /// <p>Applications call the  <strong>IDXGIFactory2::CreateSwapChainForHwnd</strong> method to create a swap chain that is associated with an <strong><see cref = "System.IntPtr"/></strong>.</p>
        /// </remarks>
        /// <doc-id>hh404647</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain1::GetHwnd([Out] HWND* pHwnd)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain1::GetHwnd</unmanaged-short>
        internal unsafe void GetHwnd(out System.IntPtr hwndRef)
        {
            SharpDX.Result __result__;
            fixed (void *hwndRef_ = &hwndRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, hwndRef_, (*(void ***)this._nativePointer)[20]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the underlying <strong>CoreWindow</strong> object for this swap-chain object.</p>
        /// </summary>
        /// <param name = "refiid">No documentation.</param>
        /// <param name = "unkOut">No documentation.</param>
        /// <returns><p><strong>GetCoreWindow</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if it successfully retrieved the underlying <strong>CoreWindow</strong> object.</li> <li> <see cref = "InvalidCall"/> if <em>ppUnk</em> is <strong><c>null</c></strong>; that is, the swap chain is not associated with a <strong>CoreWindow</strong> object.</li> <li>Any <strong><see cref = "SharpDX.Result"/></strong> that a call to <strong>QueryInterface</strong> to query for an <strong>CoreWindow</strong> object might typically return.</li> <li>Possibly other error codes that are described in the DXGI_ERROR topic. </li> </ul><p><strong>Platform Update for Windows?7:??</strong>On Windows?7 or Windows Server?2008?R2 with the Platform Update for Windows?7 installed, <strong>GetCoreWindow</strong> fails with E_NOTIMPL. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p></returns>
        /// <remarks>
        /// <p>Applications call the <strong>IDXGIFactory2::CreateSwapChainForCoreWindow</strong> method to create a swap chain that is associated with an <strong>CoreWindow</strong> object.</p>
        /// </remarks>
        /// <doc-id>hh404650</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain1::GetCoreWindow([In] const GUID&amp; refiid,[Out] void** ppUnk)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain1::GetCoreWindow</unmanaged-short>
        public unsafe void GetCoreWindow(System.Guid refiid, out System.IntPtr unkOut)
        {
            SharpDX.Result __result__;
            fixed (void *unkOut_ = &unkOut)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &refiid, unkOut_, (*(void ***)this._nativePointer)[21]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Presents a frame on the display screen. </p>
        /// </summary>
        /// <param name = "syncInterval"><dd> <p>An integer that specifies how to synchronize presentation of a frame with the vertical blank.</p> <p>For the bit-block transfer (bitblt) model (<strong>DXGI_SWAP_EFFECT_DISCARD</strong> or <strong>DXGI_SWAP_EFFECT_SEQUENTIAL</strong>), values are:</p> <ul> <li>0 - The presentation occurs immediately, there is no synchronization.</li> <li>1 through 4 - Synchronize presentation after the <em>n</em>th vertical blank.</li> </ul> <p>For the flip model (<strong>DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL</strong>), values are:</p> <ul> <li>0 - Cancel the remaining time on the previously presented frame and discard this frame if a newer frame is queued.</li> <li>1 through 4 - Synchronize presentation for at least <em>n</em> vertical blanks.</li> </ul> <p>For an example that shows how sync-interval values affect a flip presentation queue, see Remarks.</p> <p>If the update region straddles more than one output (each represented by <strong><see cref = "SharpDX.DXGI.Output1"/></strong>), <strong>Present1</strong> performs the synchronization to the output that contains the largest sub-rectangle of the target window's client area.</p> </dd></param>
        /// <param name = "presentFlags"><dd> <p>An integer value that contains swap-chain presentation options. These options are defined by the DXGI_PRESENT constants.</p> </dd></param>
        /// <param name = "presentParametersRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.DXGI.PresentParameters"/></strong> structure that describes updated rectangles and scroll information of the frame to present.</p> </dd></param>
        /// <returns><p>Possible return values include: <see cref = "SharpDX.Result.Ok"/>, <see cref = "DeviceRemoved"/> , DXGI_STATUS_OCCLUDED, <see cref = "InvalidCall"/>, or E_OUTOFMEMORY.  </p></returns>
        /// <remarks>
        /// <p>An app can use <strong>Present1</strong> to optimize presentation by specifying scroll and dirty rectangles. When the runtime has information about these rectangles, the runtime can then perform necessary bitblts during presentation more efficiently and pass this metadata to the Desktop Window Manager (DWM). The DWM can then use the metadata to optimize presentation and pass the metadata to indirect displays and terminal servers to optimize traffic over the wire. An app must confine its modifications to only the dirty regions that it passes to <strong>Present1</strong>, as well as modify the entire dirty region to avoid undefined resource contents from being exposed.</p><p>For flip presentation model swap chains that you create with the <strong>DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL</strong> value set, a successful presentation results in an unbind of back buffer 0 from the graphics pipeline, except for when you pass the <strong>DXGI_PRESENT_DO_NOT_SEQUENCE</strong> flag in the <em>Flags</em> parameter.</p><p>For info about how data values change when you present content to the screen, see Converting data for the color space.</p><p>For info about calling <strong>Present1</strong> when your app uses multiple threads, see Multithread Considerations and Multithreading and DXGI.</p>
        /// </remarks>
        /// <doc-id>hh446797</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain1::Present1([In] unsigned int SyncInterval,[In] unsigned int PresentFlags,[In] const DXGI_PRESENT_PARAMETERS* pPresentParameters)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain1::Present1</unmanaged-short>
        internal unsafe SharpDX.Result Present1(System.Int32 syncInterval, SharpDX.DXGI.PresentFlags presentFlags, System.IntPtr presentParametersRef)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, syncInterval, unchecked ((System.Int32)presentFlags), (void *)presentParametersRef, (*(void ***)this._nativePointer)[22]);
            __result__.CheckError();
            return __result__;
        }

        /// <summary>
        /// <p>Determines whether a swap chain supports ?temporary mono.?</p>
        /// </summary>
        /// <returns><p>Indicates whether to use the swap chain in temporary mono mode. <strong>TRUE</strong> indicates that you can use temporary-mono mode; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>.</p><p><strong>Platform Update for Windows?7:??</strong>On Windows?7 or Windows Server?2008?R2 with the Platform Update for Windows?7 installed, <strong>IsTemporaryMonoSupported</strong> always returns <see cref = "SharpDX.Result.False"/> because stereoscopic 3D display behavior isn?t available with the Platform Update for Windows?7. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p></returns>
        /// <remarks>
        /// <p>Temporary mono is a feature where a stereo swap chain can be presented using only the content in the left buffer.  To present using the left buffer as a mono buffer, an application calls the  <strong>IDXGISwapChain1::Present1</strong> method with the <strong>DXGI_PRESENT_STEREO_TEMPORARY_MONO</strong> flag.  All windowed swap chains support temporary mono. However, full-screen swap chains optionally support temporary mono because not all hardware supports temporary mono on full-screen swap chains efficiently.</p>
        /// </remarks>
        /// <doc-id>hh446794</doc-id>
        /// <unmanaged>BOOL IDXGISwapChain1::IsTemporaryMonoSupported()</unmanaged>
        /// <unmanaged-short>IDXGISwapChain1::IsTemporaryMonoSupported</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawBool IsTemporaryMonoSupported_()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[23]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the output (the display monitor) to which you can restrict the contents of a present operation.</p>
        /// </summary>
        /// <param name = "restrictToOutputOut"><dd> <p> A reference to a buffer that receives a reference to the <strong><see cref = "SharpDX.DXGI.Output"/></strong> interface for the restrict-to output. An application passes this reference to <strong><see cref = "SharpDX.DXGI.Output"/></strong> in a call to the  <strong>IDXGIFactory2::CreateSwapChainForHwnd</strong>, <strong>IDXGIFactory2::CreateSwapChainForCoreWindow</strong>, or  <strong>IDXGIFactory2::CreateSwapChainForComposition</strong> method to create the swap chain.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if the restrict-to output was successfully retrieved; otherwise, returns E_INVALIDARG if the reference is invalid.</p></returns>
        /// <remarks>
        /// <p>If the method succeeds, the runtime fills the buffer at <em>ppRestrictToOutput</em> with a reference to the restrict-to output interface. This restrict-to output interface has its reference count incremented. When you are finished with it, be sure to release the interface to avoid a memory leak.</p><p>The output is also owned by the adapter on which the swap chain's device was created.</p>
        /// </remarks>
        /// <doc-id>hh446788</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain1::GetRestrictToOutput([Out] IDXGIOutput** ppRestrictToOutput)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain1::GetRestrictToOutput</unmanaged-short>
        internal unsafe void GetRestrictToOutput(out SharpDX.DXGI.Output restrictToOutputOut)
        {
            System.IntPtr restrictToOutputOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &restrictToOutputOut_, (*(void ***)this._nativePointer)[24]);
            if (restrictToOutputOut_ != System.IntPtr.Zero)
                restrictToOutputOut = new SharpDX.DXGI.Output(restrictToOutputOut_);
            else
                restrictToOutputOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Changes the background color of the swap chain.</p>
        /// </summary>
        /// <param name = "colorRef"><dd> <p>A reference to a <strong>DXGI_RGBA</strong> structure that specifies the background color to set.</p> </dd></param>
        /// <returns><p><strong>SetBackgroundColor</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if it successfully set the background color.</li> <li>E_INVALIDARG if the <em>pColor</em> parameter is incorrect, for example, <em>pColor</em> is <c>null</c> or any of the floating-point values of the members of <strong>DXGI_RGBA</strong> to which <em>pColor</em> points are outside the range from 0.0 through 1.0.</li> <li>Possibly other error codes that are described in the DXGI_ERROR topic.</li> </ul><p><strong>Platform Update for Windows?7:??</strong>On Windows?7 or Windows Server?2008?R2 with the Platform Update for Windows?7 installed, <strong>SetBackgroundColor</strong> fails with E_NOTIMPL. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p></returns>
        /// <remarks>
        /// <p>The background color affects only swap chains that you create with <strong>DXGI_SCALING_NONE</strong> in windowed mode. You pass this value in a call to <strong>IDXGIFactory2::CreateSwapChainForHwnd</strong>, <strong>IDXGIFactory2::CreateSwapChainForCoreWindow</strong>, or  <strong>IDXGIFactory2::CreateSwapChainForComposition</strong>. Typically, the background color is not visible unless the swap-chain contents are smaller than the destination window.</p><p>When you set the background color, it is not immediately realized. It takes effect in conjunction with your next call to the <strong>IDXGISwapChain1::Present1</strong> method. The <strong>DXGI_PRESENT</strong> flags that you pass to <strong>IDXGISwapChain1::Present1</strong> can help achieve the effect that you require. For example, if you call <strong>SetBackgroundColor</strong> and then call <strong>IDXGISwapChain1::Present1</strong> with the <em>Flags</em> parameter set to <strong>DXGI_PRESENT_DO_NOT_SEQUENCE</strong>, you change only the background color without changing the displayed contents of the swap chain.</p><p>When you call the <strong>IDXGISwapChain1::Present1</strong> method to display contents of the swap chain, <strong>IDXGISwapChain1::Present1</strong> uses the <strong><see cref = "SharpDX.DXGI.AlphaMode"/></strong> value that is specified in the <strong>AlphaMode</strong> member of the <strong><see cref = "SharpDX.DXGI.SwapChainDescription1"/></strong> structure to determine how to handle the <strong>a</strong> member of the <strong>DXGI_RGBA</strong> structure, the alpha value of the background color, that achieves window transparency. For example, if <strong>AlphaMode</strong> is <strong>DXGI_ALPHA_MODE_IGNORE</strong>, <strong>IDXGISwapChain1::Present1</strong> ignores the a member of <strong>DXGI_RGBA</strong>.</p><strong>Note</strong>??Like all presentation data, we recommend that you perform floating point operations in a linear color space. When the desktop is in a fixed bit color depth mode, the operating system converts linear color data to standard RGB data (sRGB, gamma 2.2 corrected space) to compose to the screen. For more info, see Converting data for the color space.?
        /// </remarks>
        /// <doc-id>hh446799</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain1::SetBackgroundColor([In] const D3DCOLORVALUE* pColor)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain1::SetBackgroundColor</unmanaged-short>
        internal unsafe void SetBackgroundColor(SharpDX.Mathematics.Interop.RawColor4 colorRef)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, &colorRef, (*(void ***)this._nativePointer)[25]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the background color of the swap chain.</p>
        /// </summary>
        /// <param name = "colorRef"><dd> <p>A reference to a <strong>DXGI_RGBA</strong> structure that receives the background color of the swap chain.</p> </dd></param>
        /// <returns><p><strong>GetBackgroundColor</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if it successfully retrieves the background color.</li> <li> <see cref = "InvalidCall"/> if the <em>pColor</em> parameter is invalid, for example, <em>pColor</em> is <c>null</c>.</li> <li>Possibly other error codes that are described in the DXGI_ERROR topic.</li> </ul></returns>
        /// <remarks>
        /// <strong>Note</strong>??The background color that <strong>GetBackgroundColor</strong> retrieves does not indicate what the screen currently displays. The background color indicates what the screen will display with your next call to the <strong>IDXGISwapChain1::Present1</strong> method. The default value of the background color is black with full opacity: 0,0,0,1.?
        /// </remarks>
        /// <doc-id>hh404634</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain1::GetBackgroundColor([Out] D3DCOLORVALUE* pColor)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain1::GetBackgroundColor</unmanaged-short>
        internal unsafe void GetBackgroundColor(out SharpDX.Mathematics.Interop.RawColor4 colorRef)
        {
            colorRef = default (SharpDX.Mathematics.Interop.RawColor4);
            SharpDX.Result __result__;
            fixed (void *colorRef_ = &colorRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, colorRef_, (*(void ***)this._nativePointer)[26]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the rotation of the back buffers for the swap chain.</p>
        /// </summary>
        /// <param name = "rotation"><dd> <p>A <strong><see cref = "SharpDX.DXGI.DisplayModeRotation"/></strong>-typed value that specifies how to set the rotation of the back buffers for the swap chain.</p> </dd></param>
        /// <returns><p><strong>SetRotation</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if it successfully set the rotation.</li> <li><see cref = "InvalidCall"/> if the swap chain is bit-block transfer (bitblt) model. The swap chain must be flip model to successfully call <strong>SetRotation</strong>.</li> <li>Possibly other error codes that are described in the DXGI_ERROR topic.</li> </ul><p><strong>Platform Update for Windows?7:??</strong>On Windows?7 or Windows Server?2008?R2 with the Platform Update for Windows?7 installed, <strong>SetRotation</strong> fails with <see cref = "InvalidCall"/>. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p></returns>
        /// <remarks>
        /// <p>You can only use <strong>SetRotation</strong> to rotate the back buffers for flip-model swap chains that you present in windowed mode. </p><p><strong>SetRotation</strong> isn't supported for rotating the back buffers for flip-model swap chains that you present in full-screen mode. In this situation, <strong>SetRotation</strong> doesn't fail, but you must ensure that you specify no rotation (<strong>DXGI_MODE_ROTATION_IDENTITY</strong>) for the swap chain. Otherwise, when you call <strong>IDXGISwapChain1::Present1</strong> or <strong>IDXGISwapChain::Present</strong> to present a frame,  the presentation fails.</p>
        /// </remarks>
        /// <doc-id>hh446801</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain1::SetRotation([In] DXGI_MODE_ROTATION Rotation)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain1::SetRotation</unmanaged-short>
        internal unsafe void SetRotation(SharpDX.DXGI.DisplayModeRotation rotation)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)rotation), (*(void ***)this._nativePointer)[27]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the rotation of the back buffers for the swap chain.</p>
        /// </summary>
        /// <param name = "rotationRef"><dd> <p>A reference to a variable that receives a <strong><see cref = "SharpDX.DXGI.DisplayModeRotation"/></strong>-typed value that specifies the rotation of the back buffers for the swap chain.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise.  For a list of error codes, see DXGI_ERROR.</p><p><strong>Platform Update for Windows?7:??</strong>On Windows?7 or Windows Server?2008?R2 with the Platform Update for Windows?7 installed, <strong>GetRotation</strong> fails with <see cref = "InvalidCall"/>. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p></returns>
        /// <doc-id>hh446791</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain1::GetRotation([Out] DXGI_MODE_ROTATION* pRotation)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain1::GetRotation</unmanaged-short>
        internal unsafe void GetRotation(out SharpDX.DXGI.DisplayModeRotation rotationRef)
        {
            SharpDX.Result __result__;
            fixed (void *rotationRef_ = &rotationRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, rotationRef_, (*(void ***)this._nativePointer)[28]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("a8be2ac4-199f-4946-b331-79599fb98de7")]
    public partial class SwapChain2 : SharpDX.DXGI.SwapChain1
    {
        public SwapChain2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SwapChain2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SwapChain2(nativePtr);
        /// <summary>
        /// <p>Gets or sets the number of frames that the swap chain is allowed to queue for rendering.</p>
        /// </summary>
        /// <doc-id>dn268311</doc-id>
        /// <unmanaged>GetMaximumFrameLatency / SetMaximumFrameLatency</unmanaged>
        /// <unmanaged-short>GetMaximumFrameLatency</unmanaged-short>
        public System.Int32 MaximumFrameLatency
        {
            get
            {
                GetMaximumFrameLatency(out var __output__);
                return __output__;
            }

            set => SetMaximumFrameLatency(value);
        }

        /// <summary>
        /// <p>Returns a waitable handle that signals when the DXGI adapter has finished presenting a new frame.</p><p>Windows?8.1 introduces new APIs that allow lower-latency rendering by waiting  until the previous frame is presented to the display before drawing the next frame. To use this method, first create the DXGI swap chain with the <strong>DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT</strong> flag set, then call <strong>GetFrameLatencyWaitableObject</strong> to retrieve the waitable handle. Use the waitable handle with <strong>WaitForSingleObjectEx</strong> to synchronize rendering of each new frame with the end of the previous frame. For every frame it renders, the app should wait on this handle before starting any rendering operations. Note that this requirement includes the first frame the app renders with the swap chain. See the DirectXLatency sample.</p>
        /// </summary>
        /// <doc-id>dn268309</doc-id>
        /// <unmanaged>GetFrameLatencyWaitableObject</unmanaged>
        /// <unmanaged-short>GetFrameLatencyWaitableObject</unmanaged-short>
        public System.IntPtr FrameLatencyWaitableObject
        {
            get => GetFrameLatencyWaitableObject();
        }

        /// <summary>
        /// <p>Gets or sets the transform matrix that will be applied to a composition swap chain upon the next present. </p><p>Starting with Windows?8.1, Windows Store apps are able to place DirectX swap chain visuals in XAML pages using the <strong>SwapChainPanel</strong> element, which can be placed and sized arbitrarily. This exposes the DirectX swap chain visuals to touch scaling and translation scenarios using touch UI. The <strong>GetMatrixTransform</strong> and  <strong>SetMatrixTransform</strong> methods are used to synchronize scaling of the DirectX swap chain with its associated <strong>SwapChainPanel</strong> element. Only simple scale/translation elements in the matrix are allowed ? the call will fail if the matrix contains skew/rotation elements.</p>
        /// </summary>
        /// <doc-id>dn268310</doc-id>
        /// <unmanaged>GetMatrixTransform / SetMatrixTransform</unmanaged>
        /// <unmanaged-short>GetMatrixTransform</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawMatrix3x2 MatrixTransform
        {
            get
            {
                GetMatrixTransform(out var __output__);
                return __output__;
            }

            set => SetMatrixTransform(ref value);
        }

        /// <summary>
        /// <p>Sets the source region to be used for the swap chain.</p><p>Use <strong>SetSourceSize</strong> to specify the portion of the swap chain from which the operating system presents. This allows an effective resize without calling the more-expensive <strong>IDXGISwapChain::ResizeBuffers</strong> method. Prior to Windows?8.1, calling <strong>IDXGISwapChain::ResizeBuffers</strong> was the only way to resize the swap chain. The source rectangle is always defined by the region [0, 0, Width, Height].</p>
        /// </summary>
        /// <param name = "width">No documentation.</param>
        /// <param name = "height">No documentation.</param>
        /// <returns><p>This method can return:</p><ul> <li>E_INVALIDARG if one or more parameters exceed the size of the back buffer.</li> <li>Possibly other error codes that are described in the DXGI_ERROR topic.</li> </ul></returns>
        /// <doc-id>dn280409</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain2::SetSourceSize([In] unsigned int Width,[In] unsigned int Height)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain2::SetSourceSize</unmanaged-short>
        internal unsafe void SetSourceSize(System.Int32 width, System.Int32 height)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, width, height, (*(void ***)this._nativePointer)[29]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the source region used for the swap chain.</p><p>Use <strong>GetSourceSize</strong> to get the portion of the swap chain from which the operating system presents. The source rectangle is always defined by the region [0, 0, Width, Height]. Use <strong>SetSourceSize</strong> to set this portion of the swap chain. </p>
        /// </summary>
        /// <param name = "widthRef">No documentation.</param>
        /// <param name = "heightRef">No documentation.</param>
        /// <returns><p> This method can return error codes that are described in the DXGI_ERROR topic.</p></returns>
        /// <doc-id>dn280408</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain2::GetSourceSize([Out] unsigned int* pWidth,[Out] unsigned int* pHeight)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain2::GetSourceSize</unmanaged-short>
        internal unsafe void GetSourceSize(out System.Int32 widthRef, out System.Int32 heightRef)
        {
            SharpDX.Result __result__;
            fixed (void *heightRef_ = &heightRef)
                fixed (void *widthRef_ = &widthRef)
                    __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, widthRef_, heightRef_, (*(void ***)this._nativePointer)[30]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the number of frames that the swap chain is allowed to queue for rendering.</p>
        /// </summary>
        /// <param name = "maxLatency"><dd> <p>The maximum number of back buffer frames that will be queued for the swap chain. This value is 3 by default.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, <see cref = "DeviceRemoved"/> if the device was removed.</p></returns>
        /// <remarks>
        /// <p>This method is only valid for use on swap chains created with <strong>DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT</strong>. Otherwise, the result will be <see cref = "InvalidCall"/>.</p>
        /// </remarks>
        /// <doc-id>dn268313</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain2::SetMaximumFrameLatency([In] unsigned int MaxLatency)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain2::SetMaximumFrameLatency</unmanaged-short>
        internal unsafe void SetMaximumFrameLatency(System.Int32 maxLatency)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, maxLatency, (*(void ***)this._nativePointer)[31]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the number of frames that the swap chain is allowed to queue for rendering.</p>
        /// </summary>
        /// <param name = "maxLatencyRef"><dd> <p>The maximum number of back buffer frames that will be queued for the swap chain. This value is 1 by default, but should be set to 2 if the scene takes longer than it takes for one vertical refresh (typically about 16ms) to draw.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns one of the following members of the D3DERR enumerated type:</p><ul> <li><strong>D3DERR_DEVICELOST</strong></li> <li><strong>D3DERR_DEVICEREMOVED</strong></li> <li><strong>D3DERR_DRIVERINTERNALERROR</strong></li> <li><strong>D3DERR_INVALIDCALL</strong></li> <li><strong>D3DERR_OUTOFVIDEOMEMORY</strong></li> </ul></returns>
        /// <doc-id>dn268311</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain2::GetMaximumFrameLatency([Out] unsigned int* pMaxLatency)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain2::GetMaximumFrameLatency</unmanaged-short>
        internal unsafe void GetMaximumFrameLatency(out System.Int32 maxLatencyRef)
        {
            SharpDX.Result __result__;
            fixed (void *maxLatencyRef_ = &maxLatencyRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, maxLatencyRef_, (*(void ***)this._nativePointer)[32]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns a waitable handle that signals when the DXGI adapter has finished presenting a new frame.</p><p>Windows?8.1 introduces new APIs that allow lower-latency rendering by waiting  until the previous frame is presented to the display before drawing the next frame. To use this method, first create the DXGI swap chain with the <strong>DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT</strong> flag set, then call <strong>GetFrameLatencyWaitableObject</strong> to retrieve the waitable handle. Use the waitable handle with <strong>WaitForSingleObjectEx</strong> to synchronize rendering of each new frame with the end of the previous frame. For every frame it renders, the app should wait on this handle before starting any rendering operations. Note that this requirement includes the first frame the app renders with the swap chain. See the DirectXLatency sample.</p>
        /// </summary>
        /// <returns><p>A handle to the waitable object, or <c>null</c> if the swap chain was not created with <strong>DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT</strong>.</p></returns>
        /// <doc-id>dn268309</doc-id>
        /// <unmanaged>void* IDXGISwapChain2::GetFrameLatencyWaitableObject()</unmanaged>
        /// <unmanaged-short>IDXGISwapChain2::GetFrameLatencyWaitableObject</unmanaged-short>
        internal unsafe System.IntPtr GetFrameLatencyWaitableObject()
        {
            System.IntPtr __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallSystemIntPtr(this._nativePointer, (*(void ***)this._nativePointer)[33]);
            return __result__;
        }

        /// <summary>
        /// <p>Sets the transform matrix that will be applied to a composition swap chain upon the next present. </p><p>Starting with Windows?8.1, Windows Store apps are able to place DirectX swap chain visuals in XAML pages using the <strong>SwapChainPanel</strong> element, which can be placed and sized arbitrarily. This exposes the DirectX swap chain visuals to touch scaling and translation scenarios using touch UI. The <strong>GetMatrixTransform</strong> and  <strong>SetMatrixTransform</strong> methods are used to synchronize scaling of the DirectX swap chain with its associated <strong>SwapChainPanel</strong> element. Only simple scale/translation elements in the matrix are allowed ? the call will fail if the matrix contains skew/rotation elements.</p>
        /// </summary>
        /// <param name = "matrixRef">No documentation.</param>
        /// <returns><p><strong>SetMatrixTransform</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if it successfully retrieves the transform matrix.</li> <li>E_INVALIDARG if the <em>pMatrix</em> parameter is incorrect, for example, <em>pMatrix</em> is <c>null</c> or the matrix represented by <strong><see cref = "SharpDX.Mathematics.Interop.RawMatrix3x2"/></strong> includes components other than scale and translation.</li> <li><see cref = "InvalidCall"/> if the method is called on a swap chain that was not created with <strong>CreateSwapChainForComposition</strong>.</li> <li>Possibly other error codes that are described in the DXGI_ERROR topic.</li> </ul></returns>
        /// <doc-id>dn268312</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain2::SetMatrixTransform([In] const DXGI_MATRIX_3X2_F* pMatrix)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain2::SetMatrixTransform</unmanaged-short>
        internal unsafe void SetMatrixTransform(ref SharpDX.Mathematics.Interop.RawMatrix3x2 matrixRef)
        {
            SharpDX.Result __result__;
            fixed (void *matrixRef_ = &matrixRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, matrixRef_, (*(void ***)this._nativePointer)[34]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the transform matrix that will be applied to a composition swap chain upon the next present. </p><p>Starting with Windows?8.1, Windows Store apps are able to place DirectX swap chain visuals in XAML pages using the <strong>SwapChainPanel</strong> element, which can be placed and sized arbitrarily. This exposes the DirectX swap chain visuals to touch scaling and translation scenarios using touch UI. The <strong>GetMatrixTransform</strong> and  <strong>SetMatrixTransform</strong> methods are used to synchronize scaling of the DirectX swap chain with its associated <strong>SwapChainPanel</strong> element. Only simple scale/translation elements in the matrix are allowed ? the call will fail if the matrix contains skew/rotation elements.</p>
        /// </summary>
        /// <param name = "matrixRef">No documentation.</param>
        /// <returns><p><strong>GetMatrixTransform</strong> returns: </p><ul> <li><see cref = "SharpDX.Result.Ok"/> if it successfully retrieves the transform matrix.</li> <li><see cref = "InvalidCall"/> if the method is called on a swap chain that was not created with <strong>CreateSwapChainForComposition</strong>.</li> <li>Possibly other error codes that are described in the DXGI_ERROR topic.</li> </ul></returns>
        /// <doc-id>dn268310</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain2::GetMatrixTransform([Out] DXGI_MATRIX_3X2_F* pMatrix)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain2::GetMatrixTransform</unmanaged-short>
        internal unsafe void GetMatrixTransform(out SharpDX.Mathematics.Interop.RawMatrix3x2 matrixRef)
        {
            matrixRef = default (SharpDX.Mathematics.Interop.RawMatrix3x2);
            SharpDX.Result __result__;
            fixed (void *matrixRef_ = &matrixRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, matrixRef_, (*(void ***)this._nativePointer)[35]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("94d99bdb-f1f8-4ab0-b236-7da0170edab1")]
    public partial class SwapChain3 : SharpDX.DXGI.SwapChain2
    {
        public SwapChain3(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SwapChain3(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SwapChain3(nativePtr);
        /// <summary>
        /// <p>Gets the index of the swap chain's current back buffer.</p>
        /// </summary>
        /// <doc-id>dn903675</doc-id>
        /// <unmanaged>GetCurrentBackBufferIndex</unmanaged>
        /// <unmanaged-short>GetCurrentBackBufferIndex</unmanaged-short>
        public System.Int32 CurrentBackBufferIndex
        {
            get => GetCurrentBackBufferIndex();
        }

        /// <summary>
        /// <p>Sets the color space used by the swap chain.</p>
        /// </summary>
        /// <doc-id>dn903676</doc-id>
        /// <unmanaged>SetColorSpace1</unmanaged>
        /// <unmanaged-short>SetColorSpace1</unmanaged-short>
        public SharpDX.DXGI.ColorSpaceType ColorSpace1
        {
            set => SetColorSpace1(value);
        }

        /// <summary>
        /// <p>Gets the index of the swap chain's current back buffer.</p>
        /// </summary>
        /// <returns><p>Returns the index of the current back buffer.</p></returns>
        /// <doc-id>dn903675</doc-id>
        /// <unmanaged>unsigned int IDXGISwapChain3::GetCurrentBackBufferIndex()</unmanaged>
        /// <unmanaged-short>IDXGISwapChain3::GetCurrentBackBufferIndex</unmanaged-short>
        internal unsafe System.Int32 GetCurrentBackBufferIndex()
        {
            System.Int32 __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[36]);
            return __result__;
        }

        /// <summary>
        /// <p>Checks the swap chain's support for color space.</p>
        /// </summary>
        /// <param name = "colorSpace"><dd>  <p>A <strong><see cref = "SharpDX.DXGI.ColorSpaceType"/></strong>-typed value that specifies color space type to check support for.</p> </dd></param>
        /// <returns><dd>  <p>A reference to a variable that receives a combination of <strong><see cref = "SharpDX.DXGI.SwapChainColorSpaceSupportFlags"/></strong>-typed values that are combined by using a bitwise OR operation. The resulting value specifies options for color space support. </p> </dd></returns>
        /// <doc-id>dn903674</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain3::CheckColorSpaceSupport([In] DXGI_COLOR_SPACE_TYPE ColorSpace,[Out] unsigned int* pColorSpaceSupport)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain3::CheckColorSpaceSupport</unmanaged-short>
        public unsafe SharpDX.DXGI.SwapChainColorSpaceSupportFlags CheckColorSpaceSupport(SharpDX.DXGI.ColorSpaceType colorSpace)
        {
            SharpDX.DXGI.SwapChainColorSpaceSupportFlags colorSpaceSupportRef;
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)colorSpace), &colorSpaceSupportRef, (*(void ***)this._nativePointer)[37]);
            __result__.CheckError();
            return colorSpaceSupportRef;
        }

        /// <summary>
        /// <p>Sets the color space used by the swap chain.</p>
        /// </summary>
        /// <param name = "colorSpace"><dd>  <p>A <strong><see cref = "SharpDX.DXGI.ColorSpaceType"/></strong>-typed value that specifies the color space to set.</p> </dd></param>
        /// <returns><p>This method returns <strong><see cref = "SharpDX.Result.Ok"/></strong> on success, or it returns one of the error codes that are described in the DXGI_ERROR topic.</p></returns>
        /// <doc-id>dn903676</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain3::SetColorSpace1([In] DXGI_COLOR_SPACE_TYPE ColorSpace)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain3::SetColorSpace1</unmanaged-short>
        internal unsafe void SetColorSpace1(SharpDX.DXGI.ColorSpaceType colorSpace)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)colorSpace), (*(void ***)this._nativePointer)[38]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Changes the swap chain's back buffer size, format, and number of buffers, where the swap chain was created using a D3D12 command queue as an input device. This should be called when the application window is resized. </p>
        /// </summary>
        /// <param name = "bufferCount"><dd>  <p> The number of buffers in the swap chain (including all back and front buffers). This number can be different from the number of buffers with which you created the swap chain. This number can't be greater than <strong>DXGI_MAX_SWAP_CHAIN_BUFFERS</strong>. Set this number to zero to preserve the existing number of buffers in the swap chain. You can't specify less than two buffers for the flip presentation model. </p> </dd></param>
        /// <param name = "width"><dd>  <p> The new width of the back buffer.  If you specify zero, DXGI will use the width of the client area of the target window.  You can't specify the width as zero if you called the <strong>IDXGIFactory2::CreateSwapChainForComposition</strong> method to create the swap chain for a composition surface. </p> </dd></param>
        /// <param name = "height"><dd>  <p> The new height of the back buffer.  If you specify zero, DXGI will use the height of the client area of the target window.  You can't specify the height as zero if you called the <strong>IDXGIFactory2::CreateSwapChainForComposition</strong> method to create the swap chain for a composition surface. </p> </dd></param>
        /// <param name = "format"><dd>  <p> A <strong><see cref = "SharpDX.DXGI.Format"/></strong>-typed value for the new format of the back buffer.  Set this value to <strong>DXGI_FORMAT_UNKNOWN</strong> to preserve the existing format of the back buffer.  The flip presentation model supports a more restricted set of formats than the bit-block transfer (bitblt) model. </p> </dd></param>
        /// <param name = "swapChainFlags"><dd>  <p> A combination of <strong><see cref = "SharpDX.DXGI.SwapChainFlags"/></strong>-typed values that are combined by using a bitwise OR operation. The resulting value specifies options for swap-chain behavior. </p> </dd></param>
        /// <param name = "creationNodeMaskRef"><dd>  <p> An array of UINTs, of total size <em>BufferCount</em>, where the value indicates which node the back buffer should be created on. Buffers created using <strong>ResizeBuffers1</strong> with a non-null <em>pCreationNodeMask</em> array are visible to all nodes. </p> </dd></param>
        /// <param name = "presentQueueOut"><dd>  <p> An array of command queues (<strong><see cref = "SharpDX.Direct3D12.CommandQueue"/></strong> instances), of total size <em>BufferCount</em>. Each queue provided must match the corresponding creation node mask specified in the <em>pCreationNodeMask</em> array. When <strong>Present()</strong> is called, in addition to rotating to the next buffer for the next frame, the swapchain will also rotate through these command queues. This allows the app to control which queue requires synchronization for a given present operation. </p> </dd></param>
        /// <returns><p> Returns <see cref = "SharpDX.Result.Ok"/> if successful; an error code otherwise. For a list of error codes, see DXGI_ERROR. </p></returns>
        /// <remarks>
        /// <p> This method is only valid to call when the swapchain was created using a D3D12 command queue (<strong><see cref = "SharpDX.Direct3D12.CommandQueue"/></strong>) as an input device. </p><p> When a swapchain is created on a multi-GPU adapter, the backbuffers are all created on node 1 and only a single command queue is supported. <strong>ResizeBuffers1</strong> enables applications to create backbuffers on different nodes, allowing a different command queue to be used with each node. These capabilities enable Alternate Frame Rendering (AFR) techniques to be used with the swapchain. See Direct3D 12 Multi-Adapters. </p><p> The only difference between <strong>IDXGISwapChain::ResizeBuffers</strong> in Windows?8 versus Windows?7 is with flip presentation model swap chains that you create with the <strong>DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL</strong> or DXGI_SWAP_EFFECT_FLIP_DISCARD value set. In Windows?8, you must call <strong>ResizeBuffers</strong> to realize a transition between full-screen mode and windowed mode; otherwise, your next call to the <strong>IDXGISwapChain::Present</strong> method fails. </p><p> Also see the Remarks section in <strong>IDXGISwapChain::ResizeBuffers</strong>, all of which is relevant to <strong>ResizeBuffers1</strong>. </p>
        /// </remarks>
        /// <doc-id>mt403341</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain3::ResizeBuffers1([In] unsigned int BufferCount,[In] unsigned int Width,[In] unsigned int Height,[In] DXGI_FORMAT Format,[In] unsigned int SwapChainFlags,[In, Buffer] const unsigned int* pCreationNodeMask,[In, Buffer] const IUnknown** ppPresentQueue)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain3::ResizeBuffers1</unmanaged-short>
        public unsafe void ResizeBuffers1(System.Int32 bufferCount, System.Int32 width, System.Int32 height, SharpDX.DXGI.Format format, SharpDX.DXGI.SwapChainFlags swapChainFlags, System.Int32[] creationNodeMaskRef, SharpDX.IUnknown[] presentQueueOut)
        {
            System.IntPtr*presentQueueOut_;
            presentQueueOut_ = (System.IntPtr*)0;
            if (presentQueueOut != null)
            {
                System.IntPtr*_presentQueueOut = stackalloc System.IntPtr[presentQueueOut.Length];
                presentQueueOut_ = _presentQueueOut;
            }

            SharpDX.Result __result__;
            if (presentQueueOut != null)
                for (int i = 0; i < presentQueueOut.Length; ++i)
                    (presentQueueOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(presentQueueOut[i]);
            fixed (void *creationNodeMaskRef_ = creationNodeMaskRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, bufferCount, width, height, unchecked ((System.Int32)format), unchecked ((System.Int32)swapChainFlags), creationNodeMaskRef_, (void *)presentQueueOut_, (*(void ***)this._nativePointer)[39]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("3D585D5A-BD4A-489E-B1F4-3DBCB6452FFB")]
    public partial class SwapChain4 : SharpDX.DXGI.SwapChain3
    {
        public SwapChain4(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SwapChain4(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SwapChain4(nativePtr);
        /// <summary>
        /// <p>This method sets High Dynamic Range (HDR) and Wide Color Gamut (WCG)  header metadata.</p>
        /// </summary>
        /// <param name = "type"><dd>  <p>Specifies one member of the  <strong><see cref = "SharpDX.DXGI.HdrMetadataType"/></strong> enum.</p> </dd></param>
        /// <param name = "size"><dd>  <p>Specifies the size of <em>pMetaData</em>, in bytes.</p> </dd></param>
        /// <param name = "metaDataRef"><dd>  <p>Specifies a void reference that references the metadata, if it exists. Refer to the <strong><see cref = "SharpDX.DXGI.HdrMetadataHdr10"/></strong> structure.</p> </dd></param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code.</p></returns>
        /// <remarks>
        /// <p>This method sets metadata to enable a monitor's output to be adjusted depending on its capabilities.</p>
        /// </remarks>
        /// <doc-id>mt732708</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChain4::SetHDRMetaData([In] DXGI_HDR_METADATA_TYPE Type,[In] unsigned int Size,[In, Buffer, Optional] void* pMetaData)</unmanaged>
        /// <unmanaged-short>IDXGISwapChain4::SetHDRMetaData</unmanaged-short>
        public unsafe void SetHDRMetaData(SharpDX.DXGI.HdrMetadataType type, System.Int32 size, System.IntPtr metaDataRef)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)type), size, (void *)metaDataRef, (*(void ***)this._nativePointer)[40]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("dd95b90b-f05f-4f6a-bd65-25bfb264bd84")]
    public partial class SwapChainMedia : SharpDX.ComObject
    {
        public SwapChainMedia(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SwapChainMedia(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SwapChainMedia(nativePtr);
        /// <summary>
        /// <p>Queries the system for a  <strong><see cref = "SharpDX.DXGI.FrameStatisticsMedia"/></strong> structure that indicates whether a custom refresh rate is currently approved by the system.</p>
        /// </summary>
        /// <doc-id>dn384133</doc-id>
        /// <unmanaged>GetFrameStatisticsMedia</unmanaged>
        /// <unmanaged-short>GetFrameStatisticsMedia</unmanaged-short>
        public SharpDX.DXGI.FrameStatisticsMedia FrameStatisticsMedia
        {
            get
            {
                GetFrameStatisticsMedia(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Requests a custom presentation duration (custom refresh rate).</p>
        /// </summary>
        /// <doc-id>dn384134</doc-id>
        /// <unmanaged>SetPresentDuration</unmanaged>
        /// <unmanaged-short>SetPresentDuration</unmanaged-short>
        public System.Int32 PresentDuration
        {
            set => SetPresentDuration(value);
        }

        /// <summary>
        /// <p>Queries the system for a  <strong><see cref = "SharpDX.DXGI.FrameStatisticsMedia"/></strong> structure that indicates whether a custom refresh rate is currently approved by the system.</p>
        /// </summary>
        /// <param name = "statsRef">No documentation.</param>
        /// <returns><p>This method returns <see cref = "SharpDX.Result.Ok"/> on success, or a DXGI error code on failure.</p></returns>
        /// <doc-id>dn384133</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChainMedia::GetFrameStatisticsMedia([Out] DXGI_FRAME_STATISTICS_MEDIA* pStats)</unmanaged>
        /// <unmanaged-short>IDXGISwapChainMedia::GetFrameStatisticsMedia</unmanaged-short>
        internal unsafe void GetFrameStatisticsMedia(out SharpDX.DXGI.FrameStatisticsMedia statsRef)
        {
            statsRef = default (SharpDX.DXGI.FrameStatisticsMedia);
            SharpDX.Result __result__;
            fixed (void *statsRef_ = &statsRef)
                __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, statsRef_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Requests a custom presentation duration (custom refresh rate).</p>
        /// </summary>
        /// <param name = "duration"><dd> <p>The custom presentation duration, specified in hundreds of nanoseconds.</p> </dd></param>
        /// <returns><p>This method returns <see cref = "SharpDX.Result.Ok"/> on success, or a DXGI error code on failure.</p></returns>
        /// <doc-id>dn384134</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChainMedia::SetPresentDuration([In] unsigned int Duration)</unmanaged>
        /// <unmanaged-short>IDXGISwapChainMedia::SetPresentDuration</unmanaged-short>
        internal unsafe void SetPresentDuration(System.Int32 duration)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, duration, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Queries the graphics driver for a supported frame present duration corresponding to a custom refresh rate.</p>
        /// </summary>
        /// <param name = "desiredPresentDuration"><dd> <p>Indicates the frame duration to check. This value is the duration of one frame at the desired refresh rate, specified in hundreds of nanoseconds. For example, set this field to 167777 to check for 60 Hz refresh rate support.</p> </dd></param>
        /// <param name = "closestSmallerPresentDurationRef"><dd> <p>A variable that will be set to the closest supported frame present duration that's smaller than the requested value, or zero if the device does not support any lower duration.</p> </dd></param>
        /// <param name = "closestLargerPresentDurationRef"><dd> <p>A variable that will be set to the closest supported frame present duration that's larger than the requested value, or zero if the device does not support any higher duration.</p> </dd></param>
        /// <returns><p>This method returns <see cref = "SharpDX.Result.Ok"/> on success, or a DXGI error code on failure.</p></returns>
        /// <remarks>
        /// <p>If the DXGI output adapter does not support custom refresh rates (for example, an external display) then the display driver will set upper and lower bounds to (0, 0).</p>
        /// </remarks>
        /// <doc-id>dn384132</doc-id>
        /// <unmanaged>HRESULT IDXGISwapChainMedia::CheckPresentDurationSupport([In] unsigned int DesiredPresentDuration,[Out] unsigned int* pClosestSmallerPresentDuration,[Out] unsigned int* pClosestLargerPresentDuration)</unmanaged>
        /// <unmanaged-short>IDXGISwapChainMedia::CheckPresentDurationSupport</unmanaged-short>
        public unsafe void CheckPresentDurationSupport(System.Int32 desiredPresentDuration, out System.Int32 closestSmallerPresentDurationRef, out System.Int32 closestLargerPresentDurationRef)
        {
            SharpDX.Result __result__;
            fixed (void *closestLargerPresentDurationRef_ = &closestLargerPresentDurationRef)
                fixed (void *closestSmallerPresentDurationRef_ = &closestSmallerPresentDurationRef)
                    __result__ = SharpDX.DXGI.LocalInterop.CalliStdCallint(this._nativePointer, desiredPresentDuration, closestSmallerPresentDurationRef_, closestLargerPresentDurationRef_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }
    }
}