// <auto-generated/>

namespace SharpDX.Win32
{
    [System.Runtime.InteropServices.GuidAttribute("0000000c-0000-0000-C000-000000000046")]
    public partial class ComStream : SharpDX.Win32.ComStreamBase, SharpDX.Win32.IStream
    {
        public ComStream(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ComStream(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ComStream(nativePtr);
        /// <summary>
        /// <p> The <strong>Seek</strong> method changes the seek reference to a new location.  The new location is relative to either the beginning of the stream, the end of the stream, or the current seek reference.</p>
        /// </summary>
        /// <param name = "dlibMove"><dd> <p>The displacement to be added to the location indicated by the <em>dwOrigin</em> parameter. If <em>dwOrigin</em> is <strong>STREAM_SEEK_SET</strong>, this is interpreted as an unsigned value rather than a signed value.</p> </dd></param>
        /// <param name = "dwOrigin"><dd> <p>The origin for the displacement specified in <em>dlibMove</em>. The origin can be the beginning of the file (<strong>STREAM_SEEK_SET</strong>), the current seek reference (<strong>STREAM_SEEK_CUR</strong>), or the end of the file (<strong>STREAM_SEEK_END</strong>). For more information about values, see the <strong>STREAM_SEEK</strong> enumeration.</p> </dd></param>
        /// <returns><dd> <p>A reference to the location where this method writes the value of the new seek reference from the beginning of the stream. </p> <p>You can set this reference to <strong><c>null</c></strong>. In this case, this method does not provide the new seek reference.</p> </dd></returns>
        /// <remarks>
        /// <p><strong>IStream::Seek</strong> changes the seek reference so that subsequent read and write operations can be performed at a different location in the stream object. It is an error to seek before the beginning of the stream. It is not, however, an error to seek past the end of the stream. Seeking past the end of the stream is useful for subsequent write operations, as the stream byte range will be extended to the new seek position immediately before the write is complete.</p><p>You can also use this method to obtain the current value of the seek reference by calling this method with the <em>dwOrigin</em> parameter set to <strong>STREAM_SEEK_CUR</strong> and the <em>dlibMove</em> parameter set to 0 so that the seek reference is not changed. The current seek reference is returned in the <em>plibNewPosition</em> parameter.</p>
        /// </remarks>
        /// <doc-id>aa380043</doc-id>
        /// <unmanaged>HRESULT IStream::Seek([In] LARGE_INTEGER dlibMove,[In] DWORD dwOrigin,[Out, Optional] ULARGE_INTEGER* plibNewPosition)</unmanaged>
        /// <unmanaged-short>IStream::Seek</unmanaged-short>
        public unsafe System.Int64 Seek(System.Int64 dlibMove, System.IO.SeekOrigin dwOrigin)
        {
            System.Int64 libNewPositionRef;
            SharpDX.Result __result__;
            __result__ = SharpDX.LocalInterop.CalliStdCallint(this._nativePointer, dlibMove, unchecked ((System.UInt32)dwOrigin), &libNewPositionRef, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
            return libNewPositionRef;
        }

        /// <summary>
        /// <p>The <strong>SetSize</strong> method changes the size of the stream object.</p>
        /// </summary>
        /// <param name = "libNewSize"><dd> <p>Specifies the new size, in bytes, of the stream.</p> </dd></param>
        /// <returns><p>This method can return one of these values.</p><dl> <dt><strong><see cref = "SharpDX.Result.Ok"/></strong></dt> <dd> <p>The size of the stream object was successfully changed.</p> </dd> <dt><strong>E_PENDING</strong></dt> <dd> <p>Asynchronous Storage only: Part or all of the stream's data is currently unavailable. For more information, see <strong>IFillLockBytes</strong> and Asynchronous Storage.</p> </dd> <dt><strong>STG_E_MEDIUMFULL</strong></dt> <dd> <p>The stream size is not changed because there is no space left on the storage device.</p> </dd> <dt><strong>STG_E_INVALIDFUNCTION</strong></dt> <dd> <p>The value of the <em>libNewSize</em> parameter is not supported by the implementation. Not all streams support greater than 2?? bytes. If a stream does not support more than 2?? bytes, the high <strong><see cref = "System.Int32"/></strong> data type of <em>libNewSize</em> must be zero. If it is nonzero, the implementation may return STG_E_INVALIDFUNCTION. In general, COM-based implementations of the  <strong><see cref = "SharpDX.Win32.IStream"/></strong> interface do not support streams larger than 2?? bytes.</p> </dd> <dt><strong>STG_E_REVERTED</strong></dt> <dd> <p>The object has been invalidated by a revert operation above it in the transaction tree.</p> </dd> </dl></returns>
        /// <remarks>
        /// <p><strong>IStream::SetSize</strong> changes the size of the stream object. Call this method to preallocate space for the stream. If the <em>libNewSize</em> parameter is larger than the current stream size, the stream is extended to the indicated size by filling the intervening space with bytes of undefined value. This operation is similar to the 
        /// <strong>ISequentialStream::Write</strong> method if the seek reference is past the current end of the stream.</p><p>If the <em>libNewSize</em> parameter is smaller than the current stream, the stream is truncated to the indicated size.</p><p>The seek reference is not affected by the change in stream size.</p><p>Calling <strong>IStream::SetSize</strong> can be an effective way to obtain a large chunk of contiguous space.</p>
        /// </remarks>
        /// <doc-id>aa380044</doc-id>
        /// <unmanaged>HRESULT IStream::SetSize([In] ULARGE_INTEGER libNewSize)</unmanaged>
        /// <unmanaged-short>IStream::SetSize</unmanaged-short>
        public unsafe void SetSize(System.Int64 libNewSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.LocalInterop.CalliStdCallint(this._nativePointer, libNewSize, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>The <strong>CopyTo</strong> method copies a specified number of bytes from the current seek reference in the stream to the current seek reference in another stream.</p>
        /// </summary>
        /// <param name = "stmRef"><dd> <p>A reference to the destination stream. The stream pointed to by <em>pstm</em> can be a new stream or a clone of the source stream.</p> </dd></param>
        /// <param name = "cb"><dd> <p>The number of bytes to copy from the source stream.</p> </dd></param>
        /// <param name = "cbWrittenRef"><dd> <p>A reference to the location where this method writes the actual number of bytes written to the destination. You can set this reference to <strong><c>null</c></strong>. In this case, this method does not provide the actual number of bytes written.</p> </dd></param>
        /// <returns><dd> <p>A reference to the location where this method writes the actual number of bytes read from the source. You can set this reference to <strong><c>null</c></strong>. In this case, this method does not provide the actual number of bytes read.</p> </dd></returns>
        /// <remarks>
        /// <p>The <strong>CopyTo</strong> method copies the specified bytes from one stream to another. It can also be used to copy a stream to itself. The seek reference in each stream instance is adjusted for the number of bytes read or written. This method is equivalent to reading <em>cb</em> bytes into memory using 
        /// <strong>ISequentialStream::Read</strong> and then immediately writing them to the destination stream using 
        /// <strong>ISequentialStream::Write</strong>, although <strong>IStream::CopyTo</strong> will be more efficient.</p><p>The destination stream can be a clone of the source stream created by calling the 
        /// <strong>IStream::Clone</strong> method.</p><p>If <strong>IStream::CopyTo</strong> returns an error, you cannot assume that the seek references are valid for either the source or destination. Additionally, the values of <em>pcbRead</em> and <em>pcbWritten</em> are not meaningful even though they are returned.</p><p>If <strong>IStream::CopyTo</strong> returns successfully, the actual number of bytes read and written are the same.</p><p>To copy the remainder of the source from the current seek reference, specify the maximum large integer value for the <em>cb</em> parameter. If the seek reference is the beginning of the stream, this operation copies the entire stream.</p>
        /// </remarks>
        /// <doc-id>aa380038</doc-id>
        /// <unmanaged>HRESULT IStream::CopyTo([In] IStream* pstm,[In] ULARGE_INTEGER cb,[Out] ULARGE_INTEGER* pcbRead,[Out] ULARGE_INTEGER* pcbWritten)</unmanaged>
        /// <unmanaged-short>IStream::CopyTo</unmanaged-short>
        public unsafe System.Int64 CopyTo(SharpDX.Win32.IStream stmRef, System.Int64 cb, out System.Int64 cbWrittenRef)
        {
            System.IntPtr stmRef_ = System.IntPtr.Zero;
            System.Int64 cbReadRef;
            SharpDX.Result __result__;
            stmRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Win32.IStream>(stmRef);
            fixed (void *cbWrittenRef_ = &cbWrittenRef)
                __result__ = SharpDX.LocalInterop.CalliStdCallint(this._nativePointer, (void *)stmRef_, cb, &cbReadRef, cbWrittenRef_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
            return cbReadRef;
        }

        /// <summary>
        /// <p>The <strong>Commit</strong> method ensures that any changes made to a stream object open in transacted mode are reflected in the parent storage. If the stream object is open in direct mode, <strong>IStream::Commit</strong> has no effect other than flushing all memory buffers to the next-level storage object. The COM compound file implementation of streams does not support opening streams in transacted mode.</p>
        /// </summary>
        /// <param name = "grfCommitFlags"><dd> <p>Controls how the changes for the stream object are committed. See the <strong><see cref = "SharpDX.Win32.CommitFlags"/></strong> enumeration for a definition of these values.</p> </dd></param>
        /// <returns><p>This method can return one of these values.</p><dl> <dt><strong><see cref = "SharpDX.Result.Ok"/></strong></dt> <dd> <p>Changes to the stream object were successfully committed to the parent level.</p> </dd> <dt><strong>E_PENDING</strong></dt> <dd> <p>Asynchronous Storage only: Part or all of the stream's data is currently unavailable. For more information see <strong>IFillLockBytes</strong> and Asynchronous Storage.</p> </dd> <dt><strong>STG_E_MEDIUMFULL</strong></dt> <dd> <p>The commit operation failed due to lack of space on the storage device.</p> </dd> <dt><strong>STG_E_REVERTED</strong></dt> <dd> <p>The object has been invalidated by a revert operation above it in the transaction tree.</p> </dd> </dl></returns>
        /// <remarks>
        /// <p>The <strong>Commit</strong> method ensures that changes to a stream object opened in transacted mode are reflected in the parent storage. Changes that have been made to the stream since it was opened or last committed are reflected to the parent storage object. If the parent is opened in transacted mode, the parent may revert at a later time, rolling back the changes to this stream object. The compound file implementation does not support the opening of streams in transacted mode, so this method has very little effect other than to flush memory buffers. For more information, see 
        /// <see cref = "SharpDX.Win32.IStream"/> - Compound File Implementation.</p><p>If the stream is open in direct mode, this method ensures that any memory buffers have been flushed out to the underlying storage object. This is much like a flush in traditional file systems.</p><p>The <strong>IStream::Commit</strong> method is useful on a direct mode stream when the implementation of the 
        /// <strong><see cref = "SharpDX.Win32.IStream"/></strong> interface is a wrapper for underlying file system APIs. In this case, <strong>IStream::Commit</strong> would be connected to the file system's flush call.</p>
        /// </remarks>
        /// <doc-id>aa380036</doc-id>
        /// <unmanaged>HRESULT IStream::Commit([In] DWORD grfCommitFlags)</unmanaged>
        /// <unmanaged-short>IStream::Commit</unmanaged-short>
        public unsafe void Commit(SharpDX.Win32.CommitFlags grfCommitFlags)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)grfCommitFlags), (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>The <strong>Revert</strong> method discards all changes that have been made to a transacted stream since the last 
        /// <strong>IStream::Commit</strong> call. On streams open in direct mode and streams using the COM compound file implementation of <strong>IStream::Revert</strong>, this method has no effect.</p>
        /// </summary>
        /// <returns><p>This method can return one of these values.</p><dl> <dt><strong><see cref = "SharpDX.Result.Ok"/></strong></dt> <dd> <p>The stream was successfully reverted to its previous version.</p> </dd> <dt><strong>E_PENDING</strong></dt> <dd> <p>Asynchronous Storage only: Part or all of the stream's data is currently unavailable. For more information see <strong>IFillLockBytes</strong> and Asynchronous Storage.</p> </dd> </dl></returns>
        /// <remarks>
        /// <p>The <strong>Revert</strong> method discards changes made to a transacted stream since the last commit operation.</p>
        /// </remarks>
        /// <doc-id>aa380042</doc-id>
        /// <unmanaged>HRESULT IStream::Revert()</unmanaged>
        /// <unmanaged-short>IStream::Revert</unmanaged-short>
        public unsafe void Revert()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "libOffset">No documentation.</param>
        /// <param name = "cb">No documentation.</param>
        /// <param name = "dwLockType">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT IStream::LockRegion([In] ULARGE_INTEGER libOffset,[In] ULARGE_INTEGER cb,[In] DWORD dwLockType)</unmanaged>
        /// <unmanaged-short>IStream::LockRegion</unmanaged-short>
        public unsafe void LockRegion(System.Int64 libOffset, System.Int64 cb, SharpDX.Win32.LockType dwLockType)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.LocalInterop.CalliStdCallint(this._nativePointer, libOffset, cb, unchecked ((System.Int32)dwLockType), (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "libOffset">No documentation.</param>
        /// <param name = "cb">No documentation.</param>
        /// <param name = "dwLockType">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT IStream::UnlockRegion([In] ULARGE_INTEGER libOffset,[In] ULARGE_INTEGER cb,[In] DWORD dwLockType)</unmanaged>
        /// <unmanaged-short>IStream::UnlockRegion</unmanaged-short>
        public unsafe void UnlockRegion(System.Int64 libOffset, System.Int64 cb, SharpDX.Win32.LockType dwLockType)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.LocalInterop.CalliStdCallint(this._nativePointer, libOffset, cb, unchecked ((System.Int32)dwLockType), (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> The <strong>Stat</strong> method retrieves the 
        /// <strong><see cref = "SharpDX.Win32.StorageStatistics"/></strong> structure for this stream.</p>
        /// </summary>
        /// <param name = "grfStatFlag">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <remarks>
        /// <p><strong>IStream::Stat</strong> retrieves a reference to the 
        /// <strong><see cref = "SharpDX.Win32.StorageStatistics"/></strong> structure that contains information about this open stream. When this stream is within a structured storage and 
        /// <strong>IStorage::EnumElements</strong> is called, it creates an enumerator object with the 
        /// <strong>IEnumSTATSTG</strong> interface on it, which can be called to enumerate the storages and streams through the 
        /// <strong><see cref = "SharpDX.Win32.StorageStatistics"/></strong> structures associated with each of them.</p>
        /// </remarks>
        /// <doc-id>aa380045</doc-id>
        /// <unmanaged>HRESULT IStream::Stat([Out] STATSTG* pstatstg,[In] DWORD grfStatFlag)</unmanaged>
        /// <unmanaged-short>IStream::Stat</unmanaged-short>
        public unsafe SharpDX.Win32.StorageStatistics GetStatistics(SharpDX.Win32.StorageStatisticsFlags grfStatFlag)
        {
            SharpDX.Win32.StorageStatistics statstgRef;
            SharpDX.Win32.StorageStatistics.__Native statstgRef_ = default (SharpDX.Win32.StorageStatistics.__Native);
            statstgRef = default (SharpDX.Win32.StorageStatistics);
            SharpDX.Result __result__;
            __result__ = SharpDX.LocalInterop.CalliStdCallint(this._nativePointer, &statstgRef_, unchecked ((System.Int32)grfStatFlag), (*(void ***)this._nativePointer)[12]);
            statstgRef.__MarshalFrom(ref statstgRef_);
            __result__.CheckError();
            return statstgRef;
        }

        /// <summary>
        /// <p> The <strong>Clone</strong> method creates a new stream object with its own seek reference that references the same bytes as the original stream.</p>
        /// </summary>
        /// <returns><dd> <p>When successful, reference to the location of an <strong><see cref = "SharpDX.Win32.IStream"/></strong> reference to the new stream object. If an error occurs, this parameter is <strong><c>null</c></strong>.</p> </dd></returns>
        /// <remarks>
        /// <p>The <strong>Clone</strong> method creates a new stream object for accessing the same bytes but using a separate seek reference. The new stream object sees the same data as the source-stream object. Changes written to one object are immediately visible in the other. Range locking is shared between the stream objects.</p><p>The initial setting of the seek reference in the cloned stream instance is the same as the current setting of the seek reference in the original stream at the time of the clone operation.</p>
        /// </remarks>
        /// <doc-id>aa380035</doc-id>
        /// <unmanaged>HRESULT IStream::Clone([Out] IStream** ppstm)</unmanaged>
        /// <unmanaged-short>IStream::Clone</unmanaged-short>
        public unsafe SharpDX.Win32.IStream Clone()
        {
            SharpDX.Win32.IStream stmOut;
            System.IntPtr stmOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.LocalInterop.CalliStdCallint(this._nativePointer, &stmOut_, (*(void ***)this._nativePointer)[13]);
            if (stmOut_ != System.IntPtr.Zero)
                stmOut = new SharpDX.Win32.ComStream(stmOut_);
            else
                stmOut = null;
            __result__.CheckError();
            return stmOut;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("0c733a30-2a1c-11ce-ade5-00aa0044773d")]
    public partial class ComStreamBase : SharpDX.ComObject, SharpDX.Win32.IStreamBase
    {
        public ComStreamBase(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ComStreamBase(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ComStreamBase(nativePtr);
        /// <summary>
        /// <p>Reads a specified number of bytes from the stream object into memory starting at the current read/write location within the stream.</p>
        /// </summary>
        /// <param name = "vRef"><dd><p>[in]Points to the buffer into which the stream is read. If an error occurs, this value is <c>null</c>.</p></dd></param>
        /// <param name = "cb"><dd><p>[in]Specifies the number of bytes of data to attempt to read from the stream object.</p></dd></param>
        /// <returns><dd><p>[out]Pointer to a location where this method writes the actual number of bytes read from the stream object. You can set this reference to <c>null</c> to indicate that you are not interested in this value. In this case, this method does not provide the actual number of bytes read.</p></dd></returns>
        /// <doc-id>ms713642</doc-id>
        /// <unmanaged>HRESULT ISequentialStream::Read([Out, Buffer] void* pv,[In] ULONG cb,[Out, Optional] ULONG* pcbRead)</unmanaged>
        /// <unmanaged-short>ISequentialStream::Read</unmanaged-short>
        public unsafe System.Int32 Read(System.IntPtr vRef, System.Int32 cb)
        {
            System.Int32 cbReadRef;
            SharpDX.Result __result__;
            __result__ = SharpDX.LocalInterop.CalliStdCallint(this._nativePointer, (void *)vRef, cb, &cbReadRef, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
            return cbReadRef;
        }

        /// <summary>
        /// <p>Writes a specified number of bytes into the stream object starting at the current read/write location within the stream.</p>
        /// </summary>
        /// <param name = "vRef"><dd><p>[in] Points to the buffer into which the stream should be written.</p></dd></param>
        /// <param name = "cb"><dd><p>[in] The number of bytes of data to attempt to write into the stream.</p></dd></param>
        /// <returns><dd><p>[out] Pointer to a location where this method writes the actual number of bytes written to the stream object. The caller can set this reference to <c>null</c>, in which case this method does not provide the actual number of bytes written.</p></dd></returns>
        /// <doc-id>ms711215</doc-id>
        /// <unmanaged>HRESULT ISequentialStream::Write([In, Buffer] const void* pv,[In] ULONG cb,[Out, Optional] ULONG* pcbWritten)</unmanaged>
        /// <unmanaged-short>ISequentialStream::Write</unmanaged-short>
        public unsafe System.Int32 Write(System.IntPtr vRef, System.Int32 cb)
        {
            System.Int32 cbWrittenRef;
            SharpDX.Result __result__;
            __result__ = SharpDX.LocalInterop.CalliStdCallint(this._nativePointer, (void *)vRef, cb, &cbWrittenRef, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
            return cbWrittenRef;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("0000000c-0000-0000-C000-000000000046")]
    public partial interface IStream : SharpDX.Win32.IStreamBase
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("0c733a30-2a1c-11ce-ade5-00aa0044773d")]
    public partial interface IStreamBase : SharpDX.IUnknown
    {
    }
}