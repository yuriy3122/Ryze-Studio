// <auto-generated/>

namespace SharpDX.Direct3D11
{
    /// <summary>
    /// <p>Contains an initialization vector (IV) for 128-bit Advanced Encryption Standard CTR mode (AES-CTR) block cipher encryption. </p>
    /// </summary>
    /// <doc-id>hh447597</doc-id>
    /// <unmanaged>D3D11_AES_CTR_IV</unmanaged>
    /// <unmanaged-short>D3D11_AES_CTR_IV</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct AesCtrIv
    {
        /// <summary>
        /// <dd> <p>The IV, in big-endian format.</p> </dd>
        /// </summary>
        /// <doc-id>hh447597</doc-id>
        /// <unmanaged>IV</unmanaged>
        /// <unmanaged-short>IV</unmanaged-short>
        public System.Int64 Iv;
        /// <summary>
        /// <dd> <p>The block count, in big-endian format.</p> </dd>
        /// </summary>
        /// <doc-id>hh447597</doc-id>
        /// <unmanaged>Count</unmanaged>
        /// <unmanaged-short>Count</unmanaged-short>
        public System.Int64 Count;
    }

    /// <summary>
    /// <p>Contains input data for a <strong>D3D11_AUTHENTICATED_CONFIGURE_ENCRYPTION_WHEN_ACCESSIBLE</strong> command.</p>
    /// </summary>
    /// <doc-id>hh447600</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_CONFIGURE_ACCESSIBLE_ENCRYPTION_INPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_CONFIGURE_ACCESSIBLE_ENCRYPTION_INPUT</unmanaged-short>
    public partial struct AuthenticatedConfigureAccessibleEncryptionInput
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedConfigureInput"/></strong> structure that contains the command <see cref = "System.Guid"/> and other data. </p> </dd>
        /// </summary>
        /// <doc-id>hh447600</doc-id>
        /// <unmanaged>Parameters</unmanaged>
        /// <unmanaged-short>Parameters</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedConfigureInput Parameters;
        /// <summary>
        /// <dd> <p>A <see cref = "System.Guid"/> that specifies the type of encryption to apply.</p> </dd>
        /// </summary>
        /// <doc-id>hh447600</doc-id>
        /// <unmanaged>EncryptionGuid</unmanaged>
        /// <unmanaged-short>EncryptionGuid</unmanaged-short>
        public System.Guid EncryptionGuid;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D11.AuthenticatedConfigureInput.__Native Parameters;
            public System.Guid EncryptionGuid;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Parameters.__MarshalFree(ref @ref.Parameters);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Parameters.__MarshalFrom(ref @ref.Parameters);
            EncryptionGuid = @ref.EncryptionGuid;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Parameters.__MarshalTo(ref @ref.Parameters);
            @ref.EncryptionGuid = EncryptionGuid;
        }
    }

    /// <summary>
    /// <p>Contains input data for a <strong>D3D11_AUTHENTICATED_CONFIGURE_CRYPTO_SESSION</strong> command.</p>
    /// </summary>
    /// <doc-id>hh447601</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_CONFIGURE_CRYPTO_SESSION_INPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_CONFIGURE_CRYPTO_SESSION_INPUT</unmanaged-short>
    public partial struct AuthenticatedConfigureCryptoSessionInput
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedConfigureInput"/></strong> structure that contains the command <see cref = "System.Guid"/> and other data. </p> </dd>
        /// </summary>
        /// <doc-id>hh447601</doc-id>
        /// <unmanaged>Parameters</unmanaged>
        /// <unmanaged-short>Parameters</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedConfigureInput Parameters;
        /// <summary>
        /// <dd> <p>A handle to the decoder device. Get this from <strong>ID3D11VideoDecoder::GetDriverHandle</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>hh447601</doc-id>
        /// <unmanaged>DecoderHandle</unmanaged>
        /// <unmanaged-short>DecoderHandle</unmanaged-short>
        public System.IntPtr DecoderHandle;
        /// <summary>
        /// <dd> <p>A handle to the cryptographic session. Get this from <strong>ID3D11CryptoSession::GetCryptoSessionHandle</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>hh447601</doc-id>
        /// <unmanaged>CryptoSessionHandle</unmanaged>
        /// <unmanaged-short>CryptoSessionHandle</unmanaged-short>
        public System.IntPtr CryptoSessionHandle;
        /// <summary>
        /// <dd> <p>A handle to the Direct3D device. Get this from <strong>D3D11VideoContext::QueryAuthenticatedChannel</strong> using <strong>D3D11_AUTHENTICATED_QUERY_DEVICE_HANDLE</strong>.
        /// </p> </dd>
        /// </summary>
        /// <doc-id>hh447601</doc-id>
        /// <unmanaged>DeviceHandle</unmanaged>
        /// <unmanaged-short>DeviceHandle</unmanaged-short>
        public System.IntPtr DeviceHandle;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D11.AuthenticatedConfigureInput.__Native Parameters;
            public System.IntPtr DecoderHandle;
            public System.IntPtr CryptoSessionHandle;
            public System.IntPtr DeviceHandle;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Parameters.__MarshalFree(ref @ref.Parameters);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Parameters.__MarshalFrom(ref @ref.Parameters);
            DecoderHandle = @ref.DecoderHandle;
            CryptoSessionHandle = @ref.CryptoSessionHandle;
            DeviceHandle = @ref.DeviceHandle;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Parameters.__MarshalTo(ref @ref.Parameters);
            @ref.DecoderHandle = DecoderHandle;
            @ref.CryptoSessionHandle = CryptoSessionHandle;
            @ref.DeviceHandle = DeviceHandle;
        }
    }

    /// <summary>
    /// <p>Contains input data for a <strong>D3D11_AUTHENTICATED_CONFIGURE_INITIALIZE</strong> command.</p>
    /// </summary>
    /// <doc-id>hh447602</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_CONFIGURE_INITIALIZE_INPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_CONFIGURE_INITIALIZE_INPUT</unmanaged-short>
    public partial struct AuthenticatedConfigureInitializeInput
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedConfigureInput"/></strong> structure that contains the command <see cref = "System.Guid"/> and other data. </p> </dd>
        /// </summary>
        /// <doc-id>hh447602</doc-id>
        /// <unmanaged>Parameters</unmanaged>
        /// <unmanaged-short>Parameters</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedConfigureInput Parameters;
        /// <summary>
        /// <dd> <p>The initial sequence number for queries.</p> </dd>
        /// </summary>
        /// <doc-id>hh447602</doc-id>
        /// <unmanaged>StartSequenceQuery</unmanaged>
        /// <unmanaged-short>StartSequenceQuery</unmanaged-short>
        public System.Int32 StartSequenceQuery;
        /// <summary>
        /// <dd> <p>The initial sequence number for commands.</p> </dd>
        /// </summary>
        /// <doc-id>hh447602</doc-id>
        /// <unmanaged>StartSequenceConfigure</unmanaged>
        /// <unmanaged-short>StartSequenceConfigure</unmanaged-short>
        public System.Int32 StartSequenceConfigure;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D11.AuthenticatedConfigureInput.__Native Parameters;
            public System.Int32 StartSequenceQuery;
            public System.Int32 StartSequenceConfigure;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Parameters.__MarshalFree(ref @ref.Parameters);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Parameters.__MarshalFrom(ref @ref.Parameters);
            StartSequenceQuery = @ref.StartSequenceQuery;
            StartSequenceConfigure = @ref.StartSequenceConfigure;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Parameters.__MarshalTo(ref @ref.Parameters);
            @ref.StartSequenceQuery = StartSequenceQuery;
            @ref.StartSequenceConfigure = StartSequenceConfigure;
        }
    }

    /// <summary>
    /// <p>Contains input data for the <strong>ID3D11VideoContext::ConfigureAuthenticatedChannel</strong> method.</p>
    /// </summary>
    /// <doc-id>hh447603</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_CONFIGURE_INPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_CONFIGURE_INPUT</unmanaged-short>
    public partial struct AuthenticatedConfigureInput
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447603</doc-id>
        /// <unmanaged>omac</unmanaged>
        /// <unmanaged-short>omac</unmanaged-short>
        public SharpDX.Direct3D11.MessageAuthenticationCode Omac;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447603</doc-id>
        /// <unmanaged>ConfigureType</unmanaged>
        /// <unmanaged-short>ConfigureType</unmanaged-short>
        public System.Guid ConfigureType;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447603</doc-id>
        /// <unmanaged>hChannel</unmanaged>
        /// <unmanaged-short>hChannel</unmanaged-short>
        public System.IntPtr HChannel;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447603</doc-id>
        /// <unmanaged>SequenceNumber</unmanaged>
        /// <unmanaged-short>SequenceNumber</unmanaged-short>
        public System.Int32 SequenceNumber;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D11.MessageAuthenticationCode.__Native Omac;
            public System.Guid ConfigureType;
            public System.IntPtr HChannel;
            public System.Int32 SequenceNumber;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Omac.__MarshalFree(ref @ref.Omac);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Omac.__MarshalFrom(ref @ref.Omac);
            ConfigureType = @ref.ConfigureType;
            HChannel = @ref.HChannel;
            SequenceNumber = @ref.SequenceNumber;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Omac.__MarshalTo(ref @ref.Omac);
            @ref.ConfigureType = ConfigureType;
            @ref.HChannel = HChannel;
            @ref.SequenceNumber = SequenceNumber;
        }
    }

    /// <summary>
    /// <p>Contains the response from the <strong>ID3D11VideoContext::ConfigureAuthenticatedChannel</strong> method.</p>
    /// </summary>
    /// <doc-id>hh447604</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_CONFIGURE_OUTPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_CONFIGURE_OUTPUT</unmanaged-short>
    public partial struct AuthenticatedConfigureOutput
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447604</doc-id>
        /// <unmanaged>omac</unmanaged>
        /// <unmanaged-short>omac</unmanaged-short>
        public SharpDX.Direct3D11.MessageAuthenticationCode Omac;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447604</doc-id>
        /// <unmanaged>ConfigureType</unmanaged>
        /// <unmanaged-short>ConfigureType</unmanaged-short>
        public System.Guid ConfigureType;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447604</doc-id>
        /// <unmanaged>hChannel</unmanaged>
        /// <unmanaged-short>hChannel</unmanaged-short>
        public System.IntPtr HChannel;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447604</doc-id>
        /// <unmanaged>SequenceNumber</unmanaged>
        /// <unmanaged-short>SequenceNumber</unmanaged-short>
        public System.Int32 SequenceNumber;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447604</doc-id>
        /// <unmanaged>ReturnCode</unmanaged>
        /// <unmanaged-short>ReturnCode</unmanaged-short>
        public SharpDX.Result ReturnCode;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D11.MessageAuthenticationCode.__Native Omac;
            public System.Guid ConfigureType;
            public System.IntPtr HChannel;
            public System.Int32 SequenceNumber;
            public SharpDX.Result ReturnCode;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Omac.__MarshalFree(ref @ref.Omac);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Omac.__MarshalFrom(ref @ref.Omac);
            ConfigureType = @ref.ConfigureType;
            HChannel = @ref.HChannel;
            SequenceNumber = @ref.SequenceNumber;
            ReturnCode = @ref.ReturnCode;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Omac.__MarshalTo(ref @ref.Omac);
            @ref.ConfigureType = ConfigureType;
            @ref.HChannel = HChannel;
            @ref.SequenceNumber = SequenceNumber;
            @ref.ReturnCode = ReturnCode;
        }
    }

    /// <summary>
    /// <p>Contains input data for a <strong>D3D11_AUTHENTICATED_CONFIGURE_PROTECTION</strong> command.</p>
    /// </summary>
    /// <doc-id>hh447598</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_CONFIGURE_PROTECTION_INPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_CONFIGURE_PROTECTION_INPUT</unmanaged-short>
    public partial struct AuthenticatedConfigureProtectionInput
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedConfigureInput"/></strong> structure that contains the command <see cref = "System.Guid"/> and other data. </p> </dd>
        /// </summary>
        /// <doc-id>hh447598</doc-id>
        /// <unmanaged>Parameters</unmanaged>
        /// <unmanaged-short>Parameters</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedConfigureInput Parameters;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedProtectionFlags"/></strong> union that specifies the protection level.</p> </dd>
        /// </summary>
        /// <doc-id>hh447598</doc-id>
        /// <unmanaged>Protections</unmanaged>
        /// <unmanaged-short>Protections</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedProtectionFlags Protections;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D11.AuthenticatedConfigureInput.__Native Parameters;
            public SharpDX.Direct3D11.AuthenticatedProtectionFlags Protections;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Parameters.__MarshalFree(ref @ref.Parameters);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Parameters.__MarshalFrom(ref @ref.Parameters);
            Protections = @ref.Protections;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Parameters.__MarshalTo(ref @ref.Parameters);
            @ref.Protections = Protections;
        }
    }

    /// <summary>
    /// <p>Contains input data for a <strong>D3D11_AUTHENTICATED_CONFIGURE_SHARED_RESOURCE</strong> command.</p>
    /// </summary>
    /// <doc-id>hh447605</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_CONFIGURE_SHARED_RESOURCE_INPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_CONFIGURE_SHARED_RESOURCE_INPUT</unmanaged-short>
    public partial struct AuthenticatedConfigureSharedResourceInput
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedConfigureInput"/></strong> structure that contains the command <see cref = "System.Guid"/> and other data. </p> </dd>
        /// </summary>
        /// <doc-id>hh447605</doc-id>
        /// <unmanaged>Parameters</unmanaged>
        /// <unmanaged-short>Parameters</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedConfigureInput Parameters;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedProcessIdentifierType"/></strong> value that specifies the type of process. To specify the Desktop Window Manager (DWM) process, set this member to <strong>D3D11_PROCESSIDTYPE_DWM</strong>. Otherwise, set this member to <strong>D3D11_PROCESSIDTYPE_HANDLE</strong> and set the <strong>ProcessHandle</strong> member to a valid handle.</p> </dd>
        /// </summary>
        /// <doc-id>hh447605</doc-id>
        /// <unmanaged>ProcessType</unmanaged>
        /// <unmanaged-short>ProcessType</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedProcessIdentifierType ProcessType;
        /// <summary>
        /// <dd> <p>A process handle. If the <strong>ProcessType</strong> member equals <strong>D3D11_PROCESSIDTYPE_HANDLE</strong>, the <strong>ProcessHandle</strong> member specifies a handle to a process. Otherwise, the value is ignored.</p> </dd>
        /// </summary>
        /// <doc-id>hh447605</doc-id>
        /// <unmanaged>ProcessHandle</unmanaged>
        /// <unmanaged-short>ProcessHandle</unmanaged-short>
        public System.IntPtr ProcessHandle;
        /// <summary>
        /// <dd> <p>If <strong>TRUE</strong>, the specified process has access to restricted shared resources.</p> </dd>
        /// </summary>
        /// <doc-id>hh447605</doc-id>
        /// <unmanaged>AllowAccess</unmanaged>
        /// <unmanaged-short>AllowAccess</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool AllowAccess;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D11.AuthenticatedConfigureInput.__Native Parameters;
            public SharpDX.Direct3D11.AuthenticatedProcessIdentifierType ProcessType;
            public System.IntPtr ProcessHandle;
            public SharpDX.Mathematics.Interop.RawBool AllowAccess;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Parameters.__MarshalFree(ref @ref.Parameters);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Parameters.__MarshalFrom(ref @ref.Parameters);
            ProcessType = @ref.ProcessType;
            ProcessHandle = @ref.ProcessHandle;
            AllowAccess = @ref.AllowAccess;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Parameters.__MarshalTo(ref @ref.Parameters);
            @ref.ProcessType = ProcessType;
            @ref.ProcessHandle = ProcessHandle;
            @ref.AllowAccess = AllowAccess;
        }
    }

    /// <summary>
    /// <p>Specifies the protection level for video content.</p>
    /// </summary>
    /// <doc-id>hh447607</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_PROTECTION_FLAGS</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_PROTECTION_FLAGS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct AuthenticatedProtectionFlags
    {
        /// <summary>
        /// <dd> <dl> <dt><strong>ProtectionEnabled</strong></dt> <dd> <p>If 1, video content protection is enabled. </p> </dd> <dt><strong>OverlayOrFullscreenRequired</strong></dt> <dd> <p>If 1, the application requires video to be displayed using either a hardware overlay or full-screen exclusive mode.</p> </dd> <dt><strong>Reserved </strong></dt> <dd> <p>Reserved. Set all bits to zero. </p> </dd> </dl> </dd>
        /// </summary>
        /// <doc-id>hh447607</doc-id>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public SharpDX.Direct3D11.AuthenticatedProtectionFlagsMidlMidlItfD3d11000000340001Inner Flags;
        /// <summary>
        /// <dd> <p>Use this member to access all of the bits in the union. </p> </dd>
        /// </summary>
        /// <doc-id>hh447607</doc-id>
        /// <unmanaged>Value</unmanaged>
        /// <unmanaged-short>Value</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public System.Int32 Value;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D11_AUTHENTICATED_PROTECTION_FLAGS___MIDL___MIDL_itf_d3d11_0000_0034_0001_INNER</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_PROTECTION_FLAGS___MIDL___MIDL_itf_d3d11_0000_0034_0001_INNER</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct AuthenticatedProtectionFlagsMidlMidlItfD3d11000000340001Inner
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>ProtectionEnabled</unmanaged>
        /// <unmanaged-short>ProtectionEnabled</unmanaged-short>
        public bool ProtectionEnabled
        {
            get => 0 != ((_ProtectionEnabled >> 0) & 1);
            set => this._ProtectionEnabled = (System.Int32)((this._ProtectionEnabled & ~(1 << 0)) | (((value ? 1 : 0) & 1) << 0));
        }

        [System.Runtime.InteropServices.FieldOffset(0)]
        internal System.Int32 _ProtectionEnabled;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>OverlayOrFullscreenRequired</unmanaged>
        /// <unmanaged-short>OverlayOrFullscreenRequired</unmanaged-short>
        public bool OverlayOrFullscreenRequired
        {
            get => 0 != ((_OverlayOrFullscreenRequired >> 1) & 1);
            set => this._OverlayOrFullscreenRequired = (System.Int32)((this._OverlayOrFullscreenRequired & ~(1 << 1)) | (((value ? 1 : 0) & 1) << 1));
        }

        [System.Runtime.InteropServices.FieldOffset(0)]
        internal System.Int32 _OverlayOrFullscreenRequired;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Reserved</unmanaged>
        /// <unmanaged-short>Reserved</unmanaged-short>
        public System.Int32 Reserved
        {
            get => (System.Int32)((_Reserved >> 2) & 1073741823);
            set => this._Reserved = (System.Int32)((this._Reserved & ~(1073741823 << 2)) | ((value & 1073741823) << 2));
        }

        [System.Runtime.InteropServices.FieldOffset(0)]
        internal System.Int32 _Reserved;
    }

    /// <summary>
    /// <p>Contains the response to a <strong>D3D11_AUTHENTICATED_QUERY_ENCRYPTION_WHEN_ACCESSIBLE_GUID_COUNT</strong> query.</p>
    /// </summary>
    /// <doc-id>hh447608</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ENCRYPTION_GUID_COUNT_OUTPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ENCRYPTION_GUID_COUNT_OUTPUT</unmanaged-short>
    public partial struct AuthenticatedQueryAccessibilityEncryptionGuidCountOutput
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedQueryOutput"/></strong> structure that contains a Message Authentication Code (MAC) and other data.</p> </dd>
        /// </summary>
        /// <doc-id>hh447608</doc-id>
        /// <unmanaged>Output</unmanaged>
        /// <unmanaged-short>Output</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedQueryOutput Output;
        /// <summary>
        /// <dd> <p>The number of encryption GUIDs. </p> </dd>
        /// </summary>
        /// <doc-id>hh447608</doc-id>
        /// <unmanaged>EncryptionGuidCount</unmanaged>
        /// <unmanaged-short>EncryptionGuidCount</unmanaged-short>
        public System.Int32 EncryptionGuidCount;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D11.AuthenticatedQueryOutput.__Native Output;
            public System.Int32 EncryptionGuidCount;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Output.__MarshalFree(ref @ref.Output);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Output.__MarshalFrom(ref @ref.Output);
            EncryptionGuidCount = @ref.EncryptionGuidCount;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Output.__MarshalTo(ref @ref.Output);
            @ref.EncryptionGuidCount = EncryptionGuidCount;
        }
    }

    /// <summary>
    /// <p>Contains input data for a <strong>D3D11_AUTHENTICATED_QUERY_ENCRYPTION_WHEN_ACCESSIBLE_GUID</strong> query.</p>
    /// </summary>
    /// <doc-id>hh447609</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ENCRYPTION_GUID_INPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ENCRYPTION_GUID_INPUT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct AuthenticatedQueryAccessibilityEncryptionGuidInput
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedQueryInput"/></strong> structure that contains the <see cref = "System.Guid"/> for the query and other data.</p> </dd>
        /// </summary>
        /// <doc-id>hh447609</doc-id>
        /// <unmanaged>Input</unmanaged>
        /// <unmanaged-short>Input</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedQueryInput Input;
        /// <summary>
        /// <dd> <p>The index of the encryption <see cref = "System.Guid"/>. </p> </dd>
        /// </summary>
        /// <doc-id>hh447609</doc-id>
        /// <unmanaged>EncryptionGuidIndex</unmanaged>
        /// <unmanaged-short>EncryptionGuidIndex</unmanaged-short>
        public System.Int32 EncryptionGuidIndex;
    }

    /// <summary>
    /// <p>Contains the response to a <strong>D3D11_AUTHENTICATED_QUERY_ENCRYPTION_WHEN_ACCESSIBLE_GUID</strong> query.</p>
    /// </summary>
    /// <doc-id>hh447610</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ENCRYPTION_GUID_OUTPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ENCRYPTION_GUID_OUTPUT</unmanaged-short>
    public partial struct AuthenticatedQueryAccessibilityEncryptionGuidOutput
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedQueryOutput"/></strong> structure that contains a Message Authentication Code (MAC) and other data.</p> </dd>
        /// </summary>
        /// <doc-id>hh447610</doc-id>
        /// <unmanaged>Output</unmanaged>
        /// <unmanaged-short>Output</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedQueryOutput Output;
        /// <summary>
        /// <dd> <p>The index of the encryption <see cref = "System.Guid"/>.</p> </dd>
        /// </summary>
        /// <doc-id>hh447610</doc-id>
        /// <unmanaged>EncryptionGuidIndex</unmanaged>
        /// <unmanaged-short>EncryptionGuidIndex</unmanaged-short>
        public System.Int32 EncryptionGuidIndex;
        /// <summary>
        /// <dd> <p>A <see cref = "System.Guid"/> that specifies a supported encryption type.</p> </dd>
        /// </summary>
        /// <doc-id>hh447610</doc-id>
        /// <unmanaged>EncryptionGuid</unmanaged>
        /// <unmanaged-short>EncryptionGuid</unmanaged-short>
        public System.Guid EncryptionGuid;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D11.AuthenticatedQueryOutput.__Native Output;
            public System.Int32 EncryptionGuidIndex;
            public System.Guid EncryptionGuid;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Output.__MarshalFree(ref @ref.Output);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Output.__MarshalFrom(ref @ref.Output);
            EncryptionGuidIndex = @ref.EncryptionGuidIndex;
            EncryptionGuid = @ref.EncryptionGuid;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Output.__MarshalTo(ref @ref.Output);
            @ref.EncryptionGuidIndex = EncryptionGuidIndex;
            @ref.EncryptionGuid = EncryptionGuid;
        }
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D11_AUTHENTICATED_QUERY_ACESSIBILITY_OUTPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_QUERY_ACESSIBILITY_OUTPUT</unmanaged-short>
    public partial struct AuthenticatedQueryAcessibilityOutput
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Output</unmanaged>
        /// <unmanaged-short>Output</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedQueryOutput Output;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>BusType</unmanaged>
        /// <unmanaged-short>BusType</unmanaged-short>
        public SharpDX.Direct3D11.BusType BusType;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>AccessibleInContiguousBlocks</unmanaged>
        /// <unmanaged-short>AccessibleInContiguousBlocks</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool AccessibleInContiguousBlocks;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>AccessibleInNonContiguousBlocks</unmanaged>
        /// <unmanaged-short>AccessibleInNonContiguousBlocks</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool AccessibleInNonContiguousBlocks;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D11.AuthenticatedQueryOutput.__Native Output;
            public SharpDX.Direct3D11.BusType BusType;
            public SharpDX.Mathematics.Interop.RawBool AccessibleInContiguousBlocks;
            public SharpDX.Mathematics.Interop.RawBool AccessibleInNonContiguousBlocks;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Output.__MarshalFree(ref @ref.Output);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Output.__MarshalFrom(ref @ref.Output);
            BusType = @ref.BusType;
            AccessibleInContiguousBlocks = @ref.AccessibleInContiguousBlocks;
            AccessibleInNonContiguousBlocks = @ref.AccessibleInNonContiguousBlocks;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Output.__MarshalTo(ref @ref.Output);
            @ref.BusType = BusType;
            @ref.AccessibleInContiguousBlocks = AccessibleInContiguousBlocks;
            @ref.AccessibleInNonContiguousBlocks = AccessibleInNonContiguousBlocks;
        }
    }

    /// <summary>
    /// <p>Contains the response to a <strong>D3D11_AUTHENTICATED_QUERY_CHANNEL_TYPE</strong> query.</p>
    /// </summary>
    /// <doc-id>hh447612</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_QUERY_CHANNEL_TYPE_OUTPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_QUERY_CHANNEL_TYPE_OUTPUT</unmanaged-short>
    public partial struct AuthenticatedQueryChannelTypeOutput
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedQueryOutput"/></strong> structure that contains a Message Authentication Code (MAC) and other data.</p> </dd>
        /// </summary>
        /// <doc-id>hh447612</doc-id>
        /// <unmanaged>Output</unmanaged>
        /// <unmanaged-short>Output</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedQueryOutput Output;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedChannelType"/></strong> value that specifies the channel type. </p> </dd>
        /// </summary>
        /// <doc-id>hh447612</doc-id>
        /// <unmanaged>ChannelType</unmanaged>
        /// <unmanaged-short>ChannelType</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedChannelType ChannelType;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D11.AuthenticatedQueryOutput.__Native Output;
            public SharpDX.Direct3D11.AuthenticatedChannelType ChannelType;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Output.__MarshalFree(ref @ref.Output);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Output.__MarshalFrom(ref @ref.Output);
            ChannelType = @ref.ChannelType;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Output.__MarshalTo(ref @ref.Output);
            @ref.ChannelType = ChannelType;
        }
    }

    /// <summary>
    /// <p>Contains input data for a <strong>D3D11_AUTHENTICATED_QUERY_CRYPTO_SESSION</strong> query. </p>
    /// </summary>
    /// <doc-id>hh447613</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_QUERY_CRYPTO_SESSION_INPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_QUERY_CRYPTO_SESSION_INPUT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct AuthenticatedQueryCryptoSessionInput
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedQueryInput"/></strong> structure that contains the <see cref = "System.Guid"/> for the query and other data.</p> </dd>
        /// </summary>
        /// <doc-id>hh447613</doc-id>
        /// <unmanaged>Input</unmanaged>
        /// <unmanaged-short>Input</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedQueryInput Input;
        /// <summary>
        /// <dd> <p>A handle to a decoder device.</p> </dd>
        /// </summary>
        /// <doc-id>hh447613</doc-id>
        /// <unmanaged>DecoderHandle</unmanaged>
        /// <unmanaged-short>DecoderHandle</unmanaged-short>
        public System.IntPtr DecoderHandle;
    }

    /// <summary>
    /// <p>Contains the response to a <strong>D3D11_AUTHENTICATED_QUERY_CRYPTO_SESSION</strong> query. </p>
    /// </summary>
    /// <doc-id>hh447614</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_QUERY_CRYPTO_SESSION_OUTPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_QUERY_CRYPTO_SESSION_OUTPUT</unmanaged-short>
    public partial struct AuthenticatedQueryCryptoSessionOutput
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedQueryOutput"/></strong> structure that contains a Message Authentication Code (MAC) and other data.</p> </dd>
        /// </summary>
        /// <doc-id>hh447614</doc-id>
        /// <unmanaged>Output</unmanaged>
        /// <unmanaged-short>Output</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedQueryOutput Output;
        /// <summary>
        /// <dd> <p>A handle to a decoder device.</p> </dd>
        /// </summary>
        /// <doc-id>hh447614</doc-id>
        /// <unmanaged>DecoderHandle</unmanaged>
        /// <unmanaged-short>DecoderHandle</unmanaged-short>
        public System.IntPtr DecoderHandle;
        /// <summary>
        /// <dd> <p>A handle to the cryptographic session that is associated with the decoder device.</p> </dd>
        /// </summary>
        /// <doc-id>hh447614</doc-id>
        /// <unmanaged>CryptoSessionHandle</unmanaged>
        /// <unmanaged-short>CryptoSessionHandle</unmanaged-short>
        public System.IntPtr CryptoSessionHandle;
        /// <summary>
        /// <dd> <p>A handle to the Direct3D device that is associated with the decoder device.</p> </dd>
        /// </summary>
        /// <doc-id>hh447614</doc-id>
        /// <unmanaged>DeviceHandle</unmanaged>
        /// <unmanaged-short>DeviceHandle</unmanaged-short>
        public System.IntPtr DeviceHandle;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D11.AuthenticatedQueryOutput.__Native Output;
            public System.IntPtr DecoderHandle;
            public System.IntPtr CryptoSessionHandle;
            public System.IntPtr DeviceHandle;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Output.__MarshalFree(ref @ref.Output);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Output.__MarshalFrom(ref @ref.Output);
            DecoderHandle = @ref.DecoderHandle;
            CryptoSessionHandle = @ref.CryptoSessionHandle;
            DeviceHandle = @ref.DeviceHandle;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Output.__MarshalTo(ref @ref.Output);
            @ref.DecoderHandle = DecoderHandle;
            @ref.CryptoSessionHandle = CryptoSessionHandle;
            @ref.DeviceHandle = DeviceHandle;
        }
    }

    /// <summary>
    /// <p>Contains the response to a <strong>D3D11_AUTHENTICATED_QUERY_CURRENT_ENCRYPTION_WHEN_ACCESSIBLE </strong>query.</p>
    /// </summary>
    /// <doc-id>hh447615</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_QUERY_CURRENT_ACCESSIBILITY_ENCRYPTION_OUTPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_QUERY_CURRENT_ACCESSIBILITY_ENCRYPTION_OUTPUT</unmanaged-short>
    public partial struct AuthenticatedQueryCurrentAccessibilityEncryptionOutput
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedQueryOutput"/></strong> structure that contains a Message Authentication Code (MAC) and other data.</p> </dd>
        /// </summary>
        /// <doc-id>hh447615</doc-id>
        /// <unmanaged>Output</unmanaged>
        /// <unmanaged-short>Output</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedQueryOutput Output;
        /// <summary>
        /// <dd> <p>A <see cref = "System.Guid"/> that specifies the current encryption type. </p> </dd>
        /// </summary>
        /// <doc-id>hh447615</doc-id>
        /// <unmanaged>EncryptionGuid</unmanaged>
        /// <unmanaged-short>EncryptionGuid</unmanaged-short>
        public System.Guid EncryptionGuid;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D11.AuthenticatedQueryOutput.__Native Output;
            public System.Guid EncryptionGuid;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Output.__MarshalFree(ref @ref.Output);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Output.__MarshalFrom(ref @ref.Output);
            EncryptionGuid = @ref.EncryptionGuid;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Output.__MarshalTo(ref @ref.Output);
            @ref.EncryptionGuid = EncryptionGuid;
        }
    }

    /// <summary>
    /// <p>Contains the response to a <strong>D3D11_AUTHENTICATED_QUERY_DEVICE_HANDLE</strong> query. </p>
    /// </summary>
    /// <doc-id>hh447616</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_QUERY_DEVICE_HANDLE_OUTPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_QUERY_DEVICE_HANDLE_OUTPUT</unmanaged-short>
    public partial struct AuthenticatedQueryDeviceHandleOutput
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedQueryOutput"/></strong> structure that contains a Message Authentication Code (MAC) and other data. </p> </dd>
        /// </summary>
        /// <doc-id>hh447616</doc-id>
        /// <unmanaged>Output</unmanaged>
        /// <unmanaged-short>Output</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedQueryOutput Output;
        /// <summary>
        /// <dd> <p>A handle to the device. </p> </dd>
        /// </summary>
        /// <doc-id>hh447616</doc-id>
        /// <unmanaged>DeviceHandle</unmanaged>
        /// <unmanaged-short>DeviceHandle</unmanaged-short>
        public System.IntPtr DeviceHandle;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D11.AuthenticatedQueryOutput.__Native Output;
            public System.IntPtr DeviceHandle;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Output.__MarshalFree(ref @ref.Output);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Output.__MarshalFrom(ref @ref.Output);
            DeviceHandle = @ref.DeviceHandle;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Output.__MarshalTo(ref @ref.Output);
            @ref.DeviceHandle = DeviceHandle;
        }
    }

    /// <summary>
    /// <p>Contains input data for the <strong>ID3D11VideoContext::QueryAuthenticatedChannel</strong> method. </p>
    /// </summary>
    /// <doc-id>hh447617</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_QUERY_INPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_QUERY_INPUT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct AuthenticatedQueryInput
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447617</doc-id>
        /// <unmanaged>QueryType</unmanaged>
        /// <unmanaged-short>QueryType</unmanaged-short>
        public System.Guid QueryType;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447617</doc-id>
        /// <unmanaged>hChannel</unmanaged>
        /// <unmanaged-short>hChannel</unmanaged-short>
        public System.IntPtr HChannel;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447617</doc-id>
        /// <unmanaged>SequenceNumber</unmanaged>
        /// <unmanaged-short>SequenceNumber</unmanaged-short>
        public System.Int32 SequenceNumber;
    }

    /// <summary>
    /// <p>Contains a response from the <strong>ID3D11VideoContext::QueryAuthenticatedChannel</strong> method.</p>
    /// </summary>
    /// <doc-id>hh447618</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_QUERY_OUTPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_QUERY_OUTPUT</unmanaged-short>
    public partial struct AuthenticatedQueryOutput
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447618</doc-id>
        /// <unmanaged>omac</unmanaged>
        /// <unmanaged-short>omac</unmanaged-short>
        public SharpDX.Direct3D11.MessageAuthenticationCode Omac;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447618</doc-id>
        /// <unmanaged>QueryType</unmanaged>
        /// <unmanaged-short>QueryType</unmanaged-short>
        public System.Guid QueryType;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447618</doc-id>
        /// <unmanaged>hChannel</unmanaged>
        /// <unmanaged-short>hChannel</unmanaged-short>
        public System.IntPtr HChannel;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447618</doc-id>
        /// <unmanaged>SequenceNumber</unmanaged>
        /// <unmanaged-short>SequenceNumber</unmanaged-short>
        public System.Int32 SequenceNumber;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447618</doc-id>
        /// <unmanaged>ReturnCode</unmanaged>
        /// <unmanaged-short>ReturnCode</unmanaged-short>
        public SharpDX.Result ReturnCode;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D11.MessageAuthenticationCode.__Native Omac;
            public System.Guid QueryType;
            public System.IntPtr HChannel;
            public System.Int32 SequenceNumber;
            public SharpDX.Result ReturnCode;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Omac.__MarshalFree(ref @ref.Omac);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Omac.__MarshalFrom(ref @ref.Omac);
            QueryType = @ref.QueryType;
            HChannel = @ref.HChannel;
            SequenceNumber = @ref.SequenceNumber;
            ReturnCode = @ref.ReturnCode;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Omac.__MarshalTo(ref @ref.Omac);
            @ref.QueryType = QueryType;
            @ref.HChannel = HChannel;
            @ref.SequenceNumber = SequenceNumber;
            @ref.ReturnCode = ReturnCode;
        }
    }

    /// <summary>
    /// <p>Contains input data for a <strong>D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_COUNT</strong> query.</p>
    /// </summary>
    /// <doc-id>hh447619</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_COUNT_INPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_COUNT_INPUT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct AuthenticatedQueryOutputIdCountInput
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedQueryInput"/></strong> structure that contains the <see cref = "System.Guid"/> for the query and other data.</p> </dd>
        /// </summary>
        /// <doc-id>hh447619</doc-id>
        /// <unmanaged>Input</unmanaged>
        /// <unmanaged-short>Input</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedQueryInput Input;
        /// <summary>
        /// <dd> <p>A handle to the device.</p> </dd>
        /// </summary>
        /// <doc-id>hh447619</doc-id>
        /// <unmanaged>DeviceHandle</unmanaged>
        /// <unmanaged-short>DeviceHandle</unmanaged-short>
        public System.IntPtr DeviceHandle;
        /// <summary>
        /// <dd> <p>A handle to the cryptographic session.</p> </dd>
        /// </summary>
        /// <doc-id>hh447619</doc-id>
        /// <unmanaged>CryptoSessionHandle</unmanaged>
        /// <unmanaged-short>CryptoSessionHandle</unmanaged-short>
        public System.IntPtr CryptoSessionHandle;
    }

    /// <summary>
    /// <p>Contains the response to a <strong>D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_COUNT</strong> query.</p>
    /// </summary>
    /// <doc-id>hh447620</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_COUNT_OUTPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_COUNT_OUTPUT</unmanaged-short>
    public partial struct AuthenticatedQueryOutputIdCountOutput
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedQueryOutput"/></strong> structure that contains a Message Authentication Code (MAC) and other data.</p> </dd>
        /// </summary>
        /// <doc-id>hh447620</doc-id>
        /// <unmanaged>Output</unmanaged>
        /// <unmanaged-short>Output</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedQueryOutput Output;
        /// <summary>
        /// <dd> <p>A handle to the device.</p> </dd>
        /// </summary>
        /// <doc-id>hh447620</doc-id>
        /// <unmanaged>DeviceHandle</unmanaged>
        /// <unmanaged-short>DeviceHandle</unmanaged-short>
        public System.IntPtr DeviceHandle;
        /// <summary>
        /// <dd> <p>A handle to the cryptographic session.</p> </dd>
        /// </summary>
        /// <doc-id>hh447620</doc-id>
        /// <unmanaged>CryptoSessionHandle</unmanaged>
        /// <unmanaged-short>CryptoSessionHandle</unmanaged-short>
        public System.IntPtr CryptoSessionHandle;
        /// <summary>
        /// <dd> <p>The number of output IDs associated with the specified device and cryptographic session.</p> </dd>
        /// </summary>
        /// <doc-id>hh447620</doc-id>
        /// <unmanaged>OutputIDCount</unmanaged>
        /// <unmanaged-short>OutputIDCount</unmanaged-short>
        public System.Int32 OutputIDCount;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D11.AuthenticatedQueryOutput.__Native Output;
            public System.IntPtr DeviceHandle;
            public System.IntPtr CryptoSessionHandle;
            public System.Int32 OutputIDCount;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Output.__MarshalFree(ref @ref.Output);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Output.__MarshalFrom(ref @ref.Output);
            DeviceHandle = @ref.DeviceHandle;
            CryptoSessionHandle = @ref.CryptoSessionHandle;
            OutputIDCount = @ref.OutputIDCount;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Output.__MarshalTo(ref @ref.Output);
            @ref.DeviceHandle = DeviceHandle;
            @ref.CryptoSessionHandle = CryptoSessionHandle;
            @ref.OutputIDCount = OutputIDCount;
        }
    }

    /// <summary>
    /// <p>Contains input data for a <strong>D3D11_AUTHENTICATED_QUERY_OUTPUT_ID</strong> query.</p>
    /// </summary>
    /// <doc-id>hh447621</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_INPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_INPUT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct AuthenticatedQueryOutputIdInput
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedQueryInput"/></strong> structure that contains the <see cref = "System.Guid"/> for the query and other data.</p> </dd>
        /// </summary>
        /// <doc-id>hh447621</doc-id>
        /// <unmanaged>Input</unmanaged>
        /// <unmanaged-short>Input</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedQueryInput Input;
        /// <summary>
        /// <dd> <p>A handle to the device.</p> </dd>
        /// </summary>
        /// <doc-id>hh447621</doc-id>
        /// <unmanaged>DeviceHandle</unmanaged>
        /// <unmanaged-short>DeviceHandle</unmanaged-short>
        public System.IntPtr DeviceHandle;
        /// <summary>
        /// <dd> <p>A handle to the cryptographic session.</p> </dd>
        /// </summary>
        /// <doc-id>hh447621</doc-id>
        /// <unmanaged>CryptoSessionHandle</unmanaged>
        /// <unmanaged-short>CryptoSessionHandle</unmanaged-short>
        public System.IntPtr CryptoSessionHandle;
        /// <summary>
        /// <dd> <p>The index of the output ID.</p> </dd>
        /// </summary>
        /// <doc-id>hh447621</doc-id>
        /// <unmanaged>OutputIDIndex</unmanaged>
        /// <unmanaged-short>OutputIDIndex</unmanaged-short>
        public System.Int32 OutputIDIndex;
    }

    /// <summary>
    /// <p>Contains the response to a <strong>D3D11_AUTHENTICATED_QUERY_OUTPUT_ID</strong> query.</p>
    /// </summary>
    /// <doc-id>hh447622</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_OUTPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_OUTPUT</unmanaged-short>
    public partial struct AuthenticatedQueryOutputIdOutput
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedQueryOutput"/></strong> structure that contains a Message Authentication Code (MAC) and other data.</p> </dd>
        /// </summary>
        /// <doc-id>hh447622</doc-id>
        /// <unmanaged>Output</unmanaged>
        /// <unmanaged-short>Output</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedQueryOutput Output;
        /// <summary>
        /// <dd> <p>A handle to the device.</p> </dd>
        /// </summary>
        /// <doc-id>hh447622</doc-id>
        /// <unmanaged>DeviceHandle</unmanaged>
        /// <unmanaged-short>DeviceHandle</unmanaged-short>
        public System.IntPtr DeviceHandle;
        /// <summary>
        /// <dd> <p>A handle to the cryptographic session.</p> </dd>
        /// </summary>
        /// <doc-id>hh447622</doc-id>
        /// <unmanaged>CryptoSessionHandle</unmanaged>
        /// <unmanaged-short>CryptoSessionHandle</unmanaged-short>
        public System.IntPtr CryptoSessionHandle;
        /// <summary>
        /// <dd> <p>The index of the output ID.</p> </dd>
        /// </summary>
        /// <doc-id>hh447622</doc-id>
        /// <unmanaged>OutputIDIndex</unmanaged>
        /// <unmanaged-short>OutputIDIndex</unmanaged-short>
        public System.Int32 OutputIDIndex;
        /// <summary>
        /// <dd> <p>An output ID that is associated with the specified device and cryptographic session.</p> </dd>
        /// </summary>
        /// <doc-id>hh447622</doc-id>
        /// <unmanaged>OutputID</unmanaged>
        /// <unmanaged-short>OutputID</unmanaged-short>
        public System.Int64 OutputID;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D11.AuthenticatedQueryOutput.__Native Output;
            public System.IntPtr DeviceHandle;
            public System.IntPtr CryptoSessionHandle;
            public System.Int32 OutputIDIndex;
            public System.Int64 OutputID;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Output.__MarshalFree(ref @ref.Output);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Output.__MarshalFrom(ref @ref.Output);
            DeviceHandle = @ref.DeviceHandle;
            CryptoSessionHandle = @ref.CryptoSessionHandle;
            OutputIDIndex = @ref.OutputIDIndex;
            OutputID = @ref.OutputID;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Output.__MarshalTo(ref @ref.Output);
            @ref.DeviceHandle = DeviceHandle;
            @ref.CryptoSessionHandle = CryptoSessionHandle;
            @ref.OutputIDIndex = OutputIDIndex;
            @ref.OutputID = OutputID;
        }
    }

    /// <summary>
    /// <p>Contains the response to a <strong>D3D11_AUTHENTICATED_QUERY_PROTECTION</strong> query. </p>
    /// </summary>
    /// <doc-id>hh447623</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_QUERY_PROTECTION_OUTPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_QUERY_PROTECTION_OUTPUT</unmanaged-short>
    public partial struct AuthenticatedQueryProtectionOutput
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedQueryOutput"/></strong> structure that contains a Message Authentication Code (MAC) and other data. </p> </dd>
        /// </summary>
        /// <doc-id>hh447623</doc-id>
        /// <unmanaged>Output</unmanaged>
        /// <unmanaged-short>Output</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedQueryOutput Output;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedProtectionFlags"/></strong> union that specifies the protection level. </p> </dd>
        /// </summary>
        /// <doc-id>hh447623</doc-id>
        /// <unmanaged>ProtectionFlags</unmanaged>
        /// <unmanaged-short>ProtectionFlags</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedProtectionFlags ProtectionFlags;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D11.AuthenticatedQueryOutput.__Native Output;
            public SharpDX.Direct3D11.AuthenticatedProtectionFlags ProtectionFlags;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Output.__MarshalFree(ref @ref.Output);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Output.__MarshalFrom(ref @ref.Output);
            ProtectionFlags = @ref.ProtectionFlags;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Output.__MarshalTo(ref @ref.Output);
            @ref.ProtectionFlags = ProtectionFlags;
        }
    }

    /// <summary>
    /// <p>Contains the response to a <strong>D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_COUNT</strong> query.</p>
    /// </summary>
    /// <doc-id>hh447624</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_COUNT_OUTPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_COUNT_OUTPUT</unmanaged-short>
    public partial struct AuthenticatedQueryRestrictedSharedResourceProcessCountOutput
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedQueryOutput"/></strong> structure that contains a Message Authentication Code (MAC) and other data.</p> </dd>
        /// </summary>
        /// <doc-id>hh447624</doc-id>
        /// <unmanaged>Output</unmanaged>
        /// <unmanaged-short>Output</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedQueryOutput Output;
        /// <summary>
        /// <dd> <p>The number of processes that are allowed to open shared resources that have restricted access. A process cannot open such a resource unless the process has been granted access. </p> </dd>
        /// </summary>
        /// <doc-id>hh447624</doc-id>
        /// <unmanaged>RestrictedSharedResourceProcessCount</unmanaged>
        /// <unmanaged-short>RestrictedSharedResourceProcessCount</unmanaged-short>
        public System.Int32 RestrictedSharedResourceProcessCount;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D11.AuthenticatedQueryOutput.__Native Output;
            public System.Int32 RestrictedSharedResourceProcessCount;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Output.__MarshalFree(ref @ref.Output);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Output.__MarshalFrom(ref @ref.Output);
            RestrictedSharedResourceProcessCount = @ref.RestrictedSharedResourceProcessCount;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Output.__MarshalTo(ref @ref.Output);
            @ref.RestrictedSharedResourceProcessCount = RestrictedSharedResourceProcessCount;
        }
    }

    /// <summary>
    /// <p>Contains input data for a <strong>D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS</strong> query.</p>
    /// </summary>
    /// <doc-id>hh447625</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_INPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_INPUT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct AuthenticatedQueryRestrictedSharedResourceProcessInput
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedQueryInput"/></strong> structure that contains the <see cref = "System.Guid"/> for the query and other data.</p> </dd>
        /// </summary>
        /// <doc-id>hh447625</doc-id>
        /// <unmanaged>Input</unmanaged>
        /// <unmanaged-short>Input</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedQueryInput Input;
        /// <summary>
        /// <dd> <p>The index of the process. </p> </dd>
        /// </summary>
        /// <doc-id>hh447625</doc-id>
        /// <unmanaged>ProcessIndex</unmanaged>
        /// <unmanaged-short>ProcessIndex</unmanaged-short>
        public System.Int32 ProcessIndex;
    }

    /// <summary>
    /// <p>Contains the response to a <strong>D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS</strong> query.</p>
    /// </summary>
    /// <remarks>
    /// <p>The Desktop Window Manager (DWM) process is identified by setting <strong>ProcessIdentifier</strong> equal to <strong>D3D11_PROCESSIDTYPE_DWM</strong>. Other processes are identified by setting the process handle in <strong>ProcessHandle</strong> and setting <strong>ProcessIdentifier</strong> equal to <strong>D3D11_PROCESSIDTYPE_HANDLE</strong>.</p>
    /// </remarks>
    /// <doc-id>hh447626</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_OUTPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_OUTPUT</unmanaged-short>
    public partial struct AuthenticatedQueryRestrictedSharedResourceProcessOutput
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedQueryOutput"/></strong> structure that contains a Message Authentication Code (MAC) and other data.</p> </dd>
        /// </summary>
        /// <doc-id>hh447626</doc-id>
        /// <unmanaged>Output</unmanaged>
        /// <unmanaged-short>Output</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedQueryOutput Output;
        /// <summary>
        /// <dd> <p>The index of the process in the list of processes.</p> </dd>
        /// </summary>
        /// <doc-id>hh447626</doc-id>
        /// <unmanaged>ProcessIndex</unmanaged>
        /// <unmanaged-short>ProcessIndex</unmanaged-short>
        public System.Int32 ProcessIndex;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedProcessIdentifierType"/></strong> value that specifies the type of process.</p> </dd>
        /// </summary>
        /// <doc-id>hh447626</doc-id>
        /// <unmanaged>ProcessIdentifier</unmanaged>
        /// <unmanaged-short>ProcessIdentifier</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedProcessIdentifierType ProcessIdentifier;
        /// <summary>
        /// <dd> <p>A process handle. If the <strong>ProcessIdentifier</strong> member equals <strong>D3D11_PROCESSIDTYPE_HANDLE</strong>, the <strong>ProcessHandle</strong> member contains a valid handle to a process. Otherwise, this member is ignored.</p> </dd>
        /// </summary>
        /// <doc-id>hh447626</doc-id>
        /// <unmanaged>ProcessHandle</unmanaged>
        /// <unmanaged-short>ProcessHandle</unmanaged-short>
        public System.IntPtr ProcessHandle;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D11.AuthenticatedQueryOutput.__Native Output;
            public System.Int32 ProcessIndex;
            public SharpDX.Direct3D11.AuthenticatedProcessIdentifierType ProcessIdentifier;
            public System.IntPtr ProcessHandle;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Output.__MarshalFree(ref @ref.Output);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Output.__MarshalFrom(ref @ref.Output);
            ProcessIndex = @ref.ProcessIndex;
            ProcessIdentifier = @ref.ProcessIdentifier;
            ProcessHandle = @ref.ProcessHandle;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Output.__MarshalTo(ref @ref.Output);
            @ref.ProcessIndex = ProcessIndex;
            @ref.ProcessIdentifier = ProcessIdentifier;
            @ref.ProcessHandle = ProcessHandle;
        }
    }

    /// <summary>
    /// <p>Contains the response to a <strong>D3D11_AUTHENTICATED_QUERY_UNRESTRICTED_PROTECTED_SHARED_RESOURCE_COUNT</strong> query.</p>
    /// </summary>
    /// <doc-id>hh447627</doc-id>
    /// <unmanaged>D3D11_AUTHENTICATED_QUERY_UNRESTRICTED_PROTECTED_SHARED_RESOURCE_COUNT_OUTPUT</unmanaged>
    /// <unmanaged-short>D3D11_AUTHENTICATED_QUERY_UNRESTRICTED_PROTECTED_SHARED_RESOURCE_COUNT_OUTPUT</unmanaged-short>
    public partial struct AuthenticatedQueryUnrestrictedProtectedSharedResourceCountOutput
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.AuthenticatedQueryOutput"/></strong> structure that contains a Message Authentication Code (MAC) and other data.</p> </dd>
        /// </summary>
        /// <doc-id>hh447627</doc-id>
        /// <unmanaged>Output</unmanaged>
        /// <unmanaged-short>Output</unmanaged-short>
        public SharpDX.Direct3D11.AuthenticatedQueryOutput Output;
        /// <summary>
        /// <dd> <p>The number of protected, shared resources that can be opened by any process without restrictions.</p> </dd>
        /// </summary>
        /// <doc-id>hh447627</doc-id>
        /// <unmanaged>UnrestrictedProtectedSharedResourceCount</unmanaged>
        /// <unmanaged-short>UnrestrictedProtectedSharedResourceCount</unmanaged-short>
        public System.Int32 UnrestrictedProtectedSharedResourceCount;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D11.AuthenticatedQueryOutput.__Native Output;
            public System.Int32 UnrestrictedProtectedSharedResourceCount;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            Output.__MarshalFree(ref @ref.Output);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Output.__MarshalFrom(ref @ref.Output);
            UnrestrictedProtectedSharedResourceCount = @ref.UnrestrictedProtectedSharedResourceCount;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            Output.__MarshalTo(ref @ref.Output);
            @ref.UnrestrictedProtectedSharedResourceCount = UnrestrictedProtectedSharedResourceCount;
        }
    }

    /// <summary>
    /// <p> Describes the blend state that you use in a call to <strong>ID3D11Device::CreateBlendState</strong> to create a blend-state object. </p>
    /// </summary>
    /// <remarks>
    /// <p>Here are the default values for blend state.</p><table> <tr><th>State</th><th>Default Value</th></tr> <tr><td>AlphaToCoverageEnable</td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td>IndependentBlendEnable</td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td>RenderTarget[0].BlendEnable</td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td>RenderTarget[0].SrcBlend</td><td>D3D11_BLEND_ONE</td></tr> <tr><td>RenderTarget[0].DestBlend</td><td>D3D11_BLEND_ZERO</td></tr> <tr><td>RenderTarget[0].BlendOp</td><td>D3D11_BLEND_OP_ADD</td></tr> <tr><td>RenderTarget[0].SrcBlendAlpha</td><td>D3D11_BLEND_ONE</td></tr> <tr><td>RenderTarget[0].DestBlendAlpha</td><td>D3D11_BLEND_ZERO</td></tr> <tr><td>RenderTarget[0].BlendOpAlpha</td><td>D3D11_BLEND_OP_ADD</td></tr> <tr><td>RenderTarget[0].RenderTargetWriteMask</td><td>D3D11_COLOR_WRITE_ENABLE_ALL</td></tr> </table><p>?</p><strong>Note</strong>??<strong><see cref = "SharpDX.Direct3D11.BlendStateDescription"/></strong> is identical to <strong>D3D10_BLEND_DESC1</strong>.?<p> If the driver type is set to <strong>D3D_DRIVER_TYPE_HARDWARE</strong>, the feature level is set to less than or equal to <strong>D3D_FEATURE_LEVEL_9_3</strong>, and the pixel format of the render target is set to <strong>DXGI_FORMAT_R8G8B8A8_UNORM_SRGB</strong>, <strong>DXGI_FORMAT_B8G8R8A8_UNORM_SRGB</strong>, or <strong>DXGI_FORMAT_B8G8R8X8_UNORM_SRGB</strong>, the display device performs the blend in standard RGB (sRGB) space and not in linear space. However, if the feature level is set to greater than <strong>D3D_FEATURE_LEVEL_9_3</strong>, the display device performs the blend in linear space, which is ideal. </p>
    /// </remarks>
    /// <doc-id>ff476087</doc-id>
    /// <unmanaged>D3D11_BLEND_DESC</unmanaged>
    /// <unmanaged-short>D3D11_BLEND_DESC</unmanaged-short>
    public partial struct BlendStateDescription
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ff476087</doc-id>
        /// <unmanaged>AlphaToCoverageEnable</unmanaged>
        /// <unmanaged-short>AlphaToCoverageEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool AlphaToCoverageEnable;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ff476087</doc-id>
        /// <unmanaged>IndependentBlendEnable</unmanaged>
        /// <unmanaged-short>IndependentBlendEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IndependentBlendEnable;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ff476087</doc-id>
        /// <unmanaged>RenderTarget</unmanaged>
        /// <unmanaged-short>RenderTarget</unmanaged-short>
        public SharpDX.Direct3D11.RenderTargetBlendDescription[] RenderTarget
        {
            get => _RenderTarget ?? (_RenderTarget = new SharpDX.Direct3D11.RenderTargetBlendDescription[8]);
            private set => _RenderTarget = value;
        }

        internal SharpDX.Direct3D11.RenderTargetBlendDescription[] _RenderTarget;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Mathematics.Interop.RawBool AlphaToCoverageEnable;
            public SharpDX.Mathematics.Interop.RawBool IndependentBlendEnable;
            public SharpDX.Direct3D11.RenderTargetBlendDescription RenderTarget;
            public SharpDX.Direct3D11.RenderTargetBlendDescription __RenderTarget1;
            public SharpDX.Direct3D11.RenderTargetBlendDescription __RenderTarget2;
            public SharpDX.Direct3D11.RenderTargetBlendDescription __RenderTarget3;
            public SharpDX.Direct3D11.RenderTargetBlendDescription __RenderTarget4;
            public SharpDX.Direct3D11.RenderTargetBlendDescription __RenderTarget5;
            public SharpDX.Direct3D11.RenderTargetBlendDescription __RenderTarget6;
            public SharpDX.Direct3D11.RenderTargetBlendDescription __RenderTarget7;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            AlphaToCoverageEnable = @ref.AlphaToCoverageEnable;
            IndependentBlendEnable = @ref.IndependentBlendEnable;
            fixed (void *__to = &RenderTarget[0], __from = &@ref.RenderTarget)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 8 * sizeof (SharpDX.Direct3D11.RenderTargetBlendDescription));
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.AlphaToCoverageEnable = AlphaToCoverageEnable;
            @ref.IndependentBlendEnable = IndependentBlendEnable;
            fixed (void *__from = &RenderTarget[0], __to = &@ref.RenderTarget)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 8 * sizeof (SharpDX.Direct3D11.RenderTargetBlendDescription));
        }
    }

    /// <summary>
    /// <strong>Note</strong>?? This structure is supported by the Direct3D 11.1 runtime, which is available on Windows?8 and later operating systems.?<p> Describes the blend state that you use in a call to <strong>ID3D11Device1::CreateBlendState1</strong> to create a blend-state object. </p>
    /// </summary>
    /// <remarks>
    /// <p> Here are the default values for blend state. </p><table> <tr><th>State</th><th>Default Value</th></tr> <tr><td>AlphaToCoverageEnable</td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td>IndependentBlendEnable</td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td>RenderTarget[0].BlendEnable</td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td>RenderTarget[0].LogicOpEnable</td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td>RenderTarget[0].SrcBlend</td><td>D3D11_BLEND_ONE</td></tr> <tr><td>RenderTarget[0].DestBlend</td><td>D3D11_BLEND_ZERO</td></tr> <tr><td>RenderTarget[0].BlendOp</td><td>D3D11_BLEND_OP_ADD</td></tr> <tr><td>RenderTarget[0].SrcBlendAlpha</td><td>D3D11_BLEND_ONE</td></tr> <tr><td>RenderTarget[0].DestBlendAlpha</td><td>D3D11_BLEND_ZERO</td></tr> <tr><td>RenderTarget[0].BlendOpAlpha</td><td>D3D11_BLEND_OP_ADD</td></tr> <tr><td>RenderTarget[0].LogicOp</td><td>D3D11_LOGIC_OP_NOOP</td></tr> <tr><td>RenderTarget[0].RenderTargetWriteMask</td><td>D3D11_COLOR_WRITE_ENABLE_ALL</td></tr> </table><p>?</p><p> If the driver type is set to <strong>D3D_DRIVER_TYPE_HARDWARE</strong>, the feature level is set to less than or equal to <strong>D3D_FEATURE_LEVEL_9_3</strong>, and the pixel format of the render target is set to <strong>DXGI_FORMAT_R8G8B8A8_UNORM_SRGB</strong>, <strong>DXGI_FORMAT_B8G8R8A8_UNORM_SRGB</strong>, or <strong>DXGI_FORMAT_B8G8R8X8_UNORM_SRGB</strong>, the display device performs the blend in standard RGB (sRGB) space and not in linear space. However, if the feature level is set to greater than <strong>D3D_FEATURE_LEVEL_9_3</strong>, the display device performs the blend in linear space, which is ideal. </p><p> When you set the <strong>LogicOpEnable</strong> member of the first element of the <strong>RenderTarget</strong> array (<strong>RenderTarget</strong>[0]) to <strong>TRUE</strong>, you must also set the <strong>BlendEnable</strong> member of  <strong>RenderTarget</strong>[0] to <strong><see cref = "SharpDX.Result.False"/></strong>, and the <strong>IndependentBlendEnable</strong> member of  this <strong><see cref = "SharpDX.Direct3D11.BlendStateDescription1"/></strong> to <strong><see cref = "SharpDX.Result.False"/></strong>.  This reflects the limitation in hardware that you can't mix logic operations with blending across multiple render targets, and that when you use a logic operation, you must apply the same logic operation to all render targets. </p>
    /// </remarks>
    /// <doc-id>hh404435</doc-id>
    /// <unmanaged>D3D11_BLEND_DESC1</unmanaged>
    /// <unmanaged-short>D3D11_BLEND_DESC1</unmanaged-short>
    public partial struct BlendStateDescription1
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh404435</doc-id>
        /// <unmanaged>AlphaToCoverageEnable</unmanaged>
        /// <unmanaged-short>AlphaToCoverageEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool AlphaToCoverageEnable;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh404435</doc-id>
        /// <unmanaged>IndependentBlendEnable</unmanaged>
        /// <unmanaged-short>IndependentBlendEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IndependentBlendEnable;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh404435</doc-id>
        /// <unmanaged>RenderTarget</unmanaged>
        /// <unmanaged-short>RenderTarget</unmanaged-short>
        public SharpDX.Direct3D11.RenderTargetBlendDescription1[] RenderTarget
        {
            get => _RenderTarget ?? (_RenderTarget = new SharpDX.Direct3D11.RenderTargetBlendDescription1[8]);
            private set => _RenderTarget = value;
        }

        internal SharpDX.Direct3D11.RenderTargetBlendDescription1[] _RenderTarget;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Mathematics.Interop.RawBool AlphaToCoverageEnable;
            public SharpDX.Mathematics.Interop.RawBool IndependentBlendEnable;
            public SharpDX.Direct3D11.RenderTargetBlendDescription1 RenderTarget;
            public SharpDX.Direct3D11.RenderTargetBlendDescription1 __RenderTarget1;
            public SharpDX.Direct3D11.RenderTargetBlendDescription1 __RenderTarget2;
            public SharpDX.Direct3D11.RenderTargetBlendDescription1 __RenderTarget3;
            public SharpDX.Direct3D11.RenderTargetBlendDescription1 __RenderTarget4;
            public SharpDX.Direct3D11.RenderTargetBlendDescription1 __RenderTarget5;
            public SharpDX.Direct3D11.RenderTargetBlendDescription1 __RenderTarget6;
            public SharpDX.Direct3D11.RenderTargetBlendDescription1 __RenderTarget7;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            AlphaToCoverageEnable = @ref.AlphaToCoverageEnable;
            IndependentBlendEnable = @ref.IndependentBlendEnable;
            fixed (void *__to = &RenderTarget[0], __from = &@ref.RenderTarget)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 8 * sizeof (SharpDX.Direct3D11.RenderTargetBlendDescription1));
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.AlphaToCoverageEnable = AlphaToCoverageEnable;
            @ref.IndependentBlendEnable = IndependentBlendEnable;
            fixed (void *__from = &RenderTarget[0], __to = &@ref.RenderTarget)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 8 * sizeof (SharpDX.Direct3D11.RenderTargetBlendDescription1));
        }
    }

    /// <summary>
    /// <p>Describes a buffer resource.</p>
    /// </summary>
    /// <remarks>
    /// <p>This structure is used by <strong>ID3D11Device::CreateBuffer</strong> to create buffer resources.</p><p>In addition to this structure, you can also use the <strong>CD3D11_BUFFER_DESC</strong> derived structure, which is defined  in D3D11.h and behaves like an inherited class, to help create a buffer description.</p><p>If the bind flag is <strong>D3D11_BIND_CONSTANT_BUFFER</strong>, you must set the <strong>ByteWidth</strong> value in multiples of 16, and less than or equal to <strong>D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT</strong>.</p>
    /// </remarks>
    /// <doc-id>ff476092</doc-id>
    /// <unmanaged>D3D11_BUFFER_DESC</unmanaged>
    /// <unmanaged-short>D3D11_BUFFER_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct BufferDescription
    {
        /// <summary>
        /// <dd> <p>Size of the buffer in bytes.</p> </dd>
        /// </summary>
        /// <doc-id>ff476092</doc-id>
        /// <unmanaged>ByteWidth</unmanaged>
        /// <unmanaged-short>ByteWidth</unmanaged-short>
        public System.Int32 SizeInBytes;
        /// <summary>
        /// <dd> <p>Identify how the buffer is expected to be read from and written to. Frequency of update is a key factor. The most common value is typically D3D11_USAGE_DEFAULT; see <strong><see cref = "SharpDX.Direct3D11.ResourceUsage"/></strong> for all possible values.</p> </dd>
        /// </summary>
        /// <doc-id>ff476092</doc-id>
        /// <unmanaged>Usage</unmanaged>
        /// <unmanaged-short>Usage</unmanaged-short>
        public SharpDX.Direct3D11.ResourceUsage Usage;
        /// <summary>
        /// <dd> <p>Identify how the buffer will be bound to the pipeline. Flags (see <strong><see cref = "SharpDX.Direct3D11.BindFlags"/></strong>) can be combined with a logical OR.</p> </dd>
        /// </summary>
        /// <doc-id>ff476092</doc-id>
        /// <unmanaged>BindFlags</unmanaged>
        /// <unmanaged-short>BindFlags</unmanaged-short>
        public SharpDX.Direct3D11.BindFlags BindFlags;
        /// <summary>
        /// <dd> <p>CPU access flags (see <strong><see cref = "SharpDX.Direct3D11.CpuAccessFlags"/></strong>) or 0 if no CPU access is necessary. Flags can be combined with a logical OR.</p> </dd>
        /// </summary>
        /// <doc-id>ff476092</doc-id>
        /// <unmanaged>CPUAccessFlags</unmanaged>
        /// <unmanaged-short>CPUAccessFlags</unmanaged-short>
        public SharpDX.Direct3D11.CpuAccessFlags CpuAccessFlags;
        /// <summary>
        /// <dd> <p>Miscellaneous flags (see <strong><see cref = "SharpDX.Direct3D11.ResourceOptionFlags"/></strong>) or 0 if unused. Flags can be combined with a logical OR.</p> </dd>
        /// </summary>
        /// <doc-id>ff476092</doc-id>
        /// <unmanaged>MiscFlags</unmanaged>
        /// <unmanaged-short>MiscFlags</unmanaged-short>
        public SharpDX.Direct3D11.ResourceOptionFlags OptionFlags;
        /// <summary>
        /// <dd> <p>The size of each element in the buffer structure (in bytes) when the buffer represents a structured buffer. For more info about structured buffers, see Structured Buffer.</p> <p>The size value in <strong>StructureByteStride</strong> must match the size of the format that you use for views of the buffer. For example, if you use a shader resource view (SRV) to read a buffer in a pixel shader, the SRV format size must match the size value in <strong>StructureByteStride</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>ff476092</doc-id>
        /// <unmanaged>StructureByteStride</unmanaged>
        /// <unmanaged-short>StructureByteStride</unmanaged-short>
        public System.Int32 StructureByteStride;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>CD3D11_VIDEO_DEFAULT</unmanaged>
    /// <unmanaged-short>CD3D11_VIDEO_DEFAULT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct Cd3d11VideoDefault
    {
    }

    /// <summary>
    /// <p>Describes an HLSL class instance.</p>
    /// </summary>
    /// <remarks>
    /// <p>The <see cref = "SharpDX.Direct3D11.ClassInstanceDescription"/> structure is returned by the <strong>ID3D11ClassInstance::GetDesc</strong> method.</p><p>The members of this structure except <strong>InstanceIndex</strong> are valid (non default values) if they describe a class instance aquired using  <strong>ID3D11ClassLinkage::CreateClassInstance</strong>.  The <strong>InstanceIndex</strong> member is only valid when the class instance is aquired using <strong>ID3D11ClassLinkage::GetClassInstance</strong>.</p>
    /// </remarks>
    /// <doc-id>ff476098</doc-id>
    /// <unmanaged>D3D11_CLASS_INSTANCE_DESC</unmanaged>
    /// <unmanaged-short>D3D11_CLASS_INSTANCE_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ClassInstanceDescription
    {
        /// <summary>
        /// <dd> <p>The instance ID of an HLSL class; the default value is 0.</p> </dd>
        /// </summary>
        /// <doc-id>ff476098</doc-id>
        /// <unmanaged>InstanceId</unmanaged>
        /// <unmanaged-short>InstanceId</unmanaged-short>
        public System.Int32 InstanceId;
        /// <summary>
        /// <dd> <p>The instance index of an HLSL class; the default value is 0.</p> </dd>
        /// </summary>
        /// <doc-id>ff476098</doc-id>
        /// <unmanaged>InstanceIndex</unmanaged>
        /// <unmanaged-short>InstanceIndex</unmanaged-short>
        public System.Int32 InstanceIndex;
        /// <summary>
        /// <dd> <p>The type ID of an HLSL class; the default value is 0.</p> </dd>
        /// </summary>
        /// <doc-id>ff476098</doc-id>
        /// <unmanaged>TypeId</unmanaged>
        /// <unmanaged-short>TypeId</unmanaged-short>
        public System.Int32 TypeId;
        /// <summary>
        /// <dd> <p>Describes the constant buffer associated with an HLSL class; the default value is 0.</p> </dd>
        /// </summary>
        /// <doc-id>ff476098</doc-id>
        /// <unmanaged>ConstantBuffer</unmanaged>
        /// <unmanaged-short>ConstantBuffer</unmanaged-short>
        public System.Int32 ConstantBuffer;
        /// <summary>
        /// <dd> <p>The base constant buffer offset associated with an HLSL class; the default value is 0.</p> </dd>
        /// </summary>
        /// <doc-id>ff476098</doc-id>
        /// <unmanaged>BaseConstantBufferOffset</unmanaged>
        /// <unmanaged-short>BaseConstantBufferOffset</unmanaged-short>
        public System.Int32 BaseConstantBufferOffset;
        /// <summary>
        /// <dd> <p>The base texture associated with an HLSL class; the default value is 127.</p> </dd>
        /// </summary>
        /// <doc-id>ff476098</doc-id>
        /// <unmanaged>BaseTexture</unmanaged>
        /// <unmanaged-short>BaseTexture</unmanaged-short>
        public System.Int32 BaseTexture;
        /// <summary>
        /// <dd> <p>The base sampler associated with an HLSL class; the default value is 15.</p> </dd>
        /// </summary>
        /// <doc-id>ff476098</doc-id>
        /// <unmanaged>BaseSampler</unmanaged>
        /// <unmanaged-short>BaseSampler</unmanaged-short>
        public System.Int32 BaseSampler;
        /// <summary>
        /// <dd> <p>True if the class was created; the default value is false.</p> </dd>
        /// </summary>
        /// <doc-id>ff476098</doc-id>
        /// <unmanaged>Created</unmanaged>
        /// <unmanaged-short>Created</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsCreated;
    }

    /// <summary>
    /// <p>Information about the video card's performance counter capabilities.</p>
    /// </summary>
    /// <remarks>
    /// <p>This structure is returned by <strong>ID3D11Device::CheckCounterInfo</strong>.</p>
    /// </remarks>
    /// <doc-id>ff476104</doc-id>
    /// <unmanaged>D3D11_COUNTER_INFO</unmanaged>
    /// <unmanaged-short>D3D11_COUNTER_INFO</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct CounterCapabilities
    {
        /// <summary>
        /// <dd> <p>Largest device-dependent counter ID that the device supports. If none are supported, this value will be 0. Otherwise it will be greater than or equal to D3D11_COUNTER_DEVICE_DEPENDENT_0. See <strong><see cref = "SharpDX.Direct3D11.CounterKind"/></strong>.</p> </dd>
        /// </summary>
        /// <doc-id>ff476104</doc-id>
        /// <unmanaged>LastDeviceDependentCounter</unmanaged>
        /// <unmanaged-short>LastDeviceDependentCounter</unmanaged-short>
        public SharpDX.Direct3D11.CounterKind LastDeviceDependentCounter;
        /// <summary>
        /// <dd> <p>Number of counters that can be simultaneously supported.</p> </dd>
        /// </summary>
        /// <doc-id>ff476104</doc-id>
        /// <unmanaged>NumSimultaneousCounters</unmanaged>
        /// <unmanaged-short>NumSimultaneousCounters</unmanaged-short>
        public System.Int32 SimultaneousCounterCount;
        /// <summary>
        /// <dd> <p>Number of detectable parallel units that the counter is able to discern. Values are 1 ~ 4. Use NumDetectableParallelUnits to interpret the values of the VERTEX_PROCESSING, GEOMETRY_PROCESSING, PIXEL_PROCESSING, and OTHER_GPU_PROCESSING counters. </p> </dd>
        /// </summary>
        /// <doc-id>ff476104</doc-id>
        /// <unmanaged>NumDetectableParallelUnits</unmanaged>
        /// <unmanaged-short>NumDetectableParallelUnits</unmanaged-short>
        public System.Byte DetectableParallelUnitCount;
    }

    /// <summary>
    /// <p>Describes a counter.</p>
    /// </summary>
    /// <remarks>
    /// <p>This structure is used by <strong>ID3D11Counter::GetDesc</strong>, <strong>ID3D11Device::CheckCounter</strong> and <strong>ID3D11Device::CreateCounter</strong>.</p>
    /// </remarks>
    /// <doc-id>ff476103</doc-id>
    /// <unmanaged>D3D11_COUNTER_DESC</unmanaged>
    /// <unmanaged-short>D3D11_COUNTER_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct CounterDescription
    {
        /// <summary>
        /// <dd> <p>Type of counter (see <strong><see cref = "SharpDX.Direct3D11.CounterKind"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476103</doc-id>
        /// <unmanaged>Counter</unmanaged>
        /// <unmanaged-short>Counter</unmanaged-short>
        public SharpDX.Direct3D11.CounterKind Counter;
        /// <summary>
        /// <dd> <p>Reserved.</p> </dd>
        /// </summary>
        /// <doc-id>ff476103</doc-id>
        /// <unmanaged>MiscFlags</unmanaged>
        /// <unmanaged-short>MiscFlags</unmanaged-short>
        public System.Int32 MiscFlags;
    }

    /// <summary>
    /// <p> Used with <strong>ID3D11On12Device::CreateWrappedResource</strong> to override flags that would be inferred by the resource properties or heap properties, including bind flags, misc flags, and CPU access flags. </p>
    /// </summary>
    /// <remarks>
    /// <p> Use this structure with <strong>CreateWrappedResource</strong>. </p>
    /// </remarks>
    /// <doc-id>dn914753</doc-id>
    /// <unmanaged>D3D11_RESOURCE_FLAGS</unmanaged>
    /// <unmanaged-short>D3D11_RESOURCE_FLAGS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct D3D11ResourceFlags
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn914753</doc-id>
        /// <unmanaged>BindFlags</unmanaged>
        /// <unmanaged-short>BindFlags</unmanaged-short>
        public System.Int32 BindFlags;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn914753</doc-id>
        /// <unmanaged>MiscFlags</unmanaged>
        /// <unmanaged-short>MiscFlags</unmanaged-short>
        public System.Int32 MiscFlags;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn914753</doc-id>
        /// <unmanaged>CPUAccessFlags</unmanaged>
        /// <unmanaged-short>CPUAccessFlags</unmanaged-short>
        public System.Int32 CPUAccessFlags;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn914753</doc-id>
        /// <unmanaged>StructureByteStride</unmanaged>
        /// <unmanaged-short>StructureByteStride</unmanaged-short>
        public System.Int32 StructureByteStride;
    }

    /// <summary>
    /// <p>Stencil operations that can be performed based on the results of stencil test.</p>
    /// </summary>
    /// <remarks>
    /// <p>All stencil operations are specified as a <strong><see cref = "SharpDX.Direct3D11.StencilOperation"/></strong>. The stencil operation can be set differently based on the outcome of the stencil test (which is referred to as <strong>StencilFunc</strong> in the stencil test portion of depth-stencil testing.</p><p>This structure is a member of a <strong>depth-stencil description</strong>. </p>
    /// </remarks>
    /// <doc-id>ff476109</doc-id>
    /// <unmanaged>D3D11_DEPTH_STENCILOP_DESC</unmanaged>
    /// <unmanaged-short>D3D11_DEPTH_STENCILOP_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct DepthStencilOperationDescription
    {
        /// <summary>
        /// <dd> <p>The stencil operation to perform when stencil testing fails.</p> </dd>
        /// </summary>
        /// <doc-id>ff476109</doc-id>
        /// <unmanaged>StencilFailOp</unmanaged>
        /// <unmanaged-short>StencilFailOp</unmanaged-short>
        public SharpDX.Direct3D11.StencilOperation FailOperation;
        /// <summary>
        /// <dd> <p>The stencil operation to perform when stencil testing passes and depth testing fails.</p> </dd>
        /// </summary>
        /// <doc-id>ff476109</doc-id>
        /// <unmanaged>StencilDepthFailOp</unmanaged>
        /// <unmanaged-short>StencilDepthFailOp</unmanaged-short>
        public SharpDX.Direct3D11.StencilOperation DepthFailOperation;
        /// <summary>
        /// <dd> <p>The stencil operation to perform when stencil testing and depth testing both pass.</p> </dd>
        /// </summary>
        /// <doc-id>ff476109</doc-id>
        /// <unmanaged>StencilPassOp</unmanaged>
        /// <unmanaged-short>StencilPassOp</unmanaged-short>
        public SharpDX.Direct3D11.StencilOperation PassOperation;
        /// <summary>
        /// <dd> <p>A function that compares stencil data against existing stencil data. The function options are listed in <strong><see cref = "SharpDX.Direct3D11.Comparison"/></strong>.</p> </dd>
        /// </summary>
        /// <doc-id>ff476109</doc-id>
        /// <unmanaged>StencilFunc</unmanaged>
        /// <unmanaged-short>StencilFunc</unmanaged-short>
        public SharpDX.Direct3D11.Comparison Comparison;
    }

    /// <summary>
    /// <p>Describes depth-stencil state.</p>
    /// </summary>
    /// <remarks>
    /// <p>Pass a reference to <strong><see cref = "SharpDX.Direct3D11.DepthStencilStateDescription"/></strong> to the  <strong>ID3D11Device::CreateDepthStencilState</strong> method to create the depth-stencil state object.</p><p>Depth-stencil state controls how depth-stencil testing is performed by the output-merger stage.</p><p>The following table shows the default values of depth-stencil states.</p><table> <tr><th>State</th><th>Default Value</th></tr> <tr><td>DepthEnable</td><td>TRUE</td></tr> <tr><td>DepthWriteMask</td><td>D3D11_DEPTH_WRITE_MASK_ALL</td></tr> <tr><td>DepthFunc</td><td>D3D11_COMPARISON_LESS</td></tr> <tr><td>StencilEnable</td><td><see cref = "SharpDX.Result.False"/></td></tr> <tr><td>StencilReadMask</td><td>D3D11_DEFAULT_STENCIL_READ_MASK</td></tr> <tr><td>StencilWriteMask</td><td>D3D11_DEFAULT_STENCIL_WRITE_MASK</td></tr> <tr><td> <p>FrontFace.StencilFunc</p> <p>and</p> <p>BackFace.StencilFunc</p> </td><td>D3D11_COMPARISON_ALWAYS</td></tr> <tr><td> <p>FrontFace.StencilDepthFailOp</p> <p>and</p> <p>BackFace.StencilDepthFailOp</p> </td><td>D3D11_STENCIL_OP_KEEP</td></tr> <tr><td> <p>FrontFace.StencilPassOp</p> <p>and</p> <p>BackFace.StencilPassOp</p> </td><td>D3D11_STENCIL_OP_KEEP</td></tr> <tr><td> <p>FrontFace.StencilFailOp</p> <p>and</p> <p>BackFace.StencilFailOp</p> </td><td>D3D11_STENCIL_OP_KEEP</td></tr> </table><p>?</p><p>The formats that support stenciling are DXGI_FORMAT_D24_UNORM_S8_UINT and DXGI_FORMAT_D32_FLOAT_S8X24_UINT.</p>
    /// </remarks>
    /// <doc-id>ff476110</doc-id>
    /// <unmanaged>D3D11_DEPTH_STENCIL_DESC</unmanaged>
    /// <unmanaged-short>D3D11_DEPTH_STENCIL_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct DepthStencilStateDescription
    {
        /// <summary>
        /// <dd> <p>Enable depth testing.</p> </dd>
        /// </summary>
        /// <doc-id>ff476110</doc-id>
        /// <unmanaged>DepthEnable</unmanaged>
        /// <unmanaged-short>DepthEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsDepthEnabled;
        /// <summary>
        /// <dd> <p>Identify a portion of the depth-stencil buffer that can be modified by depth data (see <strong><see cref = "SharpDX.Direct3D11.DepthWriteMask"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476110</doc-id>
        /// <unmanaged>DepthWriteMask</unmanaged>
        /// <unmanaged-short>DepthWriteMask</unmanaged-short>
        public SharpDX.Direct3D11.DepthWriteMask DepthWriteMask;
        /// <summary>
        /// <dd> <p>A function that compares depth data against existing depth data. The function options are listed in <strong><see cref = "SharpDX.Direct3D11.Comparison"/></strong>.</p> </dd>
        /// </summary>
        /// <doc-id>ff476110</doc-id>
        /// <unmanaged>DepthFunc</unmanaged>
        /// <unmanaged-short>DepthFunc</unmanaged-short>
        public SharpDX.Direct3D11.Comparison DepthComparison;
        /// <summary>
        /// <dd> <p>Enable stencil testing.</p> </dd>
        /// </summary>
        /// <doc-id>ff476110</doc-id>
        /// <unmanaged>StencilEnable</unmanaged>
        /// <unmanaged-short>StencilEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsStencilEnabled;
        /// <summary>
        /// <dd> <p>Identify a portion of the depth-stencil buffer for reading stencil data.</p> </dd>
        /// </summary>
        /// <doc-id>ff476110</doc-id>
        /// <unmanaged>StencilReadMask</unmanaged>
        /// <unmanaged-short>StencilReadMask</unmanaged-short>
        public System.Byte StencilReadMask;
        /// <summary>
        /// <dd> <p>Identify a portion of the depth-stencil buffer for writing stencil data.</p> </dd>
        /// </summary>
        /// <doc-id>ff476110</doc-id>
        /// <unmanaged>StencilWriteMask</unmanaged>
        /// <unmanaged-short>StencilWriteMask</unmanaged-short>
        public System.Byte StencilWriteMask;
        /// <summary>
        /// <dd> <p>Identify how to use the results of the depth test and the stencil test for pixels whose surface normal is facing towards the camera (see <strong><see cref = "SharpDX.Direct3D11.DepthStencilOperationDescription"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476110</doc-id>
        /// <unmanaged>FrontFace</unmanaged>
        /// <unmanaged-short>FrontFace</unmanaged-short>
        public SharpDX.Direct3D11.DepthStencilOperationDescription FrontFace;
        /// <summary>
        /// <dd> <p>Identify how to use the results of the depth test and the stencil test for pixels whose surface normal is facing away from the camera (see <strong><see cref = "SharpDX.Direct3D11.DepthStencilOperationDescription"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476110</doc-id>
        /// <unmanaged>BackFace</unmanaged>
        /// <unmanaged-short>BackFace</unmanaged-short>
        public SharpDX.Direct3D11.DepthStencilOperationDescription BackFace;
    }

    /// <summary>
    /// <p>Specifies the subresources of a texture that are accessible from a depth-stencil view.</p>
    /// </summary>
    /// <remarks>
    /// <p>These are valid formats for a depth-stencil view:</p><ul> <li>DXGI_FORMAT_D16_UNORM</li> <li>DXGI_FORMAT_D24_UNORM_S8_UINT</li> <li>DXGI_FORMAT_D32_FLOAT</li> <li>DXGI_FORMAT_D32_FLOAT_S8X24_UINT</li> <li>DXGI_FORMAT_UNKNOWN</li> </ul><p>A depth-stencil view cannot use a typeless format.  If the format chosen is DXGI_FORMAT_UNKNOWN, then the format of the parent resource is used.</p><p>A depth-stencil-view description is needed when calling <strong>ID3D11Device::CreateDepthStencilView</strong>.</p>
    /// </remarks>
    /// <doc-id>ff476112</doc-id>
    /// <unmanaged>D3D11_DEPTH_STENCIL_VIEW_DESC</unmanaged>
    /// <unmanaged-short>D3D11_DEPTH_STENCIL_VIEW_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct DepthStencilViewDescription
    {
        /// <summary>
        /// <p>Specifies the subresource from a 1D texture that is accessible to a depth-stencil view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a depth-stencil-view description (see <strong><see cref = "SharpDX.Direct3D11.DepthStencilViewDescription"/></strong>).</p>
        /// </remarks>
        /// <doc-id>ff476229</doc-id>
        /// <unmanaged>D3D11_TEX1D_DSV</unmanaged>
        /// <unmanaged-short>D3D11_TEX1D_DSV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture1DResource
        {
            /// <summary>
            /// <dd> <p>The index of the first mipmap level to use.</p> </dd>
            /// </summary>
            /// <doc-id>ff476229</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
        }

        /// <summary>
        /// <p>Specifies the subresources from an array of 1D textures to use in a depth-stencil view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a depth-stencil-view description (see <strong><see cref = "SharpDX.Direct3D11.DepthStencilViewDescription"/></strong>).</p>
        /// </remarks>
        /// <doc-id>ff476225</doc-id>
        /// <unmanaged>D3D11_TEX1D_ARRAY_DSV</unmanaged>
        /// <unmanaged-short>D3D11_TEX1D_ARRAY_DSV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture1DArrayResource
        {
            /// <summary>
            /// <dd> <p>The index of the first mipmap level to use.</p> </dd>
            /// </summary>
            /// <doc-id>ff476225</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
            /// <summary>
            /// <dd> <p>The index of the first texture to use in an array of textures.</p> </dd>
            /// </summary>
            /// <doc-id>ff476225</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p>Number of textures to use.</p> </dd>
            /// </summary>
            /// <doc-id>ff476225</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
        }

        /// <summary>
        /// <p>Specifies the subresource from a 2D texture that is accessible to a depth-stencil view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a depth-stencil-view description (see <strong><see cref = "SharpDX.Direct3D11.DepthStencilViewDescription"/></strong>).</p>
        /// </remarks>
        /// <doc-id>ff476243</doc-id>
        /// <unmanaged>D3D11_TEX2D_DSV</unmanaged>
        /// <unmanaged-short>D3D11_TEX2D_DSV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DResource
        {
            /// <summary>
            /// <dd> <p>The index of the first mipmap level to use.</p> </dd>
            /// </summary>
            /// <doc-id>ff476243</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
        }

        /// <summary>
        /// <p>Specifies the subresources from an array 2D textures that are accessible to a depth-stencil view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a depth-stencil-view description (see <strong><see cref = "SharpDX.Direct3D11.DepthStencilViewDescription"/></strong>).</p>
        /// </remarks>
        /// <doc-id>ff476239</doc-id>
        /// <unmanaged>D3D11_TEX2D_ARRAY_DSV</unmanaged>
        /// <unmanaged-short>D3D11_TEX2D_ARRAY_DSV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DArrayResource
        {
            /// <summary>
            /// <dd> <p>The index of the first mipmap level to use.</p> </dd>
            /// </summary>
            /// <doc-id>ff476239</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
            /// <summary>
            /// <dd> <p>The index of the first texture to use in an array of textures.</p> </dd>
            /// </summary>
            /// <doc-id>ff476239</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p>Number of textures to use.</p> </dd>
            /// </summary>
            /// <doc-id>ff476239</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
        }

        /// <summary>
        /// <p>Specifies the subresource from a multisampled 2D texture that is accessible to a depth-stencil view.</p>
        /// </summary>
        /// <remarks>
        /// <p>Because a multisampled 2D texture contains a single subtexture, there is nothing to specify; this unused member is included so that this structure will compile in C.</p>
        /// </remarks>
        /// <doc-id>ff476236</doc-id>
        /// <unmanaged>D3D11_TEX2DMS_DSV</unmanaged>
        /// <unmanaged-short>D3D11_TEX2DMS_DSV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DMultisampledResource
        {
            /// <summary>
            /// <dd> <p>Unused.</p> </dd>
            /// </summary>
            /// <doc-id>ff476236</doc-id>
            /// <unmanaged>UnusedField_NothingToDefine</unmanaged>
            /// <unmanaged-short>UnusedField_NothingToDefine</unmanaged-short>
            public System.Int32 UnusedFieldNothingToDefine;
        }

        /// <summary>
        /// <p>Specifies the subresources from an array of multisampled 2D textures for a depth-stencil view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a depth-stencil-view description (see <strong><see cref = "SharpDX.Direct3D11.DepthStencilViewDescription"/></strong>).</p>
        /// </remarks>
        /// <doc-id>ff476233</doc-id>
        /// <unmanaged>D3D11_TEX2DMS_ARRAY_DSV</unmanaged>
        /// <unmanaged-short>D3D11_TEX2DMS_ARRAY_DSV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DMultisampledArrayResource
        {
            /// <summary>
            /// <dd> <p>The index of the first texture to use in an array of textures.</p> </dd>
            /// </summary>
            /// <doc-id>ff476233</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p>Number of textures to use.</p> </dd>
            /// </summary>
            /// <doc-id>ff476233</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
        }

        /// <summary>
        /// <dd> <p>Resource data  format (see <strong><see cref = "SharpDX.DXGI.Format"/></strong>). See remarks for allowable formats.</p> </dd>
        /// </summary>
        /// <doc-id>ff476112</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p>Type of resource (see <strong><see cref = "SharpDX.Direct3D11.DepthStencilViewDimension"/></strong>). Specifies how a depth-stencil resource will be accessed; the value is stored in the  union in this structure.</p> </dd>
        /// </summary>
        /// <doc-id>ff476112</doc-id>
        /// <unmanaged>ViewDimension</unmanaged>
        /// <unmanaged-short>ViewDimension</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(4)]
        public SharpDX.Direct3D11.DepthStencilViewDimension Dimension;
        /// <summary>
        /// <dd> <p>A value that describes whether the texture is read only.  Pass 0 to specify that it is not read only; otherwise, pass one of the members of  the <strong><see cref = "SharpDX.Direct3D11.DepthStencilViewFlags"/></strong> enumerated type.</p> </dd>
        /// </summary>
        /// <doc-id>ff476112</doc-id>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.DepthStencilViewFlags Flags;
        /// <summary>
        /// <dd> <p>Specifies a 1D texture subresource (see <strong><see cref = "SharpDX.Direct3D11.Texture1DResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476112</doc-id>
        /// <unmanaged>Texture1D</unmanaged>
        /// <unmanaged-short>Texture1D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(12)]
        public SharpDX.Direct3D11.DepthStencilViewDescription.Texture1DResource Texture1D;
        /// <summary>
        /// <dd> <p>Specifies an array of 1D texture subresources (see <strong><see cref = "SharpDX.Direct3D11.Texture1DArrayResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476112</doc-id>
        /// <unmanaged>Texture1DArray</unmanaged>
        /// <unmanaged-short>Texture1DArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(12)]
        public SharpDX.Direct3D11.DepthStencilViewDescription.Texture1DArrayResource Texture1DArray;
        /// <summary>
        /// <dd> <p>Specifies a 2D texture subresource (see <strong><see cref = "SharpDX.Direct3D11.Texture2DResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476112</doc-id>
        /// <unmanaged>Texture2D</unmanaged>
        /// <unmanaged-short>Texture2D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(12)]
        public SharpDX.Direct3D11.DepthStencilViewDescription.Texture2DResource Texture2D;
        /// <summary>
        /// <dd> <p>Specifies an array of 2D texture subresources (see <strong><see cref = "SharpDX.Direct3D11.Texture2DArrayResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476112</doc-id>
        /// <unmanaged>Texture2DArray</unmanaged>
        /// <unmanaged-short>Texture2DArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(12)]
        public SharpDX.Direct3D11.DepthStencilViewDescription.Texture2DArrayResource Texture2DArray;
        /// <summary>
        /// <dd> <p>Specifies a multisampled 2D texture (see <strong><see cref = "SharpDX.Direct3D11.Texture2DMultisampledResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476112</doc-id>
        /// <unmanaged>Texture2DMS</unmanaged>
        /// <unmanaged-short>Texture2DMS</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(12)]
        public SharpDX.Direct3D11.DepthStencilViewDescription.Texture2DMultisampledResource Texture2DMS;
        /// <summary>
        /// <dd> <p>Specifies an array of multisampled 2D textures (see <strong><see cref = "SharpDX.Direct3D11.Texture2DMultisampledArrayResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476112</doc-id>
        /// <unmanaged>Texture2DMSArray</unmanaged>
        /// <unmanaged-short>Texture2DMSArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(12)]
        public SharpDX.Direct3D11.DepthStencilViewDescription.Texture2DMultisampledArrayResource Texture2DMSArray;
    }

    /// <summary>
    /// <p> Arguments for draw indexed instanced indirect. </p>
    /// </summary>
    /// <remarks>
    /// <p> The members of this structure serve the same purpose as the parameters of <strong>ID3D11DeviceContext::DrawIndexedInstanced</strong>. </p>
    /// </remarks>
    /// <doc-id>dn912868</doc-id>
    /// <unmanaged>D3D11_DRAW_INDEXED_INSTANCED_INDIRECT_ARGS</unmanaged>
    /// <unmanaged-short>D3D11_DRAW_INDEXED_INSTANCED_INDIRECT_ARGS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct DrawIndexedInstancedIndirectArguments
    {
        /// <summary>
        /// <dd> <p> The number of indices read from the index buffer for each instance. </p> </dd>
        /// </summary>
        /// <doc-id>dn912868</doc-id>
        /// <unmanaged>IndexCountPerInstance</unmanaged>
        /// <unmanaged-short>IndexCountPerInstance</unmanaged-short>
        public System.Int32 IndexCountPerInstance;
        /// <summary>
        /// <dd> <p> The number of instances to draw. </p> </dd>
        /// </summary>
        /// <doc-id>dn912868</doc-id>
        /// <unmanaged>InstanceCount</unmanaged>
        /// <unmanaged-short>InstanceCount</unmanaged-short>
        public System.Int32 InstanceCount;
        /// <summary>
        /// <dd> <p> The location of the first index read by the GPU from the index buffer. </p> </dd>
        /// </summary>
        /// <doc-id>dn912868</doc-id>
        /// <unmanaged>StartIndexLocation</unmanaged>
        /// <unmanaged-short>StartIndexLocation</unmanaged-short>
        public System.Int32 StartIndexLocation;
        /// <summary>
        /// <dd> <p> A value added to each index before reading a vertex from the vertex buffer. </p> </dd>
        /// </summary>
        /// <doc-id>dn912868</doc-id>
        /// <unmanaged>BaseVertexLocation</unmanaged>
        /// <unmanaged-short>BaseVertexLocation</unmanaged-short>
        public System.Int32 BaseVertexLocation;
        /// <summary>
        /// <dd> <p> A value added to each index before reading per-instance data from a vertex buffer. </p> </dd>
        /// </summary>
        /// <doc-id>dn912868</doc-id>
        /// <unmanaged>StartInstanceLocation</unmanaged>
        /// <unmanaged-short>StartInstanceLocation</unmanaged-short>
        public System.Int32 StartInstanceLocation;
    }

    /// <summary>
    /// <p> Arguments for draw instanced indirect. </p>
    /// </summary>
    /// <remarks>
    /// <p> The members of this structure serve the same purpose as the parameters of <strong>ID3D11DeviceContext::DrawInstanced</strong>. </p>
    /// </remarks>
    /// <doc-id>dn912869</doc-id>
    /// <unmanaged>D3D11_DRAW_INSTANCED_INDIRECT_ARGS</unmanaged>
    /// <unmanaged-short>D3D11_DRAW_INSTANCED_INDIRECT_ARGS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct DrawInstancedIndirectArguments
    {
        /// <summary>
        /// <dd> <p> The number of vertices to draw. </p> </dd>
        /// </summary>
        /// <doc-id>dn912869</doc-id>
        /// <unmanaged>VertexCountPerInstance</unmanaged>
        /// <unmanaged-short>VertexCountPerInstance</unmanaged-short>
        public System.Int32 VertexCountPerInstance;
        /// <summary>
        /// <dd> <p> The number of instances to draw. </p> </dd>
        /// </summary>
        /// <doc-id>dn912869</doc-id>
        /// <unmanaged>InstanceCount</unmanaged>
        /// <unmanaged-short>InstanceCount</unmanaged-short>
        public System.Int32 InstanceCount;
        /// <summary>
        /// <dd> <p> The index of the first vertex. </p> </dd>
        /// </summary>
        /// <doc-id>dn912869</doc-id>
        /// <unmanaged>StartVertexLocation</unmanaged>
        /// <unmanaged-short>StartVertexLocation</unmanaged-short>
        public System.Int32 StartVertexLocation;
        /// <summary>
        /// <dd> <p> A value added to each index before reading per-instance data from a vertex buffer. </p> </dd>
        /// </summary>
        /// <doc-id>dn912869</doc-id>
        /// <unmanaged>StartInstanceLocation</unmanaged>
        /// <unmanaged-short>StartInstanceLocation</unmanaged-short>
        public System.Int32 StartInstanceLocation;
    }

    /// <summary>
    /// <p>Specifies which bytes in a video surface are encrypted. </p>
    /// </summary>
    /// <doc-id>hh447630</doc-id>
    /// <unmanaged>D3D11_ENCRYPTED_BLOCK_INFO</unmanaged>
    /// <unmanaged-short>D3D11_ENCRYPTED_BLOCK_INFO</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct EncryptedBlockInformation
    {
        /// <summary>
        /// <dd> <p>The number of bytes that are encrypted at the start of the buffer. </p> </dd>
        /// </summary>
        /// <doc-id>hh447630</doc-id>
        /// <unmanaged>NumEncryptedBytesAtBeginning</unmanaged>
        /// <unmanaged-short>NumEncryptedBytesAtBeginning</unmanaged-short>
        public System.Int32 NumEncryptedBytesAtBeginning;
        /// <summary>
        /// <dd> <p>The number of bytes that are skipped after the first <strong>NumEncryptedBytesAtBeginning</strong> bytes, and then after each block of <strong>NumBytesInEncryptPattern</strong> bytes. Skipped bytes are not encrypted. </p> </dd>
        /// </summary>
        /// <doc-id>hh447630</doc-id>
        /// <unmanaged>NumBytesInSkipPattern</unmanaged>
        /// <unmanaged-short>NumBytesInSkipPattern</unmanaged-short>
        public System.Int32 NumBytesInSkipPattern;
        /// <summary>
        /// <dd> <p>The number of bytes that are encrypted after each block of skipped bytes.</p> </dd>
        /// </summary>
        /// <doc-id>hh447630</doc-id>
        /// <unmanaged>NumBytesInEncryptPattern</unmanaged>
        /// <unmanaged-short>NumBytesInEncryptPattern</unmanaged-short>
        public System.Int32 NumBytesInEncryptPattern;
    }

    /// <summary>
    /// <strong>Note</strong>??This structure is supported by the Direct3D 11.1 runtime, which is available on Windows?8 and later operating systems.?<p>Describes information about Direct3D 11.1 adapter architecture.</p>
    /// </summary>
    /// <doc-id>hh404455</doc-id>
    /// <unmanaged>D3D11_FEATURE_DATA_ARCHITECTURE_INFO</unmanaged>
    /// <unmanaged-short>D3D11_FEATURE_DATA_ARCHITECTURE_INFO</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    internal partial struct FeatureDataArchitectureInformation
    {
        /// <summary>
        /// <dd> <p>Specifies whether a rendering device batches rendering commands and performs multipass rendering into tiles or bins over a render area. Certain API usage patterns that are fine for TileBasedDefferredRenderers (TBDRs) can perform worse on non-TBDRs and vice versa.  Applications that are careful about rendering can be friendly to both TBDR and non-TBDR architectures. <strong>TRUE</strong> if the rendering device batches rendering commands and <strong><see cref = "SharpDX.Result.False"/></strong> otherwise. </p> </dd>
        /// </summary>
        /// <doc-id>hh404455</doc-id>
        /// <unmanaged>TileBasedDeferredRenderer</unmanaged>
        /// <unmanaged-short>TileBasedDeferredRenderer</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool TileBasedDeferredRenderer;
    }

    /// <summary>
    /// <p>Describes compute shader and raw and structured buffer support in the current graphics driver.</p>
    /// </summary>
    /// <remarks>
    /// <p>Direct3D 11 devices (D3D_FEATURE_LEVEL_11_0) are required to support Compute Shader model 5.0.  Direct3D 10.x devices (D3D_FEATURE_LEVEL_10_0, D3D_FEATURE_LEVEL_10_1) can optionally support Compute Shader model 4.0 or 4.1.</p>
    /// </remarks>
    /// <doc-id>ff476126</doc-id>
    /// <unmanaged>D3D11_FEATURE_DATA_D3D10_X_HARDWARE_OPTIONS</unmanaged>
    /// <unmanaged-short>D3D11_FEATURE_DATA_D3D10_X_HARDWARE_OPTIONS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    internal partial struct FeatureDataD3D10XHardwareOptions
    {
        /// <summary>
        /// <dd> <p><strong>TRUE</strong> if compute shaders and raw and structured buffers are supported; otherwise <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd>
        /// </summary>
        /// <doc-id>ff476126</doc-id>
        /// <unmanaged>ComputeShaders_Plus_RawAndStructuredBuffers_Via_Shader_4_x</unmanaged>
        /// <unmanaged-short>ComputeShaders_Plus_RawAndStructuredBuffers_Via_Shader_4_x</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool ComputeShadersPlusRawAndStructuredBuffersViaShader4X;
    }

    /// <summary>
    /// <strong>Note</strong>??This structure is supported by the Direct3D 11.1 runtime, which is available on Windows?8 and later operating systems.?<p>Describes Direct3D 11.1 feature options in the current graphics driver.</p>
    /// </summary>
    /// <remarks>
    /// <p>If a Microsoft Direct3D device supports feature level 11.1 (<strong>D3D_FEATURE_LEVEL_11_1</strong>), when you call <strong>ID3D11Device::CheckFeatureSupport</strong> with <strong>D3D11_FEATURE_D3D11_OPTIONS</strong>, <strong>CheckFeatureSupport</strong> returns a reference to <strong><see cref = "SharpDX.Direct3D11.FeatureDataD3D11Options"/></strong> with all member set to <strong>TRUE</strong> except the <strong>SAD4ShaderInstructions</strong> and <strong>ExtendedDoublesShaderInstructions</strong> members, which are optionally supported by the hardware and driver and therefore can be <strong>TRUE</strong> or <strong><see cref = "SharpDX.Result.False"/></strong>.</p><p>Feature level 11.1  provides the following additional features:</p><ul> <li>UAVs at every shader stage with 64 UAV bind slots instead of 8.</li> <li>Target-independent rasterization, which enables you  to set the <strong>ForcedSampleCount</strong> member of <strong><see cref = "SharpDX.Direct3D11.RasterizerStateDescription1"/></strong> to 1, 4, 8, or 16 and to render to RTVs with a single sample.</li> <li>UAV-only rendering with the <strong>ForcedSampleCount</strong> member of <strong><see cref = "SharpDX.Direct3D11.RasterizerStateDescription1"/></strong> set to up to 16 (only up to 8 for feature level 11).</li> </ul><p>The runtime always sets the following groupings of members identically. That is, all the values in a grouping are <strong>TRUE</strong> or <strong><see cref = "SharpDX.Result.False"/></strong> together:</p><ul> <li><strong>DiscardAPIsSeenByDriver</strong> and <strong>FlagsForUpdateAndCopySeenByDriver</strong></li> <li><strong>ClearView</strong>, <strong>CopyWithOverlap</strong>, <strong>ConstantBufferPartialUpdate</strong>, <strong>ConstantBufferOffsetting</strong>, and <strong>MapNoOverwriteOnDynamicConstantBuffer</strong></li> <li><strong>MapNoOverwriteOnDynamicBufferSRV</strong> and <strong>MultisampleRTVWithForcedSampleCountOne</strong></li> </ul>
    /// </remarks>
    /// <doc-id>hh404457</doc-id>
    /// <unmanaged>D3D11_FEATURE_DATA_D3D11_OPTIONS</unmanaged>
    /// <unmanaged-short>D3D11_FEATURE_DATA_D3D11_OPTIONS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataD3D11Options
    {
        /// <summary>
        /// <dd> <p>Specifies whether logic operations are available in blend state. The runtime sets this member to <strong>TRUE</strong> if logic operations are available in blend state and <strong><see cref = "SharpDX.Result.False"/></strong> otherwise. This member is <strong><see cref = "SharpDX.Result.False"/></strong> for feature level 9.1, 9.2, and 9.3.  This member is optional for feature level 10, 10.1, and 11.  This member is <strong>TRUE</strong> for feature level 11.1.</p> </dd>
        /// </summary>
        /// <doc-id>hh404457</doc-id>
        /// <unmanaged>OutputMergerLogicOp</unmanaged>
        /// <unmanaged-short>OutputMergerLogicOp</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool OutputMergerLogicOp;
        /// <summary>
        /// <dd> <p>Specifies whether the driver can render with no render target views (RTVs) or depth stencil views (DSVs), and only unordered access views (UAVs) bound. The runtime sets this member to <strong>TRUE</strong> if  the driver can render with no RTVs or DSVs and only UAVs bound and <strong><see cref = "SharpDX.Result.False"/></strong> otherwise. If <strong>TRUE</strong>, you can set the <strong>ForcedSampleCount</strong> member of <strong><see cref = "SharpDX.Direct3D11.RasterizerStateDescription1"/></strong> to 1, 4, or 8 when you render with no RTVs or DSV and only UAVs bound.  For feature level 11.1, this member is always <strong>TRUE</strong> and you can also set <strong>ForcedSampleCount</strong> to 16 in addition to 1, 4, or 8.  The default value of <strong>ForcedSampleCount</strong> is 0, which means the same as if the value is set to 1. You can always set <strong>ForcedSampleCount</strong> to 0 or 1 for UAV-only rendering independently of how this member is set.</p> </dd>
        /// </summary>
        /// <doc-id>hh404457</doc-id>
        /// <unmanaged>UAVOnlyRenderingForcedSampleCount</unmanaged>
        /// <unmanaged-short>UAVOnlyRenderingForcedSampleCount</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool UAVOnlyRenderingForcedSampleCount;
        /// <summary>
        /// <dd> <p>Specifies whether the driver supports the <strong>ID3D11DeviceContext1::DiscardView</strong> and <strong>ID3D11DeviceContext1::DiscardResource</strong> methods. The runtime sets this member to <strong>TRUE</strong> if the driver supports these methods and <strong><see cref = "SharpDX.Result.False"/></strong> otherwise. How this member is set does not indicate whether the driver actually uses these methods; that is,   the driver might ignore these methods if they are not useful to the  hardware.  If <strong><see cref = "SharpDX.Result.False"/></strong>, the runtime does not expose these methods to the driver because the driver does not support them.  You can monitor this member during development to rule out legacy drivers on hardware where these methods might have otherwise been beneficial.  You are not required to write separate code paths based on whether this member is <strong>TRUE</strong> or <strong><see cref = "SharpDX.Result.False"/></strong>; you can call these methods whenever applicable.</p> </dd>
        /// </summary>
        /// <doc-id>hh404457</doc-id>
        /// <unmanaged>DiscardAPIsSeenByDriver</unmanaged>
        /// <unmanaged-short>DiscardAPIsSeenByDriver</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool DiscardAPIsSeenByDriver;
        /// <summary>
        /// <dd> <p>Specifies whether the driver supports new semantics for copy and update that are exposed by the <strong>ID3D11DeviceContext1::CopySubresourceRegion1</strong> and <strong>ID3D11DeviceContext1::UpdateSubresource1</strong> methods.  The runtime sets this member to <strong>TRUE</strong> if the driver supports new semantics for copy and update. The runtime sets this member to <strong><see cref = "SharpDX.Result.False"/></strong> only for legacy drivers. The runtime handles this member similarly to the <strong>DiscardAPIsSeenByDriver</strong> member.</p> </dd>
        /// </summary>
        /// <doc-id>hh404457</doc-id>
        /// <unmanaged>FlagsForUpdateAndCopySeenByDriver</unmanaged>
        /// <unmanaged-short>FlagsForUpdateAndCopySeenByDriver</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool FlagsForUpdateAndCopySeenByDriver;
        /// <summary>
        /// <dd> <p>Specifies whether the driver supports the <strong>ID3D11DeviceContext1::ClearView</strong> method. The runtime sets this member to <strong>TRUE</strong> if the driver supports this method and <strong><see cref = "SharpDX.Result.False"/></strong> otherwise. If <strong><see cref = "SharpDX.Result.False"/></strong>, the runtime does not expose this method to the driver because the driver does not support it.  </p> <strong>Note</strong>??For feature level 9.1, 9.2, and 9.3, this member is always <strong>TRUE</strong> because the option is emulated by the runtime. ? </dd>
        /// </summary>
        /// <doc-id>hh404457</doc-id>
        /// <unmanaged>ClearView</unmanaged>
        /// <unmanaged-short>ClearView</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool ClearView;
        /// <summary>
        /// <dd> <p>Specifies whether you can call <strong>ID3D11DeviceContext1::CopySubresourceRegion1</strong> with overlapping source and destination rectangles. The runtime sets this member to <strong>TRUE</strong> if  you can call <strong>CopySubresourceRegion1</strong> with overlapping source and destination rectangles and <strong><see cref = "SharpDX.Result.False"/></strong> otherwise. If <strong><see cref = "SharpDX.Result.False"/></strong>, the runtime does not expose this method to the driver because the driver does not support it.  </p> <strong>Note</strong>??For feature level 9.1, 9.2, and 9.3, this member is always <strong>TRUE</strong> because drivers already support the option for these feature levels. ? </dd>
        /// </summary>
        /// <doc-id>hh404457</doc-id>
        /// <unmanaged>CopyWithOverlap</unmanaged>
        /// <unmanaged-short>CopyWithOverlap</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool CopyWithOverlap;
        /// <summary>
        /// <dd> <p>Specifies whether the driver supports partial updates of constant buffers. The runtime sets this member to <strong>TRUE</strong> if  the driver supports partial updates of constant buffers and <strong><see cref = "SharpDX.Result.False"/></strong> otherwise. If <strong><see cref = "SharpDX.Result.False"/></strong>, the runtime does not expose this operation to the driver because the driver does not support it.  </p> <strong>Note</strong>??For feature level 9.1, 9.2, and 9.3, this member is always <strong>TRUE</strong> because the option is emulated by the runtime. ? </dd>
        /// </summary>
        /// <doc-id>hh404457</doc-id>
        /// <unmanaged>ConstantBufferPartialUpdate</unmanaged>
        /// <unmanaged-short>ConstantBufferPartialUpdate</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool ConstantBufferPartialUpdate;
        /// <summary>
        /// <dd> <p>Specifies whether the driver supports new semantics for setting offsets in constant buffers for a shader. The runtime sets this member to <strong>TRUE</strong> if  the driver supports allowing you to specify offsets when you call new methods like the <strong>ID3D11DeviceContext1::VSSetConstantBuffers1</strong> method and <strong><see cref = "SharpDX.Result.False"/></strong> otherwise. If <strong><see cref = "SharpDX.Result.False"/></strong>, the runtime does not expose this operation to the driver because the driver does not support it.    </p> <strong>Note</strong>??For feature level 9.1, 9.2, and 9.3, this member is always <strong>TRUE</strong> because the option is emulated by the runtime. ? </dd>
        /// </summary>
        /// <doc-id>hh404457</doc-id>
        /// <unmanaged>ConstantBufferOffsetting</unmanaged>
        /// <unmanaged-short>ConstantBufferOffsetting</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool ConstantBufferOffsetting;
        /// <summary>
        /// <dd> <p>Specifies whether you can call <strong>ID3D11DeviceContext::Map</strong> with <strong>D3D11_MAP_WRITE_NO_OVERWRITE</strong> on a dynamic constant buffer (that is, whether the driver supports this operation). The runtime sets this member to <strong>TRUE</strong> if  the driver supports this operation and <strong><see cref = "SharpDX.Result.False"/></strong> otherwise. If <strong><see cref = "SharpDX.Result.False"/></strong>, the runtime fails this method because the driver does not support the operation.  </p> <strong>Note</strong>??For feature level 9.1, 9.2, and 9.3, this member is always <strong>TRUE</strong> because the option is emulated by the runtime. ? </dd>
        /// </summary>
        /// <doc-id>hh404457</doc-id>
        /// <unmanaged>MapNoOverwriteOnDynamicConstantBuffer</unmanaged>
        /// <unmanaged-short>MapNoOverwriteOnDynamicConstantBuffer</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool MapNoOverwriteOnDynamicConstantBuffer;
        /// <summary>
        /// <dd> <p>Specifies whether you can call <strong>ID3D11DeviceContext::Map</strong> with <strong>D3D11_MAP_WRITE_NO_OVERWRITE</strong> on a dynamic buffer SRV (that is, whether the driver supports this operation). The runtime sets this member to <strong>TRUE</strong> if  the driver supports this operation and <strong><see cref = "SharpDX.Result.False"/></strong> otherwise. If <strong><see cref = "SharpDX.Result.False"/></strong>, the runtime fails this method because the driver does not support the operation.</p> </dd>
        /// </summary>
        /// <doc-id>hh404457</doc-id>
        /// <unmanaged>MapNoOverwriteOnDynamicBufferSRV</unmanaged>
        /// <unmanaged-short>MapNoOverwriteOnDynamicBufferSRV</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool MapNoOverwriteOnDynamicBufferSRV;
        /// <summary>
        /// <dd> <p>Specifies whether the driver supports multisample rendering when you render with RTVs bound. If <strong>TRUE</strong>, you can set the <strong>ForcedSampleCount</strong> member of <strong><see cref = "SharpDX.Direct3D11.RasterizerStateDescription1"/></strong> to 1 with a multisample RTV bound. The driver can support this option on feature level 10 and higher.  If <strong><see cref = "SharpDX.Result.False"/></strong>, the rasterizer-state creation will fail because the driver is legacy or the feature level is too low.</p> </dd>
        /// </summary>
        /// <doc-id>hh404457</doc-id>
        /// <unmanaged>MultisampleRTVWithForcedSampleCountOne</unmanaged>
        /// <unmanaged-short>MultisampleRTVWithForcedSampleCountOne</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool MultisampleRTVWithForcedSampleCountOne;
        /// <summary>
        /// <dd> <p>Specifies whether the hardware and driver support the <strong>msad4</strong> intrinsic function in shaders. The runtime sets this member to <strong>TRUE</strong> if  the hardware and driver support calls to <strong>msad4</strong> intrinsic functions in shaders. If <strong><see cref = "SharpDX.Result.False"/></strong>, the driver is legacy or the hardware does not support the option; the runtime will fail shader creation for shaders that use <strong>msad4</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>hh404457</doc-id>
        /// <unmanaged>SAD4ShaderInstructions</unmanaged>
        /// <unmanaged-short>SAD4ShaderInstructions</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool SAD4ShaderInstructions;
        /// <summary>
        /// <dd> <p>Specifies whether the hardware and driver support the <strong>fma</strong> intrinsic function and other extended doubles instructions (<strong>DDIV</strong> and <strong>DRCP</strong>) in shaders. The <strong>fma</strong> intrinsic function emits an extended doubles <strong>DFMA</strong> instruction. The runtime sets this member to <strong>TRUE</strong> if  the hardware and driver support extended doubles instructions in shaders (shader model 5 and higher).  Support of this option implies support of basic double-precision shader instructions as well. You can use the <strong>D3D11_FEATURE_DOUBLES</strong> value to query for support of double-precision shaders.  If <strong><see cref = "SharpDX.Result.False"/></strong>, the hardware and driver do not support the option; the runtime will fail shader creation for shaders that use extended doubles instructions.</p> </dd>
        /// </summary>
        /// <doc-id>hh404457</doc-id>
        /// <unmanaged>ExtendedDoublesShaderInstructions</unmanaged>
        /// <unmanaged-short>ExtendedDoublesShaderInstructions</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool ExtendedDoublesShaderInstructions;
        /// <summary>
        /// <dd> <p>Specifies whether the hardware and driver support sharing a greater variety of Texture2D resource types and formats. The runtime sets this member to <strong>TRUE</strong> if  the hardware and driver support extended Texture2D resource sharing.</p> </dd>
        /// </summary>
        /// <doc-id>hh404457</doc-id>
        /// <unmanaged>ExtendedResourceSharing</unmanaged>
        /// <unmanaged-short>ExtendedResourceSharing</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool ExtendedResourceSharing;
    }

    /// <summary>
    /// <strong>Note</strong>?? This structure is supported by the Direct3D 11.2 runtime, which is available on Windows?8.1 and later operating systems.?<p>Describes Direct3D 11.2 feature options in the current graphics driver.</p>
    /// </summary>
    /// <remarks>
    /// <p> If the Direct3D API is the Direct3D 11.2 runtime and can support 11.2 features, <strong>ID3D11Device::CheckFeatureSupport</strong> for <strong>D3D11_FEATURE_D3D11_OPTIONS1</strong> will return a SUCCESS code when valid parameters are passed. The members of <strong><see cref = "SharpDX.Direct3D11.FeatureDataD3D11Options1"/></strong> will be set appropriately based on the system's graphics hardware and graphics driver. </p>
    /// </remarks>
    /// <doc-id>dn280377</doc-id>
    /// <unmanaged>D3D11_FEATURE_DATA_D3D11_OPTIONS1</unmanaged>
    /// <unmanaged-short>D3D11_FEATURE_DATA_D3D11_OPTIONS1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataD3D11Options1
    {
        /// <summary>
        /// <dd> <p> Specifies whether the hardware and driver support tiled resources. The runtime sets this member to a <strong><see cref = "SharpDX.Direct3D11.TiledResourcesTier"/></strong>-typed value that indicates if the hardware and driver support tiled resources and at what tier level. </p> </dd>
        /// </summary>
        /// <doc-id>dn280377</doc-id>
        /// <unmanaged>TiledResourcesTier</unmanaged>
        /// <unmanaged-short>TiledResourcesTier</unmanaged-short>
        public SharpDX.Direct3D11.TiledResourcesTier TiledResourcesTier;
        /// <summary>
        /// <dd> <p> Specifies whether the hardware and driver support the filtering options (<strong><see cref = "SharpDX.Direct3D11.Filter"/></strong>) of comparing the result to the minimum or maximum value during texture sampling. The runtime sets this member to <strong>TRUE</strong> if the hardware and driver support these filtering options. </p> </dd>
        /// </summary>
        /// <doc-id>dn280377</doc-id>
        /// <unmanaged>MinMaxFiltering</unmanaged>
        /// <unmanaged-short>MinMaxFiltering</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool MinMaxFiltering;
        /// <summary>
        /// <dd> <p> Specifies whether the hardware and driver also support the <strong>ID3D11DeviceContext1::ClearView</strong> method on depth formats. For info about valid depth formats, see <strong><see cref = "SharpDX.Direct3D11.DepthStencilViewDescription"/></strong>. </p> </dd>
        /// </summary>
        /// <doc-id>dn280377</doc-id>
        /// <unmanaged>ClearViewAlsoSupportsDepthOnlyFormats</unmanaged>
        /// <unmanaged-short>ClearViewAlsoSupportsDepthOnlyFormats</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool ClearViewAlsoSupportsDepthOnlyFormats;
        /// <summary>
        /// <dd> <p> Specifies support for creating <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong> resources that can be passed to the <strong>ID3D11DeviceContext::Map</strong> and <strong>ID3D11DeviceContext::Unmap</strong> methods. This means that the <strong>CPUAccessFlags</strong> member of the <strong><see cref = "SharpDX.Direct3D11.BufferDescription"/></strong> structure may be set with the desired <strong><see cref = "SharpDX.Direct3D11.CpuAccessFlags"/></strong> elements when the <strong>Usage</strong> member of <strong><see cref = "SharpDX.Direct3D11.BufferDescription"/></strong> is set to <strong>D3D11_USAGE_DEFAULT</strong>. The runtime sets this member to <strong>TRUE</strong> if the hardware is capable of at least <strong>D3D_FEATURE_LEVEL_11_0</strong> and the graphics device driver supports mappable default buffers. </p> </dd>
        /// </summary>
        /// <doc-id>dn280377</doc-id>
        /// <unmanaged>MapOnDefaultBuffers</unmanaged>
        /// <unmanaged-short>MapOnDefaultBuffers</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool MapOnDefaultBuffers;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D11_FEATURE_DATA_D3D11_OPTIONS2</unmanaged>
    /// <unmanaged-short>D3D11_FEATURE_DATA_D3D11_OPTIONS2</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataD3D11Options2
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>PSSpecifiedStencilRefSupported</unmanaged>
        /// <unmanaged-short>PSSpecifiedStencilRefSupported</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool PSSpecifiedStencilRefSupported;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>TypedUAVLoadAdditionalFormats</unmanaged>
        /// <unmanaged-short>TypedUAVLoadAdditionalFormats</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool TypedUAVLoadAdditionalFormats;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>ROVsSupported</unmanaged>
        /// <unmanaged-short>ROVsSupported</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool ROVsSupported;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>ConservativeRasterizationTier</unmanaged>
        /// <unmanaged-short>ConservativeRasterizationTier</unmanaged-short>
        public SharpDX.Direct3D11.ConservativeRasterizationTier ConservativeRasterizationTier;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>TiledResourcesTier</unmanaged>
        /// <unmanaged-short>TiledResourcesTier</unmanaged-short>
        public SharpDX.Direct3D11.TiledResourcesTier TiledResourcesTier;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>MapOnDefaultTextures</unmanaged>
        /// <unmanaged-short>MapOnDefaultTextures</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool MapOnDefaultTextures;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>StandardSwizzle</unmanaged>
        /// <unmanaged-short>StandardSwizzle</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool StandardSwizzle;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>UnifiedMemoryArchitecture</unmanaged>
        /// <unmanaged-short>UnifiedMemoryArchitecture</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool UnifiedMemoryArchitecture;
    }

    /// <summary>
    /// <p>Describes Direct3D 11.3 feature options in the current graphics driver.</p>
    /// </summary>
    /// <doc-id>dn933226</doc-id>
    /// <unmanaged>D3D11_FEATURE_DATA_D3D11_OPTIONS3</unmanaged>
    /// <unmanaged-short>D3D11_FEATURE_DATA_D3D11_OPTIONS3</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataD3D11Options3
    {
        /// <summary>
        /// <dd> <p> Whether to use the VP and RT array index from any shader feeding the rasterizer. </p> </dd>
        /// </summary>
        /// <doc-id>dn933226</doc-id>
        /// <unmanaged>VPAndRTArrayIndexFromAnyShaderFeedingRasterizer</unmanaged>
        /// <unmanaged-short>VPAndRTArrayIndexFromAnyShaderFeedingRasterizer</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool VPAndRTArrayIndexFromAnyShaderFeedingRasterizer;
    }

    /// <summary>
    /// <p>Describes Direct3D 11.4 feature options in the current graphics driver.</p>
    /// </summary>
    /// <remarks>
    /// <p>Use this structure with the D3D11_FEATURE_D3D11_OPTIONS4 member of <strong><see cref = "SharpDX.Direct3D11.Feature"/></strong>. </p><p>Refer to the section on NV12 in Direct3D 11.4 Features.</p>
    /// </remarks>
    /// <doc-id>mt732994</doc-id>
    /// <unmanaged>D3D11_FEATURE_DATA_D3D11_OPTIONS4</unmanaged>
    /// <unmanaged-short>D3D11_FEATURE_DATA_D3D11_OPTIONS4</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataD3D11Options4
    {
        /// <summary>
        /// <dd> <p>Specifies a <see cref = "SharpDX.Mathematics.Interop.RawBool"/> that determines if NV12 textures can be shared across processes and D3D devices.</p> </dd>
        /// </summary>
        /// <doc-id>mt732994</doc-id>
        /// <unmanaged>ExtendedNV12SharedTextureSupported</unmanaged>
        /// <unmanaged-short>ExtendedNV12SharedTextureSupported</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool ExtendedNV12SharedTextureSupported;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D11_FEATURE_DATA_D3D11_OPTIONS5</unmanaged>
    /// <unmanaged-short>D3D11_FEATURE_DATA_D3D11_OPTIONS5</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataD3D11Options5
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SharedResourceTier</unmanaged>
        /// <unmanaged-short>SharedResourceTier</unmanaged-short>
        public SharpDX.Direct3D11.SharedResourceTier SharedResourceTier;
    }

    /// <summary>
    /// <strong>Note</strong>??This structure is supported by the Direct3D 11.1 runtime, which is available on Windows?8 and later operating systems.?<p>Describes Direct3D 9 feature options in the current graphics driver.</p>
    /// </summary>
    /// <doc-id>hh404458</doc-id>
    /// <unmanaged>D3D11_FEATURE_DATA_D3D9_OPTIONS</unmanaged>
    /// <unmanaged-short>D3D11_FEATURE_DATA_D3D9_OPTIONS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    internal partial struct FeatureDataD3D9Options
    {
        /// <summary>
        /// <dd> <p>Specifies whether the driver supports the nonpowers-of-2-unconditionally feature. For more information about this feature, see feature level. The runtime sets this member to <strong>TRUE</strong> for hardware at Direct3D 10 and higher feature levels.  For hardware at Direct3D 9.3 and lower feature levels, the runtime sets this member to <strong><see cref = "SharpDX.Result.False"/></strong> if the hardware and driver support the powers-of-2 (2D textures must have widths and heights specified as powers of two) feature or the nonpowers-of-2-conditionally feature. For more information about this feature, see feature level.</p> </dd>
        /// </summary>
        /// <doc-id>hh404458</doc-id>
        /// <unmanaged>FullNonPow2TextureSupport</unmanaged>
        /// <unmanaged-short>FullNonPow2TextureSupport</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool FullNonPow2TextureSupport;
    }

    /// <summary>
    /// <strong>Note</strong>??This structure is supported by the Direct3D 11.2 runtime, which is available on Windows?8.1 and later operating systems.?<p>Describes Direct3D 9 feature options in the current graphics driver.</p>
    /// </summary>
    /// <remarks>
    /// <p>You can use the <strong>D3D11_FEATURE_D3D9_OPTIONS1</strong> enumeration value with <strong>ID3D11Device::CheckFeatureSupport</strong> to query a driver about support for Direct3D 9 feature options rather than making multiple calls to <strong>ID3D11Device::CheckFeatureSupport</strong> by using <strong>D3D11_FEATURE_D3D9_OPTIONS</strong>, <strong>D3D11_FEATURE_D3D9_SHADOW_SUPPORT</strong>, and <strong>D3D11_FEATURE_D3D9_SIMPLE_INSTANCING_SUPPORT</strong>, which provide identical info about supported Direct3D 9 feature options.</p>
    /// </remarks>
    /// <doc-id>dn629642</doc-id>
    /// <unmanaged>D3D11_FEATURE_DATA_D3D9_OPTIONS1</unmanaged>
    /// <unmanaged-short>D3D11_FEATURE_DATA_D3D9_OPTIONS1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    internal partial struct FeatureDataD3D9Options1
    {
        /// <summary>
        /// <dd> <p>Specifies whether the driver supports the nonpowers-of-2-unconditionally feature. For more info about this feature, see feature level. The runtime sets this member to <strong>TRUE</strong> for hardware at Direct3D 10 and higher feature levels.  For hardware at Direct3D 9.3 and lower feature levels, the runtime sets this member to <strong><see cref = "SharpDX.Result.False"/></strong> if the hardware and driver support the powers-of-2 (2D textures must have widths and heights specified as powers of two) feature or the nonpowers-of-2-conditionally feature. </p> </dd>
        /// </summary>
        /// <doc-id>dn629642</doc-id>
        /// <unmanaged>FullNonPow2TextureSupported</unmanaged>
        /// <unmanaged-short>FullNonPow2TextureSupported</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool FullNonPow2TextureSupported;
        /// <summary>
        /// <dd> <p>Specifies whether the driver supports the shadowing feature with the comparison-filtering mode set to less than or equal to. The runtime sets this member to <strong>TRUE</strong> for hardware at Direct3D 10 and higher feature levels.  For hardware at Direct3D 9.3 and lower feature levels, the runtime sets this member to <strong>TRUE</strong> only if the hardware and driver support the shadowing feature; otherwise <strong><see cref = "SharpDX.Result.False"/></strong>. </p> </dd>
        /// </summary>
        /// <doc-id>dn629642</doc-id>
        /// <unmanaged>DepthAsTextureWithLessEqualComparisonFilterSupported</unmanaged>
        /// <unmanaged-short>DepthAsTextureWithLessEqualComparisonFilterSupported</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool DepthAsTextureWithLessEqualComparisonFilterSupported;
        /// <summary>
        /// <dd> <p>Specifies whether the hardware and driver support simple instancing. The runtime sets this member to <strong>TRUE</strong> if  the hardware and driver support simple instancing.</p> </dd>
        /// </summary>
        /// <doc-id>dn629642</doc-id>
        /// <unmanaged>SimpleInstancingSupported</unmanaged>
        /// <unmanaged-short>SimpleInstancingSupported</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool SimpleInstancingSupported;
        /// <summary>
        /// <dd> <p>Specifies whether the hardware and driver support setting a single face of a <strong>TextureCube</strong> as a render target while the depth stencil surface that is bound alongside can be a <strong>Texture2D</strong> (as opposed to <strong>TextureCube</strong>). The runtime sets this member to <strong>TRUE</strong> if  the hardware and driver support this feature; otherwise <strong><see cref = "SharpDX.Result.False"/></strong>.</p> <p>If the hardware and driver don't support this feature, the app must match the render target surface type with the depth stencil surface type. Because hardware at Direct3D 9.3 and lower feature levels doesn't allow <strong>TextureCube</strong> depth surfaces, the only way to render a scene into a <strong>TextureCube</strong> while having depth buffering enabled is to render each <strong>TextureCube</strong> face separately to a <strong>Texture2D</strong> render target first (because that can be matched with a <strong>Texture2D</strong> depth), and then copy the results into the <strong>TextureCube</strong>.  If  the hardware and driver support this feature, the app can just render to the <strong>TextureCube</strong> faces directly while getting depth buffering out of a <strong>Texture2D</strong> depth buffer.</p> <p>You only need to query this feature from  hardware at Direct3D 9.3 and lower feature levels because hardware at Direct3D 10.0 and higher feature levels allow <strong>TextureCube</strong> depth surfaces.</p> </dd>
        /// </summary>
        /// <doc-id>dn629642</doc-id>
        /// <unmanaged>TextureCubeFaceRenderTargetWithNonCubeDepthStencilSupported</unmanaged>
        /// <unmanaged-short>TextureCubeFaceRenderTargetWithNonCubeDepthStencilSupported</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool TextureCubeFaceRenderTargetWithNonCubeDepthStencilSupported;
    }

    /// <summary>
    /// <strong>Note</strong>??This structure is supported by the Direct3D 11.1 runtime, which is available on Windows?8 and later operating systems.?<p>Describes Direct3D?9 shadow support in the current graphics driver. </p>
    /// </summary>
    /// <remarks>
    /// <p>Shadows are an important element in realistic 3D scenes.  You can use the shadow buffer technique to render shadows.  The basic principle of the technique is to use a depth buffer to store the scene depth info from the perspective of the light source, and then compare each point rendered in the scene with that buffer to determine if it is in shadow.</p><p>To render objects into the scene with shadows on them, you create <strong>sampler state objects</strong> with comparison filtering set and  the comparison mode (ComparisonFunc) to LessEqual.  You can also set BorderColor addressing on this depth sampler, even though BorderColor isn't typically allowed on feature levels 9.1 and 9.2.  By using the border color and picking 0.0 or 1.0 as the border color value, you can control whether the regions off the edge of the shadow map appear to be always in shadow or never in shadow respectively.
    /// You can control the shadow filter quality by the Mag and Min filter settings in the comparison sampler.  Point sampling will produce shadows with non-anti-aliased edges.  Linear filter sampler settings will result in higher quality shadow edges, but might affect performance on some power-optimized devices.</p><strong>Note</strong>??If you use a separate setting for Mag versus Min filter options, you produce an undefined result.  Anisotropic filtering is not supported. The Mip filter choice is not relevant because feature level 9.x does not allow mipmapped depth buffers.?<strong>Note</strong>??On feature level 9.x, you can't compile a shader with the <strong>SampleCmp</strong> and <strong>SampleCmpLevelZero</strong> intrinsic functions by using older versions of the compiler. For example,  you can't use the fxc.exe compiler that ships with the DirectX SDK or use the <strong>D3DCompile**</strong> functions (like <strong>D3DCompileFromFile</strong>) that are implemented in D3DCompiler_43.dll and earlier. These intrinsic functions on feature level 9.x are only supported in the fxc.exe compiler that ships with the Windows?8 SDK and later and with the <strong>D3DCompile**</strong> functions that are implemented in D3DCompiler_44.dll and later.
    /// But these intrinsic functions are present in shader models for feature levels higher than 9.x.?
    /// </remarks>
    /// <doc-id>jj247569</doc-id>
    /// <unmanaged>D3D11_FEATURE_DATA_D3D9_SHADOW_SUPPORT</unmanaged>
    /// <unmanaged-short>D3D11_FEATURE_DATA_D3D9_SHADOW_SUPPORT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    internal partial struct FeatureDataD3D9ShadowSupport
    {
        /// <summary>
        /// <dd> <p>Specifies whether the driver supports the shadowing feature with the comparison-filtering mode set to less than or equal to. The runtime sets this member to <strong>TRUE</strong> for hardware at Direct3D 10 and higher feature levels.  For hardware at Direct3D 9.3 and lower feature levels, the runtime sets this member to <strong>TRUE</strong> only if the hardware and driver support the shadowing feature; otherwise <strong><see cref = "SharpDX.Result.False"/></strong>. </p> </dd>
        /// </summary>
        /// <doc-id>jj247569</doc-id>
        /// <unmanaged>SupportsDepthAsTextureWithLessEqualComparisonFilter</unmanaged>
        /// <unmanaged-short>SupportsDepthAsTextureWithLessEqualComparisonFilter</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool SupportsDepthAsTextureWithLessEqualComparisonFilter;
    }

    /// <summary>
    /// <strong>Note</strong>?? This structure is supported by the Direct3D 11.2 runtime, which is available on Windows?8.1 and later operating systems.?<p>Describes whether simple instancing is supported.</p>
    /// </summary>
    /// <remarks>
    /// <p> If the Direct3D API is the Direct3D 11.2 runtime and can support 11.2 features, <strong>ID3D11Device::CheckFeatureSupport</strong> for <strong>D3D11_FEATURE_D3D9_SIMPLE_INSTANCING_SUPPORT</strong> will return a SUCCESS code when valid parameters are passed. The <strong>SimpleInstancingSupported</strong> member of <strong><see cref = "SharpDX.Direct3D11.FeatureDataD3D9SimpleInstancingSupport"/></strong> will be set to <strong>TRUE</strong> or <strong><see cref = "SharpDX.Result.False"/></strong>. </p><p> Simple instancing means that instancing is supported with the caveat that the <strong>InstanceDataStepRate</strong> member of the <strong><see cref = "SharpDX.Direct3D11.InputElement"/></strong> structure must be equal to 1. This does not change the full instancing support provided by hardware at feature level 9.3 and above, and is meant to expose the instancing support that may be available on feature level 9.2 and 9.1 hardware. </p>
    /// </remarks>
    /// <doc-id>dn280414</doc-id>
    /// <unmanaged>D3D11_FEATURE_DATA_D3D9_SIMPLE_INSTANCING_SUPPORT</unmanaged>
    /// <unmanaged-short>D3D11_FEATURE_DATA_D3D9_SIMPLE_INSTANCING_SUPPORT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    internal partial struct FeatureDataD3D9SimpleInstancingSupport
    {
        /// <summary>
        /// <dd> <p> Specifies whether the hardware and driver support simple instancing. The runtime sets this member to <strong>TRUE</strong> if  the hardware and driver support simple instancing. </p> </dd>
        /// </summary>
        /// <doc-id>dn280414</doc-id>
        /// <unmanaged>SimpleInstancingSupported</unmanaged>
        /// <unmanaged-short>SimpleInstancingSupported</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool SimpleInstancingSupported;
    }

    /// <summary>
    /// <p>Describes double data type support in the current graphics driver.</p>
    /// </summary>
    /// <remarks>
    /// <p>If the runtime sets <strong>DoublePrecisionFloatShaderOps</strong> to  <strong>TRUE</strong>, the hardware and driver support the following Shader Model 5 instructions:</p><ul> <li> dadd </li> <li> dmax </li> <li> dmin </li> <li> dmul </li> <li> deq </li> <li> dge </li> <li> dlt </li> <li> dne </li> <li> dmov </li> <li> dmovc </li> <li> dtof </li> <li> ftod </li> </ul><strong>Note</strong>??If <strong>DoublePrecisionFloatShaderOps</strong> is <strong>TRUE</strong>, the hardware and driver do not necessarily support double-precision division.?
    /// </remarks>
    /// <doc-id>ff476127</doc-id>
    /// <unmanaged>D3D11_FEATURE_DATA_DOUBLES</unmanaged>
    /// <unmanaged-short>D3D11_FEATURE_DATA_DOUBLES</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    internal partial struct FeatureDataDoubles
    {
        /// <summary>
        /// <dd> <p>Specifies whether double types are allowed. If <strong>TRUE</strong>, double types are allowed; otherwise <strong><see cref = "SharpDX.Result.False"/></strong>. The runtime must set <strong>DoublePrecisionFloatShaderOps</strong> to  <strong>TRUE</strong> in order for you to use any HLSL shader that is compiled with a double type.</p> </dd>
        /// </summary>
        /// <doc-id>ff476127</doc-id>
        /// <unmanaged>DoublePrecisionFloatShaderOps</unmanaged>
        /// <unmanaged-short>DoublePrecisionFloatShaderOps</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool DoublePrecisionFloatShaderOps;
    }

    /// <summary>
    /// <p>Describes which resources are supported by the current graphics driver for a given format.</p>
    /// </summary>
    /// <doc-id>ff476128</doc-id>
    /// <unmanaged>D3D11_FEATURE_DATA_FORMAT_SUPPORT</unmanaged>
    /// <unmanaged-short>D3D11_FEATURE_DATA_FORMAT_SUPPORT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    internal partial struct FeatureDataFormatSupport
    {
        /// <summary>
        /// <dd> <p> <strong><see cref = "SharpDX.DXGI.Format"/></strong> to return information on.</p> </dd>
        /// </summary>
        /// <doc-id>ff476128</doc-id>
        /// <unmanaged>InFormat</unmanaged>
        /// <unmanaged-short>InFormat</unmanaged-short>
        public SharpDX.DXGI.Format InFormat;
        /// <summary>
        /// <dd> <p>Combination of <strong><see cref = "SharpDX.Direct3D11.FormatSupport"/></strong> flags indicating which resources are supported.</p> </dd>
        /// </summary>
        /// <doc-id>ff476128</doc-id>
        /// <unmanaged>OutFormatSupport</unmanaged>
        /// <unmanaged-short>OutFormatSupport</unmanaged-short>
        public SharpDX.Direct3D11.FormatSupport OutFormatSupport;
    }

    /// <summary>
    /// <p>Describes which unordered resource options are supported by the current graphics driver for a given format.</p>
    /// </summary>
    /// <doc-id>ff476129</doc-id>
    /// <unmanaged>D3D11_FEATURE_DATA_FORMAT_SUPPORT2</unmanaged>
    /// <unmanaged-short>D3D11_FEATURE_DATA_FORMAT_SUPPORT2</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    internal partial struct FeatureDataFormatSupport2
    {
        /// <summary>
        /// <dd> <p> <strong><see cref = "SharpDX.DXGI.Format"/></strong> to return information on.</p> </dd>
        /// </summary>
        /// <doc-id>ff476129</doc-id>
        /// <unmanaged>InFormat</unmanaged>
        /// <unmanaged-short>InFormat</unmanaged-short>
        public SharpDX.DXGI.Format InFormat;
        /// <summary>
        /// <dd> <p>Combination of <strong><see cref = "SharpDX.Direct3D11.ComputeShaderFormatSupport"/></strong> flags indicating which unordered resource options are supported.</p> </dd>
        /// </summary>
        /// <doc-id>ff476129</doc-id>
        /// <unmanaged>OutFormatSupport2</unmanaged>
        /// <unmanaged-short>OutFormatSupport2</unmanaged-short>
        public SharpDX.Direct3D11.ComputeShaderFormatSupport OutFormatSupport2;
    }

    /// <summary>
    /// <p> Describes feature data GPU virtual address support, including maximum address bits per resource and per process. </p>
    /// </summary>
    /// <remarks>
    /// <p> See <strong><see cref = "SharpDX.Direct3D11.Feature"/></strong>. </p>
    /// </remarks>
    /// <doc-id>mt158212</doc-id>
    /// <unmanaged>D3D11_FEATURE_DATA_GPU_VIRTUAL_ADDRESS_SUPPORT</unmanaged>
    /// <unmanaged-short>D3D11_FEATURE_DATA_GPU_VIRTUAL_ADDRESS_SUPPORT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    internal partial struct FeatureDataGpuVirtualAddressSupport
    {
        /// <summary>
        /// <dd> <p> The maximum GPU virtual address bits per resource. </p> </dd>
        /// </summary>
        /// <doc-id>mt158212</doc-id>
        /// <unmanaged>MaxGPUVirtualAddressBitsPerResource</unmanaged>
        /// <unmanaged-short>MaxGPUVirtualAddressBitsPerResource</unmanaged-short>
        public System.Int32 MaxGPUVirtualAddressBitsPerResource;
        /// <summary>
        /// <dd> <p> The maximum GPU virtual address bits per process. </p> </dd>
        /// </summary>
        /// <doc-id>mt158212</doc-id>
        /// <unmanaged>MaxGPUVirtualAddressBitsPerProcess</unmanaged>
        /// <unmanaged-short>MaxGPUVirtualAddressBitsPerProcess</unmanaged-short>
        public System.Int32 MaxGPUVirtualAddressBitsPerProcess;
    }

    /// <summary>
    /// <strong>Note</strong>??This structure is supported by the Direct3D 11.2 runtime, which is available on Windows?8.1 and later operating systems.?<p>Describes whether a GPU profiling technique is supported.</p>
    /// </summary>
    /// <remarks>
    /// <p>If the Direct3D API is the Direct3D 11.2 runtime and can support 11.2 features, <strong>ID3D11Device::CheckFeatureSupport</strong> for <strong>D3D11_FEATURE_MARKER_SUPPORT</strong> will return a SUCCESS code when valid parameters are passed. The <strong>Profile</strong> member of <strong><see cref = "SharpDX.Direct3D11.FeatureDataMarkerSupport"/></strong> will be set to <strong>TRUE</strong> or <strong><see cref = "SharpDX.Result.False"/></strong>.</p>
    /// </remarks>
    /// <doc-id>dn280415</doc-id>
    /// <unmanaged>D3D11_FEATURE_DATA_MARKER_SUPPORT</unmanaged>
    /// <unmanaged-short>D3D11_FEATURE_DATA_MARKER_SUPPORT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    internal partial struct FeatureDataMarkerSupport
    {
        /// <summary>
        /// <dd> <p>Specifies whether the hardware and driver support a GPU profiling technique that can be used with development tools. The runtime sets this member to <strong>TRUE</strong> if  the hardware and driver support data marking.</p> </dd>
        /// </summary>
        /// <doc-id>dn280415</doc-id>
        /// <unmanaged>Profile</unmanaged>
        /// <unmanaged-short>Profile</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool Profile;
    }

    /// <summary>
    /// <p>Stencil operations that can be performed based on the results of stencil test.</p>
    /// </summary>
    /// <remarks>
    /// <p>All stencil operations are specified as a <strong><see cref = "SharpDX.Direct3D11.StencilOperation"/></strong>. The stencil operation can be set differently based on the outcome of the stencil test (which is referred to as <strong>StencilFunc</strong> in the stencil test portion of depth-stencil testing.</p><p>This structure is a member of a <strong>depth-stencil description</strong>. </p>
    /// </remarks>
    /// <doc-id>ff476109</doc-id>
    /// <unmanaged>D3D11_FEATURE_DATA_SHADER_CACHE</unmanaged>
    /// <unmanaged-short>D3D11_FEATURE_DATA_SHADER_CACHE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    internal partial struct FeatureDataShaderCache
    {
        /// <summary>
        /// <dd> <p>The stencil operation to perform when stencil testing fails.</p> </dd>
        /// </summary>
        /// <doc-id>ff476109</doc-id>
        /// <unmanaged>SupportFlags</unmanaged>
        /// <unmanaged-short>SupportFlags</unmanaged-short>
        public System.Int32 SupportFlags;
    }

    /// <summary>
    /// <strong>Note</strong>??This structure is supported by the Direct3D 11.1 runtime, which is available on Windows?8 and later operating systems.?<p>Describes precision support  options for shaders in the current graphics driver.</p>
    /// </summary>
    /// <remarks>
    /// <p>For hardware at Direct3D 10 and higher feature levels, the runtime sets both members identically.  For hardware at Direct3D 9.3 and lower feature levels, the runtime can set a lower precision support in the <strong>PixelShaderMinPrecision</strong> member than the <strong>AllOtherShaderStagesMinPrecision</strong> member; for 9.3 and lower, all other shader stages represent only the vertex shader.</p><p>For more info about HLSL minimum precision, see using HLSL minimum precision.</p>
    /// </remarks>
    /// <doc-id>hh404460</doc-id>
    /// <unmanaged>D3D11_FEATURE_DATA_SHADER_MIN_PRECISION_SUPPORT</unmanaged>
    /// <unmanaged-short>D3D11_FEATURE_DATA_SHADER_MIN_PRECISION_SUPPORT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct FeatureDataShaderMinimumPrecisionSupport
    {
        /// <summary>
        /// <dd> <p>A combination of <strong><see cref = "SharpDX.Direct3D11.ShaderMinimumPrecisionSupport"/></strong>-typed values that are combined by using a bitwise OR operation. The resulting value specifies minimum precision levels that the driver supports for the pixel shader. A value of zero indicates that the driver supports only full 32-bit precision for the pixel shader.</p> </dd>
        /// </summary>
        /// <doc-id>hh404460</doc-id>
        /// <unmanaged>PixelShaderMinPrecision</unmanaged>
        /// <unmanaged-short>PixelShaderMinPrecision</unmanaged-short>
        public System.Int32 PixelShaderMinPrecision;
        /// <summary>
        /// <dd> <p>A combination of <strong><see cref = "SharpDX.Direct3D11.ShaderMinimumPrecisionSupport"/></strong>-typed values that are combined by using a bitwise OR operation. The resulting value specifies minimum precision levels that the driver supports for all other shader stages. A value of zero indicates that the driver supports only full 32-bit precision for all other shader stages.</p> </dd>
        /// </summary>
        /// <doc-id>hh404460</doc-id>
        /// <unmanaged>AllOtherShaderStagesMinPrecision</unmanaged>
        /// <unmanaged-short>AllOtherShaderStagesMinPrecision</unmanaged-short>
        public System.Int32 AllOtherShaderStagesMinPrecision;
    }

    /// <summary>
    /// <p>Describes the multi-threading features that are supported by the current graphics driver.</p>
    /// </summary>
    /// <remarks>
    /// <p>Use the <see cref = "SharpDX.Direct3D11.FeatureDataThreading"/> structure with the <strong>ID3D11Device::CheckFeatureSupport</strong> method to determine multi-threading support.</p>
    /// </remarks>
    /// <doc-id>ff476130</doc-id>
    /// <unmanaged>D3D11_FEATURE_DATA_THREADING</unmanaged>
    /// <unmanaged-short>D3D11_FEATURE_DATA_THREADING</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    internal partial struct FeatureDataThreading
    {
        /// <summary>
        /// <dd> <p><strong>TRUE</strong> means resources can be created concurrently on multiple threads while drawing; <strong><see cref = "SharpDX.Result.False"/></strong> means that the presence of coarse synchronization will prevent concurrency.</p> </dd>
        /// </summary>
        /// <doc-id>ff476130</doc-id>
        /// <unmanaged>DriverConcurrentCreates</unmanaged>
        /// <unmanaged-short>DriverConcurrentCreates</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool DriverConcurrentCreates;
        /// <summary>
        /// <dd> <p><strong>TRUE</strong> means command lists are supported by the current driver; <strong><see cref = "SharpDX.Result.False"/></strong> means that the API will emulate deferred contexts and command lists with software.</p> </dd>
        /// </summary>
        /// <doc-id>ff476130</doc-id>
        /// <unmanaged>DriverCommandLists</unmanaged>
        /// <unmanaged-short>DriverCommandLists</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool DriverCommandLists;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D11_FEATURE_DATA_VIDEO_DECODER_HISTOGRAM</unmanaged>
    /// <unmanaged-short>D3D11_FEATURE_DATA_VIDEO_DECODER_HISTOGRAM</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    internal partial struct FeatureDataVideoDecoderHistogram
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DecoderDesc</unmanaged>
        /// <unmanaged-short>DecoderDesc</unmanaged-short>
        public SharpDX.Direct3D11.VideoDecoderDescription DecoderDescription;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Components</unmanaged>
        /// <unmanaged-short>Components</unmanaged-short>
        public SharpDX.Direct3D11.VideoDecoderHistogramComponentFlags Components;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>BinCount</unmanaged>
        /// <unmanaged-short>BinCount</unmanaged-short>
        public System.Int32 BinCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>CounterBitDepth</unmanaged>
        /// <unmanaged-short>CounterBitDepth</unmanaged-short>
        public System.Int32 CounterBitDepth;
    }

    /// <summary>
    /// <p>Allow or deny certain types of messages to pass through a filter.</p>
    /// </summary>
    /// <doc-id>ff476178</doc-id>
    /// <unmanaged>D3D11_INFO_QUEUE_FILTER</unmanaged>
    /// <unmanaged-short>D3D11_INFO_QUEUE_FILTER</unmanaged-short>
    public partial class InfoQueueFilter
    {
        /// <summary>
        /// <dd> <p>Number of message categories to allow or deny.</p> </dd>
        /// </summary>
        /// <doc-id>ff476178</doc-id>
        /// <unmanaged>AllowList</unmanaged>
        /// <unmanaged-short>AllowList</unmanaged-short>
        public SharpDX.Direct3D11.InfoQueueFilterDescription AllowList;
        /// <summary>
        /// <dd> <p>Array of message categories to allow or deny. Array must have at least NumCategories members (see <strong><see cref = "SharpDX.Direct3D11.MessageCategory"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476178</doc-id>
        /// <unmanaged>DenyList</unmanaged>
        /// <unmanaged-short>DenyList</unmanaged-short>
        public SharpDX.Direct3D11.InfoQueueFilterDescription DenyList;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Direct3D11.InfoQueueFilterDescription.__Native AllowList;
            public SharpDX.Direct3D11.InfoQueueFilterDescription.__Native DenyList;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            AllowList.__MarshalFree(ref @ref.AllowList);
            DenyList.__MarshalFree(ref @ref.DenyList);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            {
                AllowList = new SharpDX.Direct3D11.InfoQueueFilterDescription();
                AllowList.__MarshalFrom(ref @ref.AllowList);
            }

            {
                DenyList = new SharpDX.Direct3D11.InfoQueueFilterDescription();
                DenyList.__MarshalFrom(ref @ref.DenyList);
            }
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            AllowList.__MarshalTo(ref @ref.AllowList);
            DenyList.__MarshalTo(ref @ref.DenyList);
        }
    }

    /// <summary>
    /// <p>Allow or deny certain types of messages to pass through a filter.</p>
    /// </summary>
    /// <doc-id>ff476178</doc-id>
    /// <unmanaged>D3D11_INFO_QUEUE_FILTER_DESC</unmanaged>
    /// <unmanaged-short>D3D11_INFO_QUEUE_FILTER_DESC</unmanaged-short>
    public partial class InfoQueueFilterDescription
    {
        /// <summary>
        /// <dd> <p>Number of message categories to allow or deny.</p> </dd>
        /// </summary>
        /// <doc-id>ff476178</doc-id>
        /// <unmanaged>NumCategories</unmanaged>
        /// <unmanaged-short>NumCategories</unmanaged-short>
        internal System.Int32 CategorieCount;
        /// <summary>
        /// <dd> <p>Array of message categories to allow or deny. Array must have at least NumCategories members (see <strong><see cref = "SharpDX.Direct3D11.MessageCategory"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476178</doc-id>
        /// <unmanaged>pCategoryList</unmanaged>
        /// <unmanaged-short>pCategoryList</unmanaged-short>
        internal System.IntPtr PCategoryList;
        /// <summary>
        /// <dd> <p>Number of message severity levels to allow or deny.</p> </dd>
        /// </summary>
        /// <doc-id>ff476178</doc-id>
        /// <unmanaged>NumSeverities</unmanaged>
        /// <unmanaged-short>NumSeverities</unmanaged-short>
        internal System.Int32 SeveritieCount;
        /// <summary>
        /// <dd> <p>Array of message severity levels to allow or deny. Array must have at least NumSeverities members (see <strong><see cref = "SharpDX.Direct3D11.MessageSeverity"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476178</doc-id>
        /// <unmanaged>pSeverityList</unmanaged>
        /// <unmanaged-short>pSeverityList</unmanaged-short>
        internal System.IntPtr PSeverityList;
        /// <summary>
        /// <dd> <p>Number of message IDs to allow or deny.</p> </dd>
        /// </summary>
        /// <doc-id>ff476178</doc-id>
        /// <unmanaged>NumIDs</unmanaged>
        /// <unmanaged-short>NumIDs</unmanaged-short>
        internal System.Int32 IDCount;
        /// <summary>
        /// <dd> <p>Array of message IDs to allow or deny. Array must have at least NumIDs members (see <strong><see cref = "SharpDX.Direct3D11.MessageId"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476178</doc-id>
        /// <unmanaged>pIDList</unmanaged>
        /// <unmanaged-short>pIDList</unmanaged-short>
        internal System.IntPtr PIDList;
    }

    /// <summary>
    /// <p>A description of a single element for the input-assembler stage.</p>
    /// </summary>
    /// <remarks>
    /// <p>An input-layout object contains an array of structures, each structure defines one element being read from an input slot. Create an input-layout  object by calling <strong>ID3D11Device::CreateInputLayout</strong>. For an example, see the "Create the Input-Layout Object" subtopic under the  Getting Started with the Input-Assembler Stage topic.</p>
    /// </remarks>
    /// <doc-id>ff476180</doc-id>
    /// <unmanaged>D3D11_INPUT_ELEMENT_DESC</unmanaged>
    /// <unmanaged-short>D3D11_INPUT_ELEMENT_DESC</unmanaged-short>
    public partial struct InputElement
    {
        /// <summary>
        /// <dd> <p>The HLSL semantic associated with this element in a shader input-signature.</p> </dd>
        /// </summary>
        /// <doc-id>ff476180</doc-id>
        /// <unmanaged>SemanticName</unmanaged>
        /// <unmanaged-short>SemanticName</unmanaged-short>
        public System.String SemanticName;
        /// <summary>
        /// <dd> <p>The semantic index for the element. A semantic index modifies a semantic, with an integer index number. A semantic index is only needed in a  case where there is more than one element with the same semantic. For example, a 4x4 matrix would have four components each with the semantic  name </p>  <pre>matrix</pre>  <p>, however each of the four component would have different semantic indices (0, 1, 2, and 3).</p> </dd>
        /// </summary>
        /// <doc-id>ff476180</doc-id>
        /// <unmanaged>SemanticIndex</unmanaged>
        /// <unmanaged-short>SemanticIndex</unmanaged-short>
        public System.Int32 SemanticIndex;
        /// <summary>
        /// <dd> <p>The data type of the element data. See <strong><see cref = "SharpDX.DXGI.Format"/></strong>.</p> </dd>
        /// </summary>
        /// <doc-id>ff476180</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p>An integer value that identifies the input-assembler (see input slot). Valid values are between 0 and 15, defined in D3D11.h.</p> </dd>
        /// </summary>
        /// <doc-id>ff476180</doc-id>
        /// <unmanaged>InputSlot</unmanaged>
        /// <unmanaged-short>InputSlot</unmanaged-short>
        public System.Int32 Slot;
        /// <summary>
        /// <dd> <p>Optional. Offset (in bytes) between each element. Use D3D11_APPEND_ALIGNED_ELEMENT for convenience to define the current element directly  after the previous one, including any packing if necessary.</p> </dd>
        /// </summary>
        /// <doc-id>ff476180</doc-id>
        /// <unmanaged>AlignedByteOffset</unmanaged>
        /// <unmanaged-short>AlignedByteOffset</unmanaged-short>
        public System.Int32 AlignedByteOffset;
        /// <summary>
        /// <dd> <p>Identifies the input data class for a single input slot (see <strong><see cref = "SharpDX.Direct3D11.InputClassification"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476180</doc-id>
        /// <unmanaged>InputSlotClass</unmanaged>
        /// <unmanaged-short>InputSlotClass</unmanaged-short>
        public SharpDX.Direct3D11.InputClassification Classification;
        /// <summary>
        /// <dd> <p>The number of instances to draw using the same per-instance data before advancing in the buffer by one element. This value must be 0 for an  element that contains per-vertex data (the slot class is set to D3D11_INPUT_PER_VERTEX_DATA).</p> </dd>
        /// </summary>
        /// <doc-id>ff476180</doc-id>
        /// <unmanaged>InstanceDataStepRate</unmanaged>
        /// <unmanaged-short>InstanceDataStepRate</unmanaged-short>
        public System.Int32 InstanceDataStepRate;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr SemanticName;
            public System.Int32 SemanticIndex;
            public SharpDX.DXGI.Format Format;
            public System.Int32 Slot;
            public System.Int32 AlignedByteOffset;
            public SharpDX.Direct3D11.InputClassification Classification;
            public System.Int32 InstanceDataStepRate;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.SemanticName);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            SemanticName = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(@ref.SemanticName);
            SemanticIndex = @ref.SemanticIndex;
            Format = @ref.Format;
            Slot = @ref.Slot;
            AlignedByteOffset = @ref.AlignedByteOffset;
            Classification = @ref.Classification;
            InstanceDataStepRate = @ref.InstanceDataStepRate;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.SemanticName = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(SemanticName);
            @ref.SemanticIndex = SemanticIndex;
            @ref.Format = Format;
            @ref.Slot = Slot;
            @ref.AlignedByteOffset = AlignedByteOffset;
            @ref.Classification = Classification;
            @ref.InstanceDataStepRate = InstanceDataStepRate;
        }
    }

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Represents key exchange data for hardware content protection.</p>
    /// </summary>
    /// <remarks>
    /// <p>A reference to this structure is passed in the <em>pData</em> parameter of <strong>ID3D11VideoContext::NegotiateCryptoSessionKeyExchange</strong> method when the <strong><see cref = "SharpDX.Direct3D11.CryptoSession"/></strong> is creating using the <strong>D3D11_KEY_EXCHANGE_HW_PROTECTION</strong> key exchange type.</p>
    /// </remarks>
    /// <doc-id>dn894115</doc-id>
    /// <unmanaged>D3D11_KEY_EXCHANGE_HW_PROTECTION_DATA</unmanaged>
    /// <unmanaged-short>D3D11_KEY_EXCHANGE_HW_PROTECTION_DATA</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct KeyExchangeHwProtectionData
    {
        /// <summary>
        /// <dd> <p>The function ID of the DRM command. The values and meanings of the function ID are defined by the DRM specification.</p> </dd>
        /// </summary>
        /// <doc-id>dn894115</doc-id>
        /// <unmanaged>HWProtectionFunctionID</unmanaged>
        /// <unmanaged-short>HWProtectionFunctionID</unmanaged-short>
        public System.Int32 HWProtectionFunctionID;
        /// <summary>
        /// <dd> <p>Pointer to a buffer containing a <strong><see cref = "SharpDX.Direct3D11.KeyExchangeHwProtectionInputData"/></strong> structure that specifies memory reserved for IHV use and the input data for the DRM command.</p> </dd>
        /// </summary>
        /// <doc-id>dn894115</doc-id>
        /// <unmanaged>pInputData</unmanaged>
        /// <unmanaged-short>pInputData</unmanaged-short>
        public System.IntPtr PInputData;
        /// <summary>
        /// <dd> <p>Pointer to a buffer containing a <strong><see cref = "SharpDX.Direct3D11.KeyExchangeHwProtectionOutputData"/></strong> structure that specifies memory reserved for IHV use and the input data for the DRM command.</p> </dd>
        /// </summary>
        /// <doc-id>dn894115</doc-id>
        /// <unmanaged>pOutputData</unmanaged>
        /// <unmanaged-short>pOutputData</unmanaged-short>
        public System.IntPtr POutputData;
        /// <summary>
        /// <dd> <p>The result of the hardware DRM command.</p> </dd>
        /// </summary>
        /// <doc-id>dn894115</doc-id>
        /// <unmanaged>Status</unmanaged>
        /// <unmanaged-short>Status</unmanaged-short>
        public SharpDX.Result Status;
    }

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Represents key exchange input data for hardware content protection.</p>
    /// </summary>
    /// <doc-id>dn894116</doc-id>
    /// <unmanaged>D3D11_KEY_EXCHANGE_HW_PROTECTION_INPUT_DATA</unmanaged>
    /// <unmanaged-short>D3D11_KEY_EXCHANGE_HW_PROTECTION_INPUT_DATA</unmanaged-short>
    public partial struct KeyExchangeHwProtectionInputData
    {
        /// <summary>
        /// <dd> <p>The size of the private data reserved for IHV usage. This size is determined from the <em>pPrivateInputSize</em> parameter returned by the <strong>ID3D11VideoDevice1::GetCryptoSessionPrivateDataSize</strong> function.</p> </dd>
        /// </summary>
        /// <doc-id>dn894116</doc-id>
        /// <unmanaged>PrivateDataSize</unmanaged>
        /// <unmanaged-short>PrivateDataSize</unmanaged-short>
        public System.Int32 PrivateDataSize;
        /// <summary>
        /// <dd> <p>The size of the DRM command data.</p> </dd>
        /// </summary>
        /// <doc-id>dn894116</doc-id>
        /// <unmanaged>HWProtectionDataSize</unmanaged>
        /// <unmanaged-short>HWProtectionDataSize</unmanaged-short>
        public System.Int32 HWProtectionDataSize;
        /// <summary>
        /// <dd> <p>If <strong>PrivateDataSize</strong> is greater than 0,  pbInput[0] ? <strong>pbInput</strong>[<strong>PrivateDataSize</strong> - 1] is reserved for IHV use.</p> <p><strong>pbInput</strong>[<strong>PrivateDataSize</strong>] ? <strong>pbInput</strong>[<strong>HWProtectionDataSize</strong> + <strong>PrivateDataSize</strong> - 1] contains the input data for the DRM command. The format and size of the DRM command is defined by the DRM specification.</p> </dd>
        /// </summary>
        /// <doc-id>dn894116</doc-id>
        /// <unmanaged>pbInput</unmanaged>
        /// <unmanaged-short>pbInput</unmanaged-short>
        public System.Byte[] PbInput
        {
            get => _PbInput ?? (_PbInput = new System.Byte[4]);
            private set => _PbInput = value;
        }

        internal System.Byte[] _PbInput;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Int32 PrivateDataSize;
            public System.Int32 HWProtectionDataSize;
            public System.Byte PbInput;
            public System.Byte __PbInput1;
            public System.Byte __PbInput2;
            public System.Byte __PbInput3;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            PrivateDataSize = @ref.PrivateDataSize;
            HWProtectionDataSize = @ref.HWProtectionDataSize;
            fixed (void *__to = &PbInput[0], __from = &@ref.PbInput)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 4 * sizeof (System.Byte));
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.PrivateDataSize = PrivateDataSize;
            @ref.HWProtectionDataSize = HWProtectionDataSize;
            fixed (void *__from = &PbInput[0], __to = &@ref.PbInput)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 4 * sizeof (System.Byte));
        }
    }

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Represents key exchange output data for hardware content protection.</p>
    /// </summary>
    /// <doc-id>dn894117</doc-id>
    /// <unmanaged>D3D11_KEY_EXCHANGE_HW_PROTECTION_OUTPUT_DATA</unmanaged>
    /// <unmanaged-short>D3D11_KEY_EXCHANGE_HW_PROTECTION_OUTPUT_DATA</unmanaged-short>
    public partial struct KeyExchangeHwProtectionOutputData
    {
        /// <summary>
        /// <dd> <p>The size of the private data reserved for IHV usage. This size is determined from the <em>pPrivateOutputSize</em> parameter returned by the <strong>ID3D11VideoDevice1::GetCryptoSessionPrivateDataSize</strong> function.</p> </dd>
        /// </summary>
        /// <doc-id>dn894117</doc-id>
        /// <unmanaged>PrivateDataSize</unmanaged>
        /// <unmanaged-short>PrivateDataSize</unmanaged-short>
        public System.Int32 PrivateDataSize;
        /// <summary>
        /// <dd> <p>The maximum size of data that the driver can return in the output buffer. The last byte that it can write to is <strong>pbOuput</strong>[<strong>PrivateDataSize</strong> + <strong>MaxHWProtectionDataSize</strong> ? 1].</p> </dd>
        /// </summary>
        /// <doc-id>dn894117</doc-id>
        /// <unmanaged>MaxHWProtectionDataSize</unmanaged>
        /// <unmanaged-short>MaxHWProtectionDataSize</unmanaged-short>
        public System.Int32 MaxHWProtectionDataSize;
        /// <summary>
        /// <dd> <p>The size of the output data written by the driver.</p> </dd>
        /// </summary>
        /// <doc-id>dn894117</doc-id>
        /// <unmanaged>HWProtectionDataSize</unmanaged>
        /// <unmanaged-short>HWProtectionDataSize</unmanaged-short>
        public System.Int32 HWProtectionDataSize;
        /// <summary>
        /// <dd> <p>The number of 100 nanosecond units spent transporting the data.</p> </dd>
        /// </summary>
        /// <doc-id>dn894117</doc-id>
        /// <unmanaged>TransportTime</unmanaged>
        /// <unmanaged-short>TransportTime</unmanaged-short>
        public System.Int64 TransportTime;
        /// <summary>
        /// <dd> <p>The number of 100 nanosecond units spent executing the content protection command.</p> </dd>
        /// </summary>
        /// <doc-id>dn894117</doc-id>
        /// <unmanaged>ExecutionTime</unmanaged>
        /// <unmanaged-short>ExecutionTime</unmanaged-short>
        public System.Int64 ExecutionTime;
        /// <summary>
        /// <dd> <p>If <strong>PrivateDataSize</strong> is greater than 0,  pbInput[0] ? <strong>pbOutput</strong>[<strong>PrivateDataSize</strong> - 1] is reserved for IHV use.</p> <p><strong>pbOutput</strong>[<strong>PrivateDataSize</strong>] ? <strong>pbOutput</strong>[<strong>HWProtectionDataSize</strong> + <strong>PrivateDataSize</strong> - 1] contains the input data for the DRM command. The format and size of the DRM command is defined by the DRM specification.</p> </dd>
        /// </summary>
        /// <doc-id>dn894117</doc-id>
        /// <unmanaged>pbOutput</unmanaged>
        /// <unmanaged-short>pbOutput</unmanaged-short>
        public System.Byte[] PbOutput
        {
            get => _PbOutput ?? (_PbOutput = new System.Byte[4]);
            private set => _PbOutput = value;
        }

        internal System.Byte[] _PbOutput;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Int32 PrivateDataSize;
            public System.Int32 MaxHWProtectionDataSize;
            public System.Int32 HWProtectionDataSize;
            public System.Int64 TransportTime;
            public System.Int64 ExecutionTime;
            public System.Byte PbOutput;
            public System.Byte __PbOutput1;
            public System.Byte __PbOutput2;
            public System.Byte __PbOutput3;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            PrivateDataSize = @ref.PrivateDataSize;
            MaxHWProtectionDataSize = @ref.MaxHWProtectionDataSize;
            HWProtectionDataSize = @ref.HWProtectionDataSize;
            TransportTime = @ref.TransportTime;
            ExecutionTime = @ref.ExecutionTime;
            fixed (void *__to = &PbOutput[0], __from = &@ref.PbOutput)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 4 * sizeof (System.Byte));
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.PrivateDataSize = PrivateDataSize;
            @ref.MaxHWProtectionDataSize = MaxHWProtectionDataSize;
            @ref.HWProtectionDataSize = HWProtectionDataSize;
            @ref.TransportTime = TransportTime;
            @ref.ExecutionTime = ExecutionTime;
            fixed (void *__from = &PbOutput[0], __to = &@ref.PbOutput)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 4 * sizeof (System.Byte));
        }
    }

    /// <summary>
    /// <p>A debug message in the Information Queue.</p>
    /// </summary>
    /// <remarks>
    /// <p>This structure is returned from <strong>ID3D11InfoQueue::GetMessage</strong> as part of the Information Queue feature (see <strong><see cref = "SharpDX.Direct3D11.InfoQueue"/> Interface</strong>).</p>
    /// </remarks>
    /// <doc-id>ff476184</doc-id>
    /// <unmanaged>D3D11_MESSAGE</unmanaged>
    /// <unmanaged-short>D3D11_MESSAGE</unmanaged-short>
    public partial struct Message
    {
        /// <summary>
        /// <dd> <p>The category of the message. See <strong><see cref = "SharpDX.Direct3D11.MessageCategory"/></strong>.</p> </dd>
        /// </summary>
        /// <doc-id>ff476184</doc-id>
        /// <unmanaged>Category</unmanaged>
        /// <unmanaged-short>Category</unmanaged-short>
        public SharpDX.Direct3D11.MessageCategory Category;
        /// <summary>
        /// <dd> <p>The severity of the message. See <strong><see cref = "SharpDX.Direct3D11.MessageSeverity"/></strong>.</p> </dd>
        /// </summary>
        /// <doc-id>ff476184</doc-id>
        /// <unmanaged>Severity</unmanaged>
        /// <unmanaged-short>Severity</unmanaged-short>
        public SharpDX.Direct3D11.MessageSeverity Severity;
        /// <summary>
        /// <dd> <p>The ID of the message. See <strong><see cref = "SharpDX.Direct3D11.MessageId"/></strong>.</p> </dd>
        /// </summary>
        /// <doc-id>ff476184</doc-id>
        /// <unmanaged>ID</unmanaged>
        /// <unmanaged-short>ID</unmanaged-short>
        public SharpDX.Direct3D11.MessageId Id;
        /// <summary>
        /// <dd> <p>The message string.</p> </dd>
        /// </summary>
        /// <doc-id>ff476184</doc-id>
        /// <unmanaged>pDescription</unmanaged>
        /// <unmanaged-short>pDescription</unmanaged-short>
        public System.String Description;
        /// <summary>
        /// <dd> <p>The length of pDescription in bytes.</p> </dd>
        /// </summary>
        /// <doc-id>ff476184</doc-id>
        /// <unmanaged>DescriptionByteLength</unmanaged>
        /// <unmanaged-short>DescriptionByteLength</unmanaged-short>
        internal SharpDX.PointerSize DescriptionByteLength;
    }

    /// <summary>
    /// <p>Contains a Message Authentication Code (MAC). </p>
    /// </summary>
    /// <doc-id>hh447631</doc-id>
    /// <unmanaged>D3D11_OMAC</unmanaged>
    /// <unmanaged-short>D3D11_OMAC</unmanaged-short>
    public partial struct MessageAuthenticationCode
    {
        /// <summary>
        /// <dd> <p>A byte array that contains the cryptographic MAC value of the message.</p> </dd>
        /// </summary>
        /// <doc-id>hh447631</doc-id>
        /// <unmanaged>Omac</unmanaged>
        /// <unmanaged-short>Omac</unmanaged-short>
        public System.Byte[] Buffer
        {
            get => _Buffer ?? (_Buffer = new System.Byte[16]);
            private set => _Buffer = value;
        }

        internal System.Byte[] _Buffer;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Byte Buffer;
            public System.Byte __Buffer1;
            public System.Byte __Buffer2;
            public System.Byte __Buffer3;
            public System.Byte __Buffer4;
            public System.Byte __Buffer5;
            public System.Byte __Buffer6;
            public System.Byte __Buffer7;
            public System.Byte __Buffer8;
            public System.Byte __Buffer9;
            public System.Byte __Buffer10;
            public System.Byte __Buffer11;
            public System.Byte __Buffer12;
            public System.Byte __Buffer13;
            public System.Byte __Buffer14;
            public System.Byte __Buffer15;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            fixed (void *__to = &Buffer[0], __from = &@ref.Buffer)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 16 * sizeof (System.Byte));
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            fixed (void *__from = &Buffer[0], __to = &@ref.Buffer)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 16 * sizeof (System.Byte));
        }
    }

    /// <summary>
    /// <p>Describes the tile structure of a tiled resource with mipmaps. </p>
    /// </summary>
    /// <doc-id>dn280418</doc-id>
    /// <unmanaged>D3D11_PACKED_MIP_DESC</unmanaged>
    /// <unmanaged-short>D3D11_PACKED_MIP_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct PackedMipDescription
    {
        /// <summary>
        /// <dd> <p>Number of standard mipmaps in the tiled resource. </p> </dd>
        /// </summary>
        /// <doc-id>dn280418</doc-id>
        /// <unmanaged>NumStandardMips</unmanaged>
        /// <unmanaged-short>NumStandardMips</unmanaged-short>
        public System.Byte StandardMipCount;
        /// <summary>
        /// <dd> <p>Number of packed mipmaps in the tiled resource. </p> <p>This number starts from the least detailed mipmap (either sharing tiles or using non standard tile layout). This number is 0 if no
        /// such packing is in the resource.  For array surfaces, this value is the number of mipmaps that are packed for a given array slice where each array slice repeats the same
        /// packing.
        /// </p> <p>On Tier_2 tiled resources hardware, mipmaps that fill at least one standard shaped tile in all dimensions 
        /// are not allowed to be included in the set of packed mipmaps.  On Tier_1 hardware, mipmaps that are an integer multiple of one standard shaped tile in all dimensions are not allowed to be included in the set of packed mipmaps.  Mipmaps with at least one 
        /// dimension less than the standard tile shape may or may not be packed.  When a given mipmap needs to be packed, all coarser 
        /// mipmaps for a given array slice are considered packed as well.
        /// </p> </dd>
        /// </summary>
        /// <doc-id>dn280418</doc-id>
        /// <unmanaged>NumPackedMips</unmanaged>
        /// <unmanaged-short>NumPackedMips</unmanaged-short>
        public System.Byte PackedMipCount;
        /// <summary>
        /// <dd> <p>Number of tiles for the packed mipmaps in the tiled resource. </p> <p>If there is no packing, this value is meaningless and is set to 0.
        /// Otherwise, it is set to the number of tiles
        /// that are needed to represent the set of packed mipmaps.  
        /// The pixel layout within the packed mipmaps is hardware specific. 
        /// If apps define only partial mappings for the set of tiles in packed mipmaps, read and write behavior is vendor specific and undefined.
        /// For arrays, this value is only the count of packed mipmaps within
        /// the subresources for each array slice.</p> </dd>
        /// </summary>
        /// <doc-id>dn280418</doc-id>
        /// <unmanaged>NumTilesForPackedMips</unmanaged>
        /// <unmanaged-short>NumTilesForPackedMips</unmanaged-short>
        public System.Int32 TilesForPackedMipCount;
        /// <summary>
        /// <dd> <p>Offset of the first packed tile for the resource
        /// in the overall range of tiles.  If <strong>NumPackedMips</strong> is 0, this
        /// value is meaningless and is 0.  Otherwise, it is the
        /// offset of the first packed tile for the resource in the overall
        /// range of tiles for the resource.  A value of 0 for 
        /// <strong>StartTileIndexInOverallResource</strong> means the entire resource is packed.  
        /// For array surfaces, this is the offset for the tiles that contain the packed 
        /// mipmaps for the first array slice. Packed mipmaps for each array slice in arrayed surfaces are at this offset
        /// past the beginning of the tiles for each array slice.  </p> <strong>Note</strong>??The 
        /// number of overall tiles, packed or not, for a given array slice is
        /// simply the total number of tiles for the resource divided by the 
        /// resource's array size, so it is easy to locate the range of tiles for 
        /// any given array slice, out of which <strong>StartTileIndexInOverallResource</strong> identifies
        /// which of those are packed. ? </dd>
        /// </summary>
        /// <doc-id>dn280418</doc-id>
        /// <unmanaged>StartTileIndexInOverallResource</unmanaged>
        /// <unmanaged-short>StartTileIndexInOverallResource</unmanaged-short>
        public System.Int32 StartTileIndexInOverallResource;
    }

    /// <summary>
    /// <p>Query information about graphics-pipeline activity in between calls to <strong>ID3D11DeviceContext::Begin</strong> and <strong>ID3D11DeviceContext::End</strong>.</p>
    /// </summary>
    /// <doc-id>ff476192</doc-id>
    /// <unmanaged>D3D11_QUERY_DATA_PIPELINE_STATISTICS</unmanaged>
    /// <unmanaged-short>D3D11_QUERY_DATA_PIPELINE_STATISTICS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct QueryDataPipelineStatistics
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ff476192</doc-id>
        /// <unmanaged>IAVertices</unmanaged>
        /// <unmanaged-short>IAVertices</unmanaged-short>
        public System.Int64 IAVerticeCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ff476192</doc-id>
        /// <unmanaged>IAPrimitives</unmanaged>
        /// <unmanaged-short>IAPrimitives</unmanaged-short>
        public System.Int64 IAPrimitiveCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ff476192</doc-id>
        /// <unmanaged>VSInvocations</unmanaged>
        /// <unmanaged-short>VSInvocations</unmanaged-short>
        public System.Int64 VSInvocationCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ff476192</doc-id>
        /// <unmanaged>GSInvocations</unmanaged>
        /// <unmanaged-short>GSInvocations</unmanaged-short>
        public System.Int64 GSInvocationCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ff476192</doc-id>
        /// <unmanaged>GSPrimitives</unmanaged>
        /// <unmanaged-short>GSPrimitives</unmanaged-short>
        public System.Int64 GSPrimitiveCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ff476192</doc-id>
        /// <unmanaged>CInvocations</unmanaged>
        /// <unmanaged-short>CInvocations</unmanaged-short>
        public System.Int64 CInvocationCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ff476192</doc-id>
        /// <unmanaged>CPrimitives</unmanaged>
        /// <unmanaged-short>CPrimitives</unmanaged-short>
        public System.Int64 CPrimitiveCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ff476192</doc-id>
        /// <unmanaged>PSInvocations</unmanaged>
        /// <unmanaged-short>PSInvocations</unmanaged-short>
        public System.Int64 PSInvocationCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ff476192</doc-id>
        /// <unmanaged>HSInvocations</unmanaged>
        /// <unmanaged-short>HSInvocations</unmanaged-short>
        public System.Int64 HSInvocationCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ff476192</doc-id>
        /// <unmanaged>DSInvocations</unmanaged>
        /// <unmanaged-short>DSInvocations</unmanaged-short>
        public System.Int64 DSInvocationCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ff476192</doc-id>
        /// <unmanaged>CSInvocations</unmanaged>
        /// <unmanaged-short>CSInvocations</unmanaged-short>
        public System.Int64 CSInvocationCount;
    }

    /// <summary>
    /// <p>Query information about the reliability of a timestamp query.</p>
    /// </summary>
    /// <remarks>
    /// <p>For a list of query types see <strong><see cref = "SharpDX.Direct3D11.QueryType"/></strong>.</p>
    /// </remarks>
    /// <doc-id>ff476194</doc-id>
    /// <unmanaged>D3D11_QUERY_DATA_TIMESTAMP_DISJOINT</unmanaged>
    /// <unmanaged-short>D3D11_QUERY_DATA_TIMESTAMP_DISJOINT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct QueryDataTimestampDisjoint
    {
        /// <summary>
        /// <dd> <p>How frequently the GPU counter increments in Hz.</p> </dd>
        /// </summary>
        /// <doc-id>ff476194</doc-id>
        /// <unmanaged>Frequency</unmanaged>
        /// <unmanaged-short>Frequency</unmanaged-short>
        public System.Int64 Frequency;
        /// <summary>
        /// <dd> <p>If this is <strong>TRUE</strong>, something occurred in between the query's <strong>ID3D11DeviceContext::Begin</strong> and <strong>ID3D11DeviceContext::End</strong> calls that caused the timestamp counter to become discontinuous or disjoint, such as unplugging the AC cord on a laptop, overheating, or throttling up/down due to laptop savings events. The timestamp returned by <strong>ID3D11DeviceContext::GetData</strong> for a timestamp query is only reliable if <strong>Disjoint</strong> is <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd>
        /// </summary>
        /// <doc-id>ff476194</doc-id>
        /// <unmanaged>Disjoint</unmanaged>
        /// <unmanaged-short>Disjoint</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool Disjoint;
    }

    /// <summary>
    /// <p>Describes a query.</p>
    /// </summary>
    /// <doc-id>ff476195</doc-id>
    /// <unmanaged>D3D11_QUERY_DESC</unmanaged>
    /// <unmanaged-short>D3D11_QUERY_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct QueryDescription
    {
        /// <summary>
        /// <dd> <p>Type of query (see <strong><see cref = "SharpDX.Direct3D11.QueryType"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476195</doc-id>
        /// <unmanaged>Query</unmanaged>
        /// <unmanaged-short>Query</unmanaged-short>
        public SharpDX.Direct3D11.QueryType Type;
        /// <summary>
        /// <dd> <p>Miscellaneous flags (see <strong><see cref = "SharpDX.Direct3D11.QueryFlags"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476195</doc-id>
        /// <unmanaged>MiscFlags</unmanaged>
        /// <unmanaged-short>MiscFlags</unmanaged-short>
        public SharpDX.Direct3D11.QueryFlags Flags;
    }

    /// <summary>
    /// <p>Describes a query.</p>
    /// </summary>
    /// <doc-id>dn899156</doc-id>
    /// <unmanaged>D3D11_QUERY_DESC1</unmanaged>
    /// <unmanaged-short>D3D11_QUERY_DESC1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct QueryDescription1
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.QueryType"/></strong>-typed value that specifies the type of query.</p> </dd>
        /// </summary>
        /// <doc-id>dn899156</doc-id>
        /// <unmanaged>Query</unmanaged>
        /// <unmanaged-short>Query</unmanaged-short>
        public SharpDX.Direct3D11.QueryType Query;
        /// <summary>
        /// <dd> <p>A combination of <strong><see cref = "SharpDX.Direct3D11.QueryFlags"/></strong>-typed values that are combined by using a bitwise OR operation. The resulting value specifies query behavior. </p> </dd>
        /// </summary>
        /// <doc-id>dn899156</doc-id>
        /// <unmanaged>MiscFlags</unmanaged>
        /// <unmanaged-short>MiscFlags</unmanaged-short>
        public System.Int32 MiscFlags;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.ContextType"/></strong>-typed value that specifies the context for the query.</p> </dd>
        /// </summary>
        /// <doc-id>dn899156</doc-id>
        /// <unmanaged>ContextType</unmanaged>
        /// <unmanaged-short>ContextType</unmanaged-short>
        public SharpDX.Direct3D11.ContextType ContextType;
    }

    /// <summary>
    /// <p>Describes rasterizer state.</p>
    /// </summary>
    /// <remarks>
    /// <p>Rasterizer state defines the behavior of the rasterizer stage. To create a rasterizer-state object, call <strong>ID3D11Device::CreateRasterizerState</strong>. To set rasterizer state, call <strong>ID3D11DeviceContext::RSSetState</strong>.</p><p>If you do not specify some rasterizer state,  the Direct3D runtime uses the following default values for rasterizer state.</p><table> <tr><th>State</th><th>Default Value</th></tr> <tr><td><strong>FillMode</strong></td><td>Solid</td></tr> <tr><td><strong>CullMode</strong></td><td>Back</td></tr> <tr><td><strong>FrontCounterClockwise</strong></td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td><strong>DepthBias</strong></td><td>0</td></tr> <tr><td><strong>SlopeScaledDepthBias</strong></td><td>0.0f</td></tr> <tr><td><strong>DepthBiasClamp</strong></td><td>0.0f</td></tr> <tr><td><strong>DepthClipEnable</strong></td><td><strong>TRUE</strong></td></tr> <tr><td><strong>ScissorEnable</strong></td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td><strong>MultisampleEnable</strong></td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td><strong>AntialiasedLineEnable</strong></td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> </table><p>?</p><strong>Note</strong>??For feature levels 9.1, 9.2, 9.3, and 10.0, if you set <strong>MultisampleEnable</strong> to <strong><see cref = "SharpDX.Result.False"/></strong>, the runtime renders all points, lines, and triangles without anti-aliasing even for render targets with a sample count greater than 1. For feature levels 10.1 and higher, the setting of <strong>MultisampleEnable</strong> has no effect on points and triangles with regard to MSAA and impacts only the selection of the line-rendering algorithm as shown in this table:?<p> </p><table> <tr><th>Line-rendering algorithm</th><th><strong>MultisampleEnable</strong></th><th><strong>AntialiasedLineEnable</strong></th></tr> <tr><td>Aliased</td><td><strong><see cref = "SharpDX.Result.False"/></strong></td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td>Alpha antialiased</td><td><strong><see cref = "SharpDX.Result.False"/></strong></td><td><strong>TRUE</strong></td></tr> <tr><td>Quadrilateral</td><td><strong>TRUE</strong></td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td>Quadrilateral</td><td><strong>TRUE</strong></td><td><strong>TRUE</strong></td></tr> </table><p>?</p><p>The settings of the <strong>MultisampleEnable</strong> and <strong>AntialiasedLineEnable</strong> members apply only to multisample antialiasing (MSAA) render targets (that is, render targets with sample counts greater than 1). Because of the differences in feature-level behavior and as long as you aren?t performing any line drawing or don?t mind that lines render as quadrilaterals, we recommend that you always set <strong>MultisampleEnable</strong> to <strong>TRUE</strong> whenever you render on MSAA render targets.</p>
    /// </remarks>
    /// <doc-id>ff476198</doc-id>
    /// <unmanaged>D3D11_RASTERIZER_DESC</unmanaged>
    /// <unmanaged-short>D3D11_RASTERIZER_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RasterizerStateDescription
    {
        /// <summary>
        /// <dd> <p>Determines the fill mode to use when rendering (see <strong><see cref = "SharpDX.Direct3D11.FillMode"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476198</doc-id>
        /// <unmanaged>FillMode</unmanaged>
        /// <unmanaged-short>FillMode</unmanaged-short>
        public SharpDX.Direct3D11.FillMode FillMode;
        /// <summary>
        /// <dd> <p>Indicates triangles facing the specified direction are not drawn (see <strong><see cref = "SharpDX.Direct3D11.CullMode"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476198</doc-id>
        /// <unmanaged>CullMode</unmanaged>
        /// <unmanaged-short>CullMode</unmanaged-short>
        public SharpDX.Direct3D11.CullMode CullMode;
        /// <summary>
        /// <dd> <p>Determines if a triangle is front- or back-facing. If this parameter is <strong>TRUE</strong>, a triangle will be considered front-facing if its vertices are counter-clockwise on the render target and considered back-facing if they are clockwise. If this parameter is <strong><see cref = "SharpDX.Result.False"/></strong>, the opposite is true.</p> </dd>
        /// </summary>
        /// <doc-id>ff476198</doc-id>
        /// <unmanaged>FrontCounterClockwise</unmanaged>
        /// <unmanaged-short>FrontCounterClockwise</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsFrontCounterClockwise;
        /// <summary>
        /// <dd> <p>Depth value added to a given pixel. For info about depth bias, see Depth Bias.</p> </dd>
        /// </summary>
        /// <doc-id>ff476198</doc-id>
        /// <unmanaged>DepthBias</unmanaged>
        /// <unmanaged-short>DepthBias</unmanaged-short>
        public System.Int32 DepthBias;
        /// <summary>
        /// <dd> <p>Maximum depth bias of a pixel. For info about depth bias, see Depth Bias.</p> </dd>
        /// </summary>
        /// <doc-id>ff476198</doc-id>
        /// <unmanaged>DepthBiasClamp</unmanaged>
        /// <unmanaged-short>DepthBiasClamp</unmanaged-short>
        public System.Single DepthBiasClamp;
        /// <summary>
        /// <dd> <p>Scalar on a given pixel's slope. For info about depth bias, see Depth Bias.</p> </dd>
        /// </summary>
        /// <doc-id>ff476198</doc-id>
        /// <unmanaged>SlopeScaledDepthBias</unmanaged>
        /// <unmanaged-short>SlopeScaledDepthBias</unmanaged-short>
        public System.Single SlopeScaledDepthBias;
        /// <summary>
        /// <dd> <p>Enable clipping based on distance.</p> <p>The hardware always performs x and y clipping of rasterized coordinates. When <strong>DepthClipEnable</strong> is set to the default?<strong>TRUE</strong>, the hardware also clips the z value (that is, the hardware performs the last step of the following algorithm).
        /// </p> <code> 0 &lt; w
        /// -w &lt;= x &lt;= w (or arbitrarily wider range if implementation uses a guard band to reduce clipping burden)
        /// -w &lt;= y &lt;= w (or arbitrarily wider range if implementation uses a guard band to reduce clipping burden)
        /// 0 &lt;= z &lt;= w
        /// </code> <p>When you set <strong>DepthClipEnable</strong> to <strong><see cref = "SharpDX.Result.False"/></strong>, the hardware skips the z clipping (that is, the last step in the preceding algorithm). However, the hardware still performs the "0 &lt; w" clipping. When z clipping is disabled, improper depth ordering at the pixel level might result. However, when z clipping is disabled, stencil shadow implementations are simplified. In other words, you can avoid complex special-case handling for geometry that goes beyond the back clipping plane.
        /// </p> </dd>
        /// </summary>
        /// <doc-id>ff476198</doc-id>
        /// <unmanaged>DepthClipEnable</unmanaged>
        /// <unmanaged-short>DepthClipEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsDepthClipEnabled;
        /// <summary>
        /// <dd> <p>Enable scissor-rectangle culling. All pixels outside an active scissor rectangle are culled.</p> </dd>
        /// </summary>
        /// <doc-id>ff476198</doc-id>
        /// <unmanaged>ScissorEnable</unmanaged>
        /// <unmanaged-short>ScissorEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsScissorEnabled;
        /// <summary>
        /// <dd> <p>Specifies whether to use the quadrilateral or alpha line anti-aliasing algorithm on multisample antialiasing (MSAA) render targets. Set to <strong>TRUE</strong> to use the quadrilateral line anti-aliasing algorithm and to <strong><see cref = "SharpDX.Result.False"/></strong> to use the alpha line anti-aliasing algorithm. For more info about this member, see Remarks.</p> </dd>
        /// </summary>
        /// <doc-id>ff476198</doc-id>
        /// <unmanaged>MultisampleEnable</unmanaged>
        /// <unmanaged-short>MultisampleEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsMultisampleEnabled;
        /// <summary>
        /// <dd> <p>Specifies whether to enable line antialiasing; only applies if doing line drawing and <strong>MultisampleEnable</strong> is <strong><see cref = "SharpDX.Result.False"/></strong>. For more info about this member, see Remarks.</p> </dd>
        /// </summary>
        /// <doc-id>ff476198</doc-id>
        /// <unmanaged>AntialiasedLineEnable</unmanaged>
        /// <unmanaged-short>AntialiasedLineEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsAntialiasedLineEnabled;
    }

    /// <summary>
    /// <strong>Note</strong>??This structure is supported by the Direct3D 11.1 runtime, which is available on Windows?8 and later operating systems.?<p>Describes rasterizer state.</p>
    /// </summary>
    /// <remarks>
    /// <p>Rasterizer state defines the behavior of the rasterizer stage. To create a rasterizer-state object, call <strong>ID3D11Device1::CreateRasterizerState1</strong>. To set rasterizer state, call <strong>ID3D11DeviceContext::RSSetState</strong>.</p><p>If you do not specify some rasterizer state,  the Direct3D runtime uses the following default values for rasterizer state.</p><table> <tr><th>State</th><th>Default Value</th></tr> <tr><td><strong>FillMode</strong></td><td>Solid</td></tr> <tr><td><strong>CullMode</strong></td><td>Back</td></tr> <tr><td><strong>FrontCounterClockwise</strong></td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td><strong>DepthBias</strong></td><td>0</td></tr> <tr><td><strong>SlopeScaledDepthBias</strong></td><td>0.0f</td></tr> <tr><td><strong>DepthBiasClamp</strong></td><td>0.0f</td></tr> <tr><td><strong>DepthClipEnable</strong></td><td><strong>TRUE</strong></td></tr> <tr><td><strong>ScissorEnable</strong></td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td><strong>MultisampleEnable</strong></td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td><strong>AntialiasedLineEnable</strong></td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td><strong>ForcedSampleCount</strong></td><td>0</td></tr> </table><p>?</p><strong>Note</strong>??For feature levels 9.1, 9.2, 9.3, and 10.0, if you set <strong>MultisampleEnable</strong> to <strong><see cref = "SharpDX.Result.False"/></strong>, the runtime renders all points, lines, and triangles without anti-aliasing even for render targets with a sample count greater than 1. For feature levels 10.1 and higher, the setting of <strong>MultisampleEnable</strong> has no effect on points and triangles with regard to MSAA and impacts only the selection of the line-rendering algorithm as shown in this table:?<p> </p><table> <tr><th>Line-rendering algorithm</th><th><strong>MultisampleEnable</strong></th><th><strong>AntialiasedLineEnable</strong></th></tr> <tr><td>Aliased</td><td><strong><see cref = "SharpDX.Result.False"/></strong></td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td>Alpha antialiased</td><td><strong><see cref = "SharpDX.Result.False"/></strong></td><td><strong>TRUE</strong></td></tr> <tr><td>Quadrilateral</td><td><strong>TRUE</strong></td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td>Quadrilateral</td><td><strong>TRUE</strong></td><td><strong>TRUE</strong></td></tr> </table><p>?</p><p>The settings of the <strong>MultisampleEnable</strong> and <strong>AntialiasedLineEnable</strong> members apply only to multisample antialiasing (MSAA) render targets (that is, render targets with sample counts greater than 1). Because of the differences in feature-level behavior and as long as you aren?t performing any line drawing or don?t mind that lines render as quadrilaterals, we recommend that you always set <strong>MultisampleEnable</strong> to <strong>TRUE</strong> whenever you render on MSAA render targets.</p>
    /// </remarks>
    /// <doc-id>hh404489</doc-id>
    /// <unmanaged>D3D11_RASTERIZER_DESC1</unmanaged>
    /// <unmanaged-short>D3D11_RASTERIZER_DESC1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RasterizerStateDescription1
    {
        /// <summary>
        /// <dd> <p>Determines the fill mode to use when rendering.</p> </dd>
        /// </summary>
        /// <doc-id>hh404489</doc-id>
        /// <unmanaged>FillMode</unmanaged>
        /// <unmanaged-short>FillMode</unmanaged-short>
        public SharpDX.Direct3D11.FillMode FillMode;
        /// <summary>
        /// <dd> <p>Indicates that triangles facing the specified direction are not drawn.</p> </dd>
        /// </summary>
        /// <doc-id>hh404489</doc-id>
        /// <unmanaged>CullMode</unmanaged>
        /// <unmanaged-short>CullMode</unmanaged-short>
        public SharpDX.Direct3D11.CullMode CullMode;
        /// <summary>
        /// <dd> <p>Specifies whether a triangle is front- or back-facing. If <strong>TRUE</strong>, a triangle will be considered front-facing if its vertices are counter-clockwise on the render target and considered back-facing if they are clockwise. If <strong><see cref = "SharpDX.Result.False"/></strong>, the opposite is true.</p> </dd>
        /// </summary>
        /// <doc-id>hh404489</doc-id>
        /// <unmanaged>FrontCounterClockwise</unmanaged>
        /// <unmanaged-short>FrontCounterClockwise</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsFrontCounterClockwise;
        /// <summary>
        /// <dd> <p>Depth value added to a given pixel. For info about depth bias, see Depth Bias.</p> </dd>
        /// </summary>
        /// <doc-id>hh404489</doc-id>
        /// <unmanaged>DepthBias</unmanaged>
        /// <unmanaged-short>DepthBias</unmanaged-short>
        public System.Int32 DepthBias;
        /// <summary>
        /// <dd> <p>Maximum depth bias of a pixel. For info about depth bias, see Depth Bias.</p> </dd>
        /// </summary>
        /// <doc-id>hh404489</doc-id>
        /// <unmanaged>DepthBiasClamp</unmanaged>
        /// <unmanaged-short>DepthBiasClamp</unmanaged-short>
        public System.Single DepthBiasClamp;
        /// <summary>
        /// <dd> <p>Scalar on a given pixel's slope. For info about depth bias, see Depth Bias.</p> </dd>
        /// </summary>
        /// <doc-id>hh404489</doc-id>
        /// <unmanaged>SlopeScaledDepthBias</unmanaged>
        /// <unmanaged-short>SlopeScaledDepthBias</unmanaged-short>
        public System.Single SlopeScaledDepthBias;
        /// <summary>
        /// <dd> <p>Specifies whether to enable clipping based on distance.</p> <p>The hardware always performs x and y clipping of rasterized coordinates. When <strong>DepthClipEnable</strong> is set to the default?<strong>TRUE</strong>, the hardware also clips the z value (that is, the hardware performs the last step of the following algorithm).
        /// </p> <code> 0 &lt; w
        /// -w &lt;= x &lt;= w (or arbitrarily wider range if implementation uses a guard band to reduce clipping burden)
        /// -w &lt;= y &lt;= w (or arbitrarily wider range if implementation uses a guard band to reduce clipping burden)
        /// 0 &lt;= z &lt;= w
        /// </code> <p>When you set <strong>DepthClipEnable</strong> to <strong><see cref = "SharpDX.Result.False"/></strong>, the hardware skips the z clipping (that is, the last step in the preceding algorithm). However, the hardware still performs the "0 &lt; w" clipping. When z clipping is disabled, improper depth ordering at the pixel level might result. However, when z clipping is disabled, stencil shadow implementations are simplified. In other words, you can avoid complex special-case handling for geometry that goes beyond the back clipping plane.
        /// </p> </dd>
        /// </summary>
        /// <doc-id>hh404489</doc-id>
        /// <unmanaged>DepthClipEnable</unmanaged>
        /// <unmanaged-short>DepthClipEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsDepthClipEnabled;
        /// <summary>
        /// <dd> <p>Specifies whether to enable scissor-rectangle culling. All pixels outside an active scissor rectangle are culled.</p> </dd>
        /// </summary>
        /// <doc-id>hh404489</doc-id>
        /// <unmanaged>ScissorEnable</unmanaged>
        /// <unmanaged-short>ScissorEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsScissorEnabled;
        /// <summary>
        /// <dd> <p>Specifies whether to use the quadrilateral or alpha line anti-aliasing algorithm on multisample antialiasing (MSAA) render targets. Set to <strong>TRUE</strong> to use the quadrilateral line anti-aliasing algorithm and to <strong><see cref = "SharpDX.Result.False"/></strong> to use the alpha line anti-aliasing algorithm. For more info about this member, see Remarks.</p> </dd>
        /// </summary>
        /// <doc-id>hh404489</doc-id>
        /// <unmanaged>MultisampleEnable</unmanaged>
        /// <unmanaged-short>MultisampleEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsMultisampleEnabled;
        /// <summary>
        /// <dd> <p>Specifies whether to enable line antialiasing; only applies if doing line drawing and <strong>MultisampleEnable</strong> is <strong><see cref = "SharpDX.Result.False"/></strong>. For more info about this member, see Remarks.</p> </dd>
        /// </summary>
        /// <doc-id>hh404489</doc-id>
        /// <unmanaged>AntialiasedLineEnable</unmanaged>
        /// <unmanaged-short>AntialiasedLineEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsAntialiasedLineEnabled;
        /// <summary>
        /// <dd> <p>The sample count that is forced while UAV rendering or rasterizing. Valid values are 0, 1, 2, 4, 8, and optionally 16. 0 indicates that the sample count is not forced.</p> <strong>Note</strong>??<p>If you want to render with <strong>ForcedSampleCount</strong> set to 1 or greater, you must follow these guidelines: </p> <ul> <li>Don't bind depth-stencil views.</li> <li>Disable depth testing.</li> <li>Ensure the shader doesn't output depth.</li> <li>If you have any render-target views bound (<strong>D3D11_BIND_RENDER_TARGET</strong>) and <strong>ForcedSampleCount</strong> is greater than 1, ensure that every render target has only a single sample.</li> <li>Don't operate the shader at sample frequency. Therefore, <strong>ID3D11ShaderReflection::IsSampleFrequencyShader</strong> returns <strong><see cref = "SharpDX.Result.False"/></strong>.</li> </ul>Otherwise, rendering behavior is undefined. For info about how to configure depth-stencil, see Configuring Depth-Stencil Functionality. ? </dd>
        /// </summary>
        /// <doc-id>hh404489</doc-id>
        /// <unmanaged>ForcedSampleCount</unmanaged>
        /// <unmanaged-short>ForcedSampleCount</unmanaged-short>
        public System.Int32 ForcedSampleCount;
    }

    /// <summary>
    /// <p>Describes rasterizer state.</p>
    /// </summary>
    /// <remarks>
    /// <p>Rasterizer state defines the behavior of the rasterizer stage. To create a rasterizer-state object, call <strong>ID3D11Device3::CreateRasterizerState2</strong>. To set rasterizer state, call <strong>ID3D11DeviceContext::RSSetState</strong>.</p><p>If you do not specify some rasterizer state,  the Direct3D runtime uses the following default values for rasterizer state.</p><table> <tr><th>State</th><th>Default Value</th></tr> <tr><td><strong>FillMode</strong></td><td>Solid</td></tr> <tr><td><strong>CullMode</strong></td><td>Back</td></tr> <tr><td><strong>FrontCounterClockwise</strong></td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td><strong>DepthBias</strong></td><td>0</td></tr> <tr><td><strong>SlopeScaledDepthBias</strong></td><td>0.0f</td></tr> <tr><td><strong>DepthBiasClamp</strong></td><td>0.0f</td></tr> <tr><td><strong>DepthClipEnable</strong></td><td><strong>TRUE</strong></td></tr> <tr><td><strong>ScissorEnable</strong></td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td><strong>MultisampleEnable</strong></td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td><strong>AntialiasedLineEnable</strong></td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td><strong>ForcedSampleCount</strong></td><td>0</td></tr> <tr><td><strong>ConservativeRaster</strong></td><td><strong>D3D11_CONSERVATIVE_RASTERIZATION_MODE_OFF</strong></td></tr> </table><p>?</p><strong>Note</strong>??For feature levels 9.1, 9.2, 9.3, and 10.0, if you set <strong>MultisampleEnable</strong> to <strong><see cref = "SharpDX.Result.False"/></strong>, the runtime renders all points, lines, and triangles without anti-aliasing even for render targets with a sample count greater than 1. For feature levels 10.1 and higher, the setting of <strong>MultisampleEnable</strong> has no effect on points and triangles with regard to MSAA and impacts only the selection of the line-rendering algorithm as shown in this table:?<p> </p><table> <tr><th>Line-rendering algorithm</th><th><strong>MultisampleEnable</strong></th><th><strong>AntialiasedLineEnable</strong></th></tr> <tr><td>Aliased</td><td><strong><see cref = "SharpDX.Result.False"/></strong></td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td>Alpha antialiased</td><td><strong><see cref = "SharpDX.Result.False"/></strong></td><td><strong>TRUE</strong></td></tr> <tr><td>Quadrilateral</td><td><strong>TRUE</strong></td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td>Quadrilateral</td><td><strong>TRUE</strong></td><td><strong>TRUE</strong></td></tr> </table><p>?</p><p>The settings of the <strong>MultisampleEnable</strong> and <strong>AntialiasedLineEnable</strong> members apply only to multisample antialiasing (MSAA) render targets (that is, render targets with sample counts greater than 1). Because of the differences in feature-level behavior and as long as you aren?t performing any line drawing or don?t mind that lines render as quadrilaterals, we recommend that you always set <strong>MultisampleEnable</strong> to <strong>TRUE</strong> whenever you render on MSAA render targets.</p>
    /// </remarks>
    /// <doc-id>dn899157</doc-id>
    /// <unmanaged>D3D11_RASTERIZER_DESC2</unmanaged>
    /// <unmanaged-short>D3D11_RASTERIZER_DESC2</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RasterizerStateDescription2
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.FillMode"/></strong>-typed value that determines the fill mode to use when rendering.</p> </dd>
        /// </summary>
        /// <doc-id>dn899157</doc-id>
        /// <unmanaged>FillMode</unmanaged>
        /// <unmanaged-short>FillMode</unmanaged-short>
        public SharpDX.Direct3D11.FillMode FillMode;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.CullMode"/></strong>-typed value that indicates that triangles facing the specified direction are not drawn.</p> </dd>
        /// </summary>
        /// <doc-id>dn899157</doc-id>
        /// <unmanaged>CullMode</unmanaged>
        /// <unmanaged-short>CullMode</unmanaged-short>
        public SharpDX.Direct3D11.CullMode CullMode;
        /// <summary>
        /// <dd> <p>Specifies whether a triangle is front- or back-facing. If <strong>TRUE</strong>, a triangle will be considered front-facing if its vertices are counter-clockwise on the render target and considered back-facing if they are clockwise. If <strong><see cref = "SharpDX.Result.False"/></strong>, the opposite is true.</p> </dd>
        /// </summary>
        /// <doc-id>dn899157</doc-id>
        /// <unmanaged>FrontCounterClockwise</unmanaged>
        /// <unmanaged-short>FrontCounterClockwise</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsFrontCounterClockwise;
        /// <summary>
        /// <dd> <p>Depth value added to a given pixel. For info about depth bias, see Depth Bias.</p> </dd>
        /// </summary>
        /// <doc-id>dn899157</doc-id>
        /// <unmanaged>DepthBias</unmanaged>
        /// <unmanaged-short>DepthBias</unmanaged-short>
        public System.Int32 DepthBias;
        /// <summary>
        /// <dd> <p>Maximum depth bias of a pixel. For info about depth bias, see Depth Bias.</p> </dd>
        /// </summary>
        /// <doc-id>dn899157</doc-id>
        /// <unmanaged>DepthBiasClamp</unmanaged>
        /// <unmanaged-short>DepthBiasClamp</unmanaged-short>
        public System.Single DepthBiasClamp;
        /// <summary>
        /// <dd> <p>Scalar on a given pixel's slope. For info about depth bias, see Depth Bias.</p> </dd>
        /// </summary>
        /// <doc-id>dn899157</doc-id>
        /// <unmanaged>SlopeScaledDepthBias</unmanaged>
        /// <unmanaged-short>SlopeScaledDepthBias</unmanaged-short>
        public System.Single SlopeScaledDepthBias;
        /// <summary>
        /// <dd> <p>Specifies whether to enable clipping based on distance.</p> <p>The hardware always performs x and y clipping of rasterized coordinates. When <strong>DepthClipEnable</strong> is set to the default?<strong>TRUE</strong>, the hardware also clips the z value (that is, the hardware performs the last step of the following algorithm).
        /// </p> <code> 0 &lt; w
        /// -w &lt;= x &lt;= w (or arbitrarily wider range if implementation uses a guard band to reduce clipping burden)
        /// -w &lt;= y &lt;= w (or arbitrarily wider range if implementation uses a guard band to reduce clipping burden)
        /// 0 &lt;= z &lt;= w
        /// </code> <p>When you set <strong>DepthClipEnable</strong> to <strong><see cref = "SharpDX.Result.False"/></strong>, the hardware skips the z clipping (that is, the last step in the preceding algorithm). However, the hardware still performs the "0 &lt; w" clipping. When z clipping is disabled, improper depth ordering at the pixel level might result. However, when z clipping is disabled, stencil shadow implementations are simplified. In other words, you can avoid complex special-case handling for geometry that goes beyond the back clipping plane.
        /// </p> </dd>
        /// </summary>
        /// <doc-id>dn899157</doc-id>
        /// <unmanaged>DepthClipEnable</unmanaged>
        /// <unmanaged-short>DepthClipEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsDepthClipEnabled;
        /// <summary>
        /// <dd> <p>Specifies whether to enable scissor-rectangle culling. All pixels outside an active scissor rectangle are culled.</p> </dd>
        /// </summary>
        /// <doc-id>dn899157</doc-id>
        /// <unmanaged>ScissorEnable</unmanaged>
        /// <unmanaged-short>ScissorEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsScissorEnabled;
        /// <summary>
        /// <dd> <p>Specifies whether to use the quadrilateral or alpha line anti-aliasing algorithm on multisample antialiasing (MSAA) render targets. Set to <strong>TRUE</strong> to use the quadrilateral line anti-aliasing algorithm and to <strong><see cref = "SharpDX.Result.False"/></strong> to use the alpha line anti-aliasing algorithm. For more info about this member, see Remarks.</p> </dd>
        /// </summary>
        /// <doc-id>dn899157</doc-id>
        /// <unmanaged>MultisampleEnable</unmanaged>
        /// <unmanaged-short>MultisampleEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsMultisampleEnabled;
        /// <summary>
        /// <dd> <p>Specifies whether to enable line antialiasing; only applies if doing line drawing and <strong>MultisampleEnable</strong> is <strong><see cref = "SharpDX.Result.False"/></strong>. For more info about this member, see Remarks.</p> </dd>
        /// </summary>
        /// <doc-id>dn899157</doc-id>
        /// <unmanaged>AntialiasedLineEnable</unmanaged>
        /// <unmanaged-short>AntialiasedLineEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsAntialiasedLineEnabled;
        /// <summary>
        /// <dd> <p>The sample count that is forced while UAV rendering or rasterizing. Valid values are 0, 1, 2, 4, 8, and optionally 16. 0 indicates that the sample count is not forced.</p> <strong>Note</strong>??<p>If you want to render with <strong>ForcedSampleCount</strong> set to 1 or greater, you must follow these guidelines: </p> <ul> <li>Don't bind depth-stencil views.</li> <li>Disable depth testing.</li> <li>Ensure the shader doesn't output depth.</li> <li>If you have any render-target views bound (<strong>D3D11_BIND_RENDER_TARGET</strong>) and <strong>ForcedSampleCount</strong> is greater than 1, ensure that every render target has only a single sample.</li> <li>Don't operate the shader at sample frequency. Therefore, <strong>ID3D11ShaderReflection::IsSampleFrequencyShader</strong> returns <strong><see cref = "SharpDX.Result.False"/></strong>.</li> </ul>Otherwise, rendering behavior is undefined. For info about how to configure depth-stencil, see Configuring Depth-Stencil Functionality. ? </dd>
        /// </summary>
        /// <doc-id>dn899157</doc-id>
        /// <unmanaged>ForcedSampleCount</unmanaged>
        /// <unmanaged-short>ForcedSampleCount</unmanaged-short>
        public System.Int32 ForcedSampleCount;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.ConservativeRasterizationMode"/></strong>-typed value that identifies whether conservative rasterization is on or off.</p> </dd>
        /// </summary>
        /// <doc-id>dn899157</doc-id>
        /// <unmanaged>ConservativeRaster</unmanaged>
        /// <unmanaged-short>ConservativeRaster</unmanaged-short>
        public SharpDX.Direct3D11.ConservativeRasterizationMode ConservativeRasterizationMode;
    }

    /// <summary>
    /// <p>Describes the blend state for a render target.</p>
    /// </summary>
    /// <remarks>
    /// <p>You specify an array of <strong><see cref = "SharpDX.Direct3D11.RenderTargetBlendDescription"/></strong> structures in the <strong>RenderTarget</strong> member of the <strong><see cref = "SharpDX.Direct3D11.BlendStateDescription"/></strong> structure to describe the blend states for render targets; you can bind up to eight render targets to the output-merger stage at one time.</p><p>For info about how blending is done, see the output-merger stage.</p><p>Here are the default values for blend state.</p><table> <tr><th>State</th><th>Default Value</th></tr> <tr><td>BlendEnable</td><td><see cref = "SharpDX.Result.False"/></td></tr> <tr><td>SrcBlend</td><td>D3D11_BLEND_ONE</td></tr> <tr><td>DestBlend</td><td>D3D11_BLEND_ZERO</td></tr> <tr><td>BlendOp</td><td>D3D11_BLEND_OP_ADD</td></tr> <tr><td>SrcBlendAlpha</td><td>D3D11_BLEND_ONE</td></tr> <tr><td>DestBlendAlpha</td><td>D3D11_BLEND_ZERO</td></tr> <tr><td>BlendOpAlpha</td><td>D3D11_BLEND_OP_ADD</td></tr> <tr><td>RenderTargetWriteMask</td><td>D3D11_COLOR_WRITE_ENABLE_ALL</td></tr> </table><p>?</p>
    /// </remarks>
    /// <doc-id>ff476200</doc-id>
    /// <unmanaged>D3D11_RENDER_TARGET_BLEND_DESC</unmanaged>
    /// <unmanaged-short>D3D11_RENDER_TARGET_BLEND_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RenderTargetBlendDescription
    {
        /// <summary>
        /// <dd> <p>Enable (or disable) blending.</p> </dd>
        /// </summary>
        /// <doc-id>ff476200</doc-id>
        /// <unmanaged>BlendEnable</unmanaged>
        /// <unmanaged-short>BlendEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsBlendEnabled;
        /// <summary>
        /// <dd> <p>This <strong>blend option</strong> specifies the operation to perform on the RGB value that the pixel shader outputs. The <strong>BlendOp</strong> member defines how to combine the <strong>SrcBlend</strong> and <strong>DestBlend</strong> operations.</p> </dd>
        /// </summary>
        /// <doc-id>ff476200</doc-id>
        /// <unmanaged>SrcBlend</unmanaged>
        /// <unmanaged-short>SrcBlend</unmanaged-short>
        public SharpDX.Direct3D11.BlendOption SourceBlend;
        /// <summary>
        /// <dd> <p>This <strong>blend option</strong> specifies the operation to perform on the current RGB value in the render target. The <strong>BlendOp</strong> member defines how to combine the <strong>SrcBlend</strong> and <strong>DestBlend</strong> operations.</p> </dd>
        /// </summary>
        /// <doc-id>ff476200</doc-id>
        /// <unmanaged>DestBlend</unmanaged>
        /// <unmanaged-short>DestBlend</unmanaged-short>
        public SharpDX.Direct3D11.BlendOption DestinationBlend;
        /// <summary>
        /// <dd> <p>This <strong>blend operation</strong> defines how to combine the <strong>SrcBlend</strong> and <strong>DestBlend</strong> operations.</p> </dd>
        /// </summary>
        /// <doc-id>ff476200</doc-id>
        /// <unmanaged>BlendOp</unmanaged>
        /// <unmanaged-short>BlendOp</unmanaged-short>
        public SharpDX.Direct3D11.BlendOperation BlendOperation;
        /// <summary>
        /// <dd> <p>This <strong>blend option</strong> specifies the operation to perform on the alpha value that the pixel shader outputs. Blend options that end in _COLOR are not allowed. The <strong>BlendOpAlpha</strong> member defines how to combine the <strong>SrcBlendAlpha</strong> and <strong>DestBlendAlpha</strong> operations.</p> </dd>
        /// </summary>
        /// <doc-id>ff476200</doc-id>
        /// <unmanaged>SrcBlendAlpha</unmanaged>
        /// <unmanaged-short>SrcBlendAlpha</unmanaged-short>
        public SharpDX.Direct3D11.BlendOption SourceAlphaBlend;
        /// <summary>
        /// <dd> <p>This <strong>blend option</strong> specifies the operation to perform on the current alpha value in the render target. Blend options that end in _COLOR are not allowed. The <strong>BlendOpAlpha</strong> member defines how to combine the <strong>SrcBlendAlpha</strong> and <strong>DestBlendAlpha</strong> operations.</p> </dd>
        /// </summary>
        /// <doc-id>ff476200</doc-id>
        /// <unmanaged>DestBlendAlpha</unmanaged>
        /// <unmanaged-short>DestBlendAlpha</unmanaged-short>
        public SharpDX.Direct3D11.BlendOption DestinationAlphaBlend;
        /// <summary>
        /// <dd> <p>This <strong>blend operation</strong> defines how to combine the <strong>SrcBlendAlpha</strong> and <strong>DestBlendAlpha</strong> operations.</p> </dd>
        /// </summary>
        /// <doc-id>ff476200</doc-id>
        /// <unmanaged>BlendOpAlpha</unmanaged>
        /// <unmanaged-short>BlendOpAlpha</unmanaged-short>
        public SharpDX.Direct3D11.BlendOperation AlphaBlendOperation;
        /// <summary>
        /// <dd> <p>A write mask.</p> </dd>
        /// </summary>
        /// <doc-id>ff476200</doc-id>
        /// <unmanaged>RenderTargetWriteMask</unmanaged>
        /// <unmanaged-short>RenderTargetWriteMask</unmanaged-short>
        public SharpDX.Direct3D11.ColorWriteMaskFlags RenderTargetWriteMask;
    }

    /// <summary>
    /// <strong>Note</strong>??This structure is supported by the Direct3D 11.1 runtime, which is available on Windows?8 and later operating systems.?<p>Describes the blend state for a render target.</p>
    /// </summary>
    /// <remarks>
    /// <p>You specify an array of <strong><see cref = "SharpDX.Direct3D11.RenderTargetBlendDescription1"/></strong> structures in the <strong>RenderTarget</strong> member of the <strong><see cref = "SharpDX.Direct3D11.BlendStateDescription1"/></strong> structure to describe the blend states for render targets; you can bind up to eight render targets to the output-merger stage at one time.</p><p>For info about how blending is done, see the output-merger stage.</p><p>Here are the default values for blend state.</p><table> <tr><th>State</th><th>Default Value</th></tr> <tr><td>BlendEnable</td><td><see cref = "SharpDX.Result.False"/></td></tr> <tr><td>LogicOpEnable</td><td><see cref = "SharpDX.Result.False"/></td></tr> <tr><td>SrcBlend</td><td>D3D11_BLEND_ONE</td></tr> <tr><td>DestBlend</td><td>D3D11_BLEND_ZERO</td></tr> <tr><td>BlendOp</td><td>D3D11_BLEND_OP_ADD</td></tr> <tr><td>SrcBlendAlpha</td><td>D3D11_BLEND_ONE</td></tr> <tr><td>DestBlendAlpha</td><td>D3D11_BLEND_ZERO</td></tr> <tr><td>BlendOpAlpha</td><td>D3D11_BLEND_OP_ADD</td></tr> <tr><td>LogicOp</td><td>D3D11_LOGIC_OP_NOOP</td></tr> <tr><td>RenderTargetWriteMask</td><td>D3D11_COLOR_WRITE_ENABLE_ALL</td></tr> </table><p>?</p>
    /// </remarks>
    /// <doc-id>hh404492</doc-id>
    /// <unmanaged>D3D11_RENDER_TARGET_BLEND_DESC1</unmanaged>
    /// <unmanaged-short>D3D11_RENDER_TARGET_BLEND_DESC1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RenderTargetBlendDescription1
    {
        /// <summary>
        /// <dd> <p>Enable (or disable) blending.</p> </dd>
        /// </summary>
        /// <doc-id>hh404492</doc-id>
        /// <unmanaged>BlendEnable</unmanaged>
        /// <unmanaged-short>BlendEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsBlendEnabled;
        /// <summary>
        /// <dd> <p>Enable (or disable) a logical operation.</p> </dd>
        /// </summary>
        /// <doc-id>hh404492</doc-id>
        /// <unmanaged>LogicOpEnable</unmanaged>
        /// <unmanaged-short>LogicOpEnable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsLogicOperationEnabled;
        /// <summary>
        /// <dd> <p>This <strong>blend option</strong> specifies the operation to perform on the RGB value that the pixel shader outputs. The <strong>BlendOp</strong> member defines how to combine the <strong>SrcBlend</strong> and <strong>DestBlend</strong> operations.</p> </dd>
        /// </summary>
        /// <doc-id>hh404492</doc-id>
        /// <unmanaged>SrcBlend</unmanaged>
        /// <unmanaged-short>SrcBlend</unmanaged-short>
        public SharpDX.Direct3D11.BlendOption SourceBlend;
        /// <summary>
        /// <dd> <p>This <strong>blend option</strong> specifies the operation to perform on the current RGB value in the render target. The <strong>BlendOp</strong> member defines how to combine the <strong>SrcBlend</strong> and <strong>DestBlend</strong> operations.</p> </dd>
        /// </summary>
        /// <doc-id>hh404492</doc-id>
        /// <unmanaged>DestBlend</unmanaged>
        /// <unmanaged-short>DestBlend</unmanaged-short>
        public SharpDX.Direct3D11.BlendOption DestinationBlend;
        /// <summary>
        /// <dd> <p>This <strong>blend operation</strong> defines how to combine the <strong>SrcBlend</strong> and <strong>DestBlend</strong> operations.</p> </dd>
        /// </summary>
        /// <doc-id>hh404492</doc-id>
        /// <unmanaged>BlendOp</unmanaged>
        /// <unmanaged-short>BlendOp</unmanaged-short>
        public SharpDX.Direct3D11.BlendOperation BlendOperation;
        /// <summary>
        /// <dd> <p>This <strong>blend option</strong> specifies the operation to perform on the alpha value that the pixel shader outputs. Blend options that end in _COLOR are not allowed. The <strong>BlendOpAlpha</strong> member defines how to combine the <strong>SrcBlendAlpha</strong> and <strong>DestBlendAlpha</strong> operations.</p> </dd>
        /// </summary>
        /// <doc-id>hh404492</doc-id>
        /// <unmanaged>SrcBlendAlpha</unmanaged>
        /// <unmanaged-short>SrcBlendAlpha</unmanaged-short>
        public SharpDX.Direct3D11.BlendOption SourceAlphaBlend;
        /// <summary>
        /// <dd> <p>This <strong>blend option</strong> specifies the operation to perform on the current alpha value in the render target. Blend options that end in _COLOR are not allowed. The <strong>BlendOpAlpha</strong> member defines how to combine the <strong>SrcBlendAlpha</strong> and <strong>DestBlendAlpha</strong> operations.</p> </dd>
        /// </summary>
        /// <doc-id>hh404492</doc-id>
        /// <unmanaged>DestBlendAlpha</unmanaged>
        /// <unmanaged-short>DestBlendAlpha</unmanaged-short>
        public SharpDX.Direct3D11.BlendOption DestinationAlphaBlend;
        /// <summary>
        /// <dd> <p>This <strong>blend operation</strong> defines how to combine the <strong>SrcBlendAlpha</strong> and <strong>DestBlendAlpha</strong> operations.</p> </dd>
        /// </summary>
        /// <doc-id>hh404492</doc-id>
        /// <unmanaged>BlendOpAlpha</unmanaged>
        /// <unmanaged-short>BlendOpAlpha</unmanaged-short>
        public SharpDX.Direct3D11.BlendOperation AlphaBlendOperation;
        /// <summary>
        /// <dd> <p>A  <strong><see cref = "SharpDX.Direct3D11.LogicOperation"/></strong>-typed value that specifies the logical operation to configure for the render target.</p> </dd>
        /// </summary>
        /// <doc-id>hh404492</doc-id>
        /// <unmanaged>LogicOp</unmanaged>
        /// <unmanaged-short>LogicOp</unmanaged-short>
        public SharpDX.Direct3D11.LogicOperation LogicOperation;
        /// <summary>
        /// <dd> <p>A write mask.</p> </dd>
        /// </summary>
        /// <doc-id>hh404492</doc-id>
        /// <unmanaged>RenderTargetWriteMask</unmanaged>
        /// <unmanaged-short>RenderTargetWriteMask</unmanaged-short>
        public SharpDX.Direct3D11.ColorWriteMaskFlags RenderTargetWriteMask;
    }

    /// <summary>
    /// <p>Specifies the subresources from a resource that are accessible using a render-target view.</p>
    /// </summary>
    /// <remarks>
    /// <p>A render-target-view description is passed into <strong>ID3D11Device::CreateRenderTargetView</strong> to create a render target.</p><p>A render-target-view cannot use the following formats:</p><ul> <li>Any typeless format.</li> <li>DXGI_FORMAT_R32G32B32 if the view will be used to bind a buffer (vertex, index, constant, or stream-output).</li> </ul><p>If the format is set to DXGI_FORMAT_UNKNOWN, then the format of the resource that the view binds to the pipeline will be used.</p>
    /// </remarks>
    /// <doc-id>ff476201</doc-id>
    /// <unmanaged>D3D11_RENDER_TARGET_VIEW_DESC</unmanaged>
    /// <unmanaged-short>D3D11_RENDER_TARGET_VIEW_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RenderTargetViewDescription
    {
        /// <summary>
        /// <p>Specifies the elements in a buffer resource to use in a render-target view.</p>
        /// </summary>
        /// <remarks>
        /// <p> A render-target view is a member of a render-target-view description (see <strong><see cref = "SharpDX.Direct3D11.RenderTargetViewDescription"/></strong>). Create a render-target view by calling <strong>ID3D11Device::CreateRenderTargetView</strong>. </p>
        /// </remarks>
        /// <doc-id>ff476093</doc-id>
        /// <unmanaged>D3D11_BUFFER_RTV</unmanaged>
        /// <unmanaged-short>D3D11_BUFFER_RTV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct BufferResource
        {
            /// <summary>
            /// <dd> <p> Number of bytes between the beginning of the buffer and the first element to access. </p> </dd>
            /// </summary>
            /// <doc-id>ff476093</doc-id>
            /// <unmanaged>FirstElement</unmanaged>
            /// <unmanaged-short>FirstElement</unmanaged-short>
            [System.Runtime.InteropServices.FieldOffset(0)]
            public System.Int32 FirstElement;
            /// <summary>
            /// <dd> <p> The offset of the first element in the view to access, relative to element 0. </p> </dd>
            /// </summary>
            /// <doc-id>ff476093</doc-id>
            /// <unmanaged>ElementOffset</unmanaged>
            /// <unmanaged-short>ElementOffset</unmanaged-short>
            [System.Runtime.InteropServices.FieldOffset(0)]
            public System.Int32 ElementOffset;
            /// <summary>
            /// <dd> <p> The total number of elements in the view. </p> </dd>
            /// </summary>
            /// <doc-id>ff476093</doc-id>
            /// <unmanaged>NumElements</unmanaged>
            /// <unmanaged-short>NumElements</unmanaged-short>
            [System.Runtime.InteropServices.FieldOffset(4)]
            public System.Int32 ElementCount;
            /// <summary>
            /// <dd> <p> The width of each element (in bytes). This can be determined from the format stored in the render-target-view description. </p> </dd>
            /// </summary>
            /// <doc-id>ff476093</doc-id>
            /// <unmanaged>ElementWidth</unmanaged>
            /// <unmanaged-short>ElementWidth</unmanaged-short>
            [System.Runtime.InteropServices.FieldOffset(4)]
            public System.Int32 ElementWidth;
        }

        /// <summary>
        /// <p>Specifies the subresource from a 1D texture to use in a render-target view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a render-target-view description (see <strong><see cref = "SharpDX.Direct3D11.RenderTargetViewDescription"/></strong>).</p>
        /// </remarks>
        /// <doc-id>ff476230</doc-id>
        /// <unmanaged>D3D11_TEX1D_RTV</unmanaged>
        /// <unmanaged-short>D3D11_TEX1D_RTV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture1DResource
        {
            /// <summary>
            /// <dd> <p>The index of the mipmap level to use mip slice.</p> </dd>
            /// </summary>
            /// <doc-id>ff476230</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
        }

        /// <summary>
        /// <p>Specifies the subresources from an array of 1D textures to use in a render-target view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a render-target-view description (see <strong><see cref = "SharpDX.Direct3D11.RenderTargetViewDescription"/></strong>).</p>
        /// </remarks>
        /// <doc-id>ff476226</doc-id>
        /// <unmanaged>D3D11_TEX1D_ARRAY_RTV</unmanaged>
        /// <unmanaged-short>D3D11_TEX1D_ARRAY_RTV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture1DArrayResource
        {
            /// <summary>
            /// <dd> <p>The index of the mipmap level to use mip slice.</p> </dd>
            /// </summary>
            /// <doc-id>ff476226</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
            /// <summary>
            /// <dd> <p>The index of the first texture to use in an array of textures.</p> </dd>
            /// </summary>
            /// <doc-id>ff476226</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p>Number of textures to use.</p> </dd>
            /// </summary>
            /// <doc-id>ff476226</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
        }

        /// <summary>
        /// <p>Specifies the subresource from a 2D texture to use in a render-target view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a render-target-view description (see <strong><see cref = "SharpDX.Direct3D11.RenderTargetViewDescription"/></strong>).</p>
        /// </remarks>
        /// <doc-id>ff476244</doc-id>
        /// <unmanaged>D3D11_TEX2D_RTV</unmanaged>
        /// <unmanaged-short>D3D11_TEX2D_RTV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DResource
        {
            /// <summary>
            /// <dd> <p>The index of the mipmap level to use mip slice.</p> </dd>
            /// </summary>
            /// <doc-id>ff476244</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
        }

        /// <summary>
        /// <p>Specifies the subresource from a multisampled 2D texture to use in a render-target view.</p>
        /// </summary>
        /// <remarks>
        /// <p>Since a multisampled 2D texture contains a single subresource, there is actually nothing to specify in <see cref = "SharpDX.Direct3D11.Texture2DMultisampledResource"/>. Consequently, <strong>UnusedField_NothingToDefine</strong> is included so that this structure will compile in C.</p>
        /// </remarks>
        /// <doc-id>ff476237</doc-id>
        /// <unmanaged>D3D11_TEX2DMS_RTV</unmanaged>
        /// <unmanaged-short>D3D11_TEX2DMS_RTV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DMultisampledResource
        {
            /// <summary>
            /// <dd> <p>Integer of any value. See remarks.</p> </dd>
            /// </summary>
            /// <doc-id>ff476237</doc-id>
            /// <unmanaged>UnusedField_NothingToDefine</unmanaged>
            /// <unmanaged-short>UnusedField_NothingToDefine</unmanaged-short>
            public System.Int32 UnusedFieldNothingToDefine;
        }

        /// <summary>
        /// <p>Specifies the subresources from an array of 2D textures to use in a render-target view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a render-target-view description (see <strong><see cref = "SharpDX.Direct3D11.RenderTargetViewDescription"/></strong>).</p>
        /// </remarks>
        /// <doc-id>ff476240</doc-id>
        /// <unmanaged>D3D11_TEX2D_ARRAY_RTV</unmanaged>
        /// <unmanaged-short>D3D11_TEX2D_ARRAY_RTV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DArrayResource
        {
            /// <summary>
            /// <dd> <p>The index of the mipmap level to use mip slice.</p> </dd>
            /// </summary>
            /// <doc-id>ff476240</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
            /// <summary>
            /// <dd> <p>The index of the first texture to use in an array of textures.</p> </dd>
            /// </summary>
            /// <doc-id>ff476240</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p>Number of textures in the array to use in the render target view, starting from <strong>FirstArraySlice</strong>.</p> </dd>
            /// </summary>
            /// <doc-id>ff476240</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
        }

        /// <summary>
        /// <p>Specifies the subresources from a an array of multisampled 2D textures to use in a render-target view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a render-target-view description (see <strong><see cref = "SharpDX.Direct3D11.RenderTargetViewDescription"/></strong>).</p>
        /// </remarks>
        /// <doc-id>ff476234</doc-id>
        /// <unmanaged>D3D11_TEX2DMS_ARRAY_RTV</unmanaged>
        /// <unmanaged-short>D3D11_TEX2DMS_ARRAY_RTV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DMultisampledArrayResource
        {
            /// <summary>
            /// <dd> <p>The index of the first texture to use in an array of textures.</p> </dd>
            /// </summary>
            /// <doc-id>ff476234</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p>Number of textures to use.</p> </dd>
            /// </summary>
            /// <doc-id>ff476234</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
        }

        /// <summary>
        /// <p>Specifies the subresources from a 3D texture to use in a render-target view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a render target view. See <strong><see cref = "SharpDX.Direct3D11.RenderTargetViewDescription"/></strong>.</p>
        /// </remarks>
        /// <doc-id>ff476247</doc-id>
        /// <unmanaged>D3D11_TEX3D_RTV</unmanaged>
        /// <unmanaged-short>D3D11_TEX3D_RTV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture3DResource
        {
            /// <summary>
            /// <dd> <p>The index of the mipmap level to use mip slice.</p> </dd>
            /// </summary>
            /// <doc-id>ff476247</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
            /// <summary>
            /// <dd> <p>First depth level to use.</p> </dd>
            /// </summary>
            /// <doc-id>ff476247</doc-id>
            /// <unmanaged>FirstWSlice</unmanaged>
            /// <unmanaged-short>FirstWSlice</unmanaged-short>
            public System.Int32 FirstDepthSlice;
            /// <summary>
            /// <dd> <p>Number of depth levels to use in the render-target view, starting from <strong>FirstWSlice</strong>. A value of -1 indicates all of the slices along the w axis, starting from <strong>FirstWSlice</strong>.</p> </dd>
            /// </summary>
            /// <doc-id>ff476247</doc-id>
            /// <unmanaged>WSize</unmanaged>
            /// <unmanaged-short>WSize</unmanaged-short>
            public System.Int32 DepthSliceCount;
        }

        /// <summary>
        /// <dd> <p>The data format (see <strong><see cref = "SharpDX.DXGI.Format"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476201</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p>The resource type (see <strong><see cref = "SharpDX.Direct3D11.RenderTargetViewDimension"/></strong>), which specifies how the render-target resource will be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>ff476201</doc-id>
        /// <unmanaged>ViewDimension</unmanaged>
        /// <unmanaged-short>ViewDimension</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(4)]
        public SharpDX.Direct3D11.RenderTargetViewDimension Dimension;
        /// <summary>
        /// <dd> <p>Specifies which buffer elements can be accessed (see <strong><see cref = "SharpDX.Direct3D11.BufferResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476201</doc-id>
        /// <unmanaged>Buffer</unmanaged>
        /// <unmanaged-short>Buffer</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.RenderTargetViewDescription.BufferResource Buffer;
        /// <summary>
        /// <dd> <p>Specifies the subresources in a 1D texture that can be accessed (see <strong><see cref = "SharpDX.Direct3D11.Texture1DResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476201</doc-id>
        /// <unmanaged>Texture1D</unmanaged>
        /// <unmanaged-short>Texture1D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.RenderTargetViewDescription.Texture1DResource Texture1D;
        /// <summary>
        /// <dd> <p>Specifies the subresources in a 1D texture array that can be accessed (see <strong><see cref = "SharpDX.Direct3D11.Texture1DArrayResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476201</doc-id>
        /// <unmanaged>Texture1DArray</unmanaged>
        /// <unmanaged-short>Texture1DArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.RenderTargetViewDescription.Texture1DArrayResource Texture1DArray;
        /// <summary>
        /// <dd> <p>Specifies the subresources in a 2D texture that can be accessed (see <strong><see cref = "SharpDX.Direct3D11.Texture2DResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476201</doc-id>
        /// <unmanaged>Texture2D</unmanaged>
        /// <unmanaged-short>Texture2D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.RenderTargetViewDescription.Texture2DResource Texture2D;
        /// <summary>
        /// <dd> <p>Specifies the subresources in a 2D texture array that can be accessed (see <strong><see cref = "SharpDX.Direct3D11.Texture2DArrayResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476201</doc-id>
        /// <unmanaged>Texture2DArray</unmanaged>
        /// <unmanaged-short>Texture2DArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.RenderTargetViewDescription.Texture2DArrayResource Texture2DArray;
        /// <summary>
        /// <dd> <p>Specifies a single subresource because a multisampled 2D texture only contains one subresource (see <strong><see cref = "SharpDX.Direct3D11.Texture2DMultisampledResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476201</doc-id>
        /// <unmanaged>Texture2DMS</unmanaged>
        /// <unmanaged-short>Texture2DMS</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.RenderTargetViewDescription.Texture2DMultisampledResource Texture2DMS;
        /// <summary>
        /// <dd> <p>Specifies the subresources in a multisampled 2D texture array that can be accessed (see <strong><see cref = "SharpDX.Direct3D11.Texture2DMultisampledArrayResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476201</doc-id>
        /// <unmanaged>Texture2DMSArray</unmanaged>
        /// <unmanaged-short>Texture2DMSArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.RenderTargetViewDescription.Texture2DMultisampledArrayResource Texture2DMSArray;
        /// <summary>
        /// <dd> <p>Specifies subresources in a 3D texture that can be accessed (see <strong><see cref = "SharpDX.Direct3D11.Texture3DResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476201</doc-id>
        /// <unmanaged>Texture3D</unmanaged>
        /// <unmanaged-short>Texture3D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.RenderTargetViewDescription.Texture3DResource Texture3D;
    }

    /// <summary>
    /// <p>Describes the subresources from a resource that are accessible using a render-target view.</p>
    /// </summary>
    /// <remarks>
    /// <p>A render-target-view description is passed into <strong>ID3D11Device3::CreateRenderTargetView1</strong> to create a render target.</p><p>A render-target-view can't use the following formats:</p><ul> <li>Any typeless format.</li> <li>DXGI_FORMAT_R32G32B32 if the view will be used to bind a buffer (vertex, index, constant, or stream-output).</li> </ul><p>If the format is set to DXGI_FORMAT_UNKNOWN, then the format of the resource that the view binds to the pipeline will be used.</p>
    /// </remarks>
    /// <doc-id>dn899158</doc-id>
    /// <unmanaged>D3D11_RENDER_TARGET_VIEW_DESC1</unmanaged>
    /// <unmanaged-short>D3D11_RENDER_TARGET_VIEW_DESC1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct RenderTargetViewDescription1
    {
        /// <summary>
        /// <p>Describes the subresource from a 2D texture to use in a render-target view.</p>
        /// </summary>
        /// <doc-id>dn899163</doc-id>
        /// <unmanaged>D3D11_TEX2D_RTV1</unmanaged>
        /// <unmanaged-short>D3D11_TEX2D_RTV1</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DResource
        {
            /// <summary>
            /// <dd> <p>The index of the mipmap level to use mip slice.</p> </dd>
            /// </summary>
            /// <doc-id>dn899163</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
            /// <summary>
            /// <dd> <p>The index (plane slice number) of the plane to use in the texture.</p> </dd>
            /// </summary>
            /// <doc-id>dn899163</doc-id>
            /// <unmanaged>PlaneSlice</unmanaged>
            /// <unmanaged-short>PlaneSlice</unmanaged-short>
            public System.Int32 PlaneSlice;
        }

        /// <summary>
        /// <p>Describes the subresources from an array of 2D textures to use in a render-target view.</p>
        /// </summary>
        /// <doc-id>dn899160</doc-id>
        /// <unmanaged>D3D11_TEX2D_ARRAY_RTV1</unmanaged>
        /// <unmanaged-short>D3D11_TEX2D_ARRAY_RTV1</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DArrayResource
        {
            /// <summary>
            /// <dd> <p>The index of the mipmap level to use mip slice.</p> </dd>
            /// </summary>
            /// <doc-id>dn899160</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
            /// <summary>
            /// <dd> <p>The index of the first texture to use in an array of textures.</p> </dd>
            /// </summary>
            /// <doc-id>dn899160</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p>Number of textures in the array to use in the render-target view, starting from <strong>FirstArraySlice</strong>.</p> </dd>
            /// </summary>
            /// <doc-id>dn899160</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
            /// <summary>
            /// <dd> <p>The index (plane slice number) of the plane to use in an array of textures.</p> </dd>
            /// </summary>
            /// <doc-id>dn899160</doc-id>
            /// <unmanaged>PlaneSlice</unmanaged>
            /// <unmanaged-short>PlaneSlice</unmanaged-short>
            public System.Int32 PlaneSlice;
        }

        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.DXGI.Format"/></strong>-typed value that specifies the data format. </p> </dd>
        /// </summary>
        /// <doc-id>dn899158</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.RenderTargetViewDimension"/></strong>-typed value that specifies the resource type and how the render-target resource will be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn899158</doc-id>
        /// <unmanaged>ViewDimension</unmanaged>
        /// <unmanaged-short>ViewDimension</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(4)]
        public SharpDX.Direct3D11.RenderTargetViewDimension Dimension;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.BufferResource"/></strong> structure that specifies which buffer elements can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn899158</doc-id>
        /// <unmanaged>Buffer</unmanaged>
        /// <unmanaged-short>Buffer</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.RenderTargetViewDescription.BufferResource Buffer;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.Texture1DResource"/></strong> structure that specifies the subresources in a 1D texture that can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn899158</doc-id>
        /// <unmanaged>Texture1D</unmanaged>
        /// <unmanaged-short>Texture1D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.RenderTargetViewDescription.Texture1DResource Texture1D;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.Texture1DArrayResource"/></strong> structure that specifies the subresources in a 1D texture array that can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn899158</doc-id>
        /// <unmanaged>Texture1DArray</unmanaged>
        /// <unmanaged-short>Texture1DArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.RenderTargetViewDescription.Texture1DArrayResource Texture1DArray;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.Texture2DResource"/></strong> structure that specifies the subresources in a 2D texture that can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn899158</doc-id>
        /// <unmanaged>Texture2D</unmanaged>
        /// <unmanaged-short>Texture2D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.RenderTargetViewDescription1.Texture2DResource Texture2D;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.Texture2DArrayResource"/></strong> structure that specifies the subresources in a 2D texture array that can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn899158</doc-id>
        /// <unmanaged>Texture2DArray</unmanaged>
        /// <unmanaged-short>Texture2DArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.RenderTargetViewDescription1.Texture2DArrayResource Texture2DArray;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.Texture2DMultisampledResource"/></strong> structure that specifies a single subresource because a multisampled 2D texture only contains one subresource.</p> </dd>
        /// </summary>
        /// <doc-id>dn899158</doc-id>
        /// <unmanaged>Texture2DMS</unmanaged>
        /// <unmanaged-short>Texture2DMS</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.RenderTargetViewDescription.Texture2DMultisampledResource Texture2DMS;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.Texture2DMultisampledArrayResource"/></strong> structure that specifies the subresources in a multisampled 2D texture array that can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn899158</doc-id>
        /// <unmanaged>Texture2DMSArray</unmanaged>
        /// <unmanaged-short>Texture2DMSArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.RenderTargetViewDescription.Texture2DMultisampledArrayResource Texture2DMSArray;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.Texture3DResource"/></strong> structure that specifies subresources in a 3D texture that can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn899158</doc-id>
        /// <unmanaged>Texture3D</unmanaged>
        /// <unmanaged-short>Texture3D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.RenderTargetViewDescription.Texture3DResource Texture3D;
    }

    /// <summary>
    /// <p>Defines a 3D box.</p>
    /// </summary>
    /// <remarks>
    /// <p>The following diagram shows a 3D box, where the origin is the left, front, top corner.</p><p></p><p>The values for <strong>right</strong>, <strong>bottom</strong>, and <strong>back</strong> are each one pixel past the end of the pixels that are included in the box region.  That is, the values for <strong>left</strong>, <strong>top</strong>, and <strong>front</strong> are included in the box region while the values for right, bottom, and back are excluded from the box region. For example, for a box that is one pixel wide, (right - left) == 1; the box region includes the left pixel but not the right pixel.</p><p>Coordinates of a box are in bytes for buffers and in texels for textures.</p>
    /// </remarks>
    /// <doc-id>ff476089</doc-id>
    /// <unmanaged>D3D11_BOX</unmanaged>
    /// <unmanaged-short>D3D11_BOX</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ResourceRegion
    {
        /// <summary>
        /// <dd> <p>The x position of the left hand side of the box.</p> </dd>
        /// </summary>
        /// <doc-id>ff476089</doc-id>
        /// <unmanaged>left</unmanaged>
        /// <unmanaged-short>left</unmanaged-short>
        public System.Int32 Left;
        /// <summary>
        /// <dd> <p>The y position of the top of the box.</p> </dd>
        /// </summary>
        /// <doc-id>ff476089</doc-id>
        /// <unmanaged>top</unmanaged>
        /// <unmanaged-short>top</unmanaged-short>
        public System.Int32 Top;
        /// <summary>
        /// <dd> <p>The z position of the front of the box.</p> </dd>
        /// </summary>
        /// <doc-id>ff476089</doc-id>
        /// <unmanaged>front</unmanaged>
        /// <unmanaged-short>front</unmanaged-short>
        public System.Int32 Front;
        /// <summary>
        /// <dd> <p>The x position of the right hand side of the box.</p> </dd>
        /// </summary>
        /// <doc-id>ff476089</doc-id>
        /// <unmanaged>right</unmanaged>
        /// <unmanaged-short>right</unmanaged-short>
        public System.Int32 Right;
        /// <summary>
        /// <dd> <p>The y position of the bottom of the box.</p> </dd>
        /// </summary>
        /// <doc-id>ff476089</doc-id>
        /// <unmanaged>bottom</unmanaged>
        /// <unmanaged-short>bottom</unmanaged-short>
        public System.Int32 Bottom;
        /// <summary>
        /// <dd> <p>The z position of the back of the box.</p> </dd>
        /// </summary>
        /// <doc-id>ff476089</doc-id>
        /// <unmanaged>back</unmanaged>
        /// <unmanaged-short>back</unmanaged-short>
        public System.Int32 Back;
    }

    /// <summary>
    /// <p>Describes a sampler state.</p>
    /// </summary>
    /// <remarks>
    /// <p>These are the default values for sampler state.</p><table> <tr><th>State</th><th>Default Value</th></tr> <tr><td>Filter</td><td>D3D11_FILTER_MIN_MAG_MIP_LINEAR</td></tr> <tr><td>AddressU</td><td>D3D11_TEXTURE_ADDRESS_CLAMP</td></tr> <tr><td>AddressV</td><td>D3D11_TEXTURE_ADDRESS_CLAMP</td></tr> <tr><td>AddressW</td><td>D3D11_TEXTURE_ADDRESS_CLAMP</td></tr> <tr><td>MinLOD</td><td>-3.402823466e+38F (-FLT_MAX)</td></tr> <tr><td>MaxLOD</td><td>3.402823466e+38F (FLT_MAX)</td></tr> <tr><td>MipMapLODBias</td><td>0.0f</td></tr> <tr><td>MaxAnisotropy</td><td>1</td></tr> <tr><td>ComparisonFunc</td><td>D3D11_COMPARISON_NEVER</td></tr> <tr><td>BorderColor</td><td>float4(1.0f,1.0f,1.0f,1.0f)</td></tr> <tr><td>Texture</td><td>N/A</td></tr> </table><p>?</p>
    /// </remarks>
    /// <doc-id>ff476207</doc-id>
    /// <unmanaged>D3D11_SAMPLER_DESC</unmanaged>
    /// <unmanaged-short>D3D11_SAMPLER_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct SamplerStateDescription
    {
        /// <summary>
        /// <dd> <p> Filtering method to use when sampling a texture (see <strong><see cref = "SharpDX.Direct3D11.Filter"/></strong>). </p> </dd>
        /// </summary>
        /// <doc-id>ff476207</doc-id>
        /// <unmanaged>Filter</unmanaged>
        /// <unmanaged-short>Filter</unmanaged-short>
        public SharpDX.Direct3D11.Filter Filter;
        /// <summary>
        /// <dd> <p> Method to use for resolving a u texture coordinate that is outside the 0 to 1 range (see <strong><see cref = "SharpDX.Direct3D11.TextureAddressMode"/></strong>). </p> </dd>
        /// </summary>
        /// <doc-id>ff476207</doc-id>
        /// <unmanaged>AddressU</unmanaged>
        /// <unmanaged-short>AddressU</unmanaged-short>
        public SharpDX.Direct3D11.TextureAddressMode AddressU;
        /// <summary>
        /// <dd> <p>Method to use for resolving a v texture coordinate that is outside the 0 to 1 range.</p> </dd>
        /// </summary>
        /// <doc-id>ff476207</doc-id>
        /// <unmanaged>AddressV</unmanaged>
        /// <unmanaged-short>AddressV</unmanaged-short>
        public SharpDX.Direct3D11.TextureAddressMode AddressV;
        /// <summary>
        /// <dd> <p>Method to use for resolving a w texture coordinate that is outside the 0 to 1 range.</p> </dd>
        /// </summary>
        /// <doc-id>ff476207</doc-id>
        /// <unmanaged>AddressW</unmanaged>
        /// <unmanaged-short>AddressW</unmanaged-short>
        public SharpDX.Direct3D11.TextureAddressMode AddressW;
        /// <summary>
        /// <dd> <p>Offset from the calculated mipmap level. For example, if Direct3D calculates that a texture should be sampled at mipmap level 3 and MipLODBias is 2, then the texture will be sampled at mipmap level 5.</p> </dd>
        /// </summary>
        /// <doc-id>ff476207</doc-id>
        /// <unmanaged>MipLODBias</unmanaged>
        /// <unmanaged-short>MipLODBias</unmanaged-short>
        public System.Single MipLodBias;
        /// <summary>
        /// <dd> <p>Clamping value used if D3D11_FILTER_ANISOTROPIC or D3D11_FILTER_COMPARISON_ANISOTROPIC is specified in Filter. Valid values are between 1 and 16.</p> </dd>
        /// </summary>
        /// <doc-id>ff476207</doc-id>
        /// <unmanaged>MaxAnisotropy</unmanaged>
        /// <unmanaged-short>MaxAnisotropy</unmanaged-short>
        public System.Int32 MaximumAnisotropy;
        /// <summary>
        /// <dd> <p> A function that compares sampled data against existing sampled data. The function options are listed in <strong><see cref = "SharpDX.Direct3D11.Comparison"/></strong>. </p> </dd>
        /// </summary>
        /// <doc-id>ff476207</doc-id>
        /// <unmanaged>ComparisonFunc</unmanaged>
        /// <unmanaged-short>ComparisonFunc</unmanaged-short>
        public SharpDX.Direct3D11.Comparison ComparisonFunction;
        /// <summary>
        /// <dd> <p>Border color to use if D3D11_TEXTURE_ADDRESS_BORDER is specified for AddressU, AddressV, or AddressW. Range must be between 0.0 and 1.0 inclusive.</p> </dd>
        /// </summary>
        /// <doc-id>ff476207</doc-id>
        /// <unmanaged>BorderColor</unmanaged>
        /// <unmanaged-short>BorderColor</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawColor4 BorderColor;
        /// <summary>
        /// <dd> <p>Lower end of the mipmap range to clamp access to, where 0 is the largest and most detailed mipmap level and any level higher than that is less detailed.</p> </dd>
        /// </summary>
        /// <doc-id>ff476207</doc-id>
        /// <unmanaged>MinLOD</unmanaged>
        /// <unmanaged-short>MinLOD</unmanaged-short>
        public System.Single MinimumLod;
        /// <summary>
        /// <dd> <p>Upper end of the mipmap range to clamp access to, where 0 is the largest and most detailed mipmap level and any level higher than that is less detailed. This value must be greater than or equal to MinLOD. To have no upper limit on LOD set this to a large value such as D3D11_FLOAT32_MAX.</p> </dd>
        /// </summary>
        /// <doc-id>ff476207</doc-id>
        /// <unmanaged>MaxLOD</unmanaged>
        /// <unmanaged-short>MaxLOD</unmanaged-short>
        public System.Single MaximumLod;
    }

    /// <summary>
    /// <p>Describes a shader-resource view.</p>
    /// </summary>
    /// <remarks>
    /// <p>A view is a format-specific way to look at the data in a resource. The view determines what data to look at, and how it is cast when read.</p><p>When viewing a resource, the resource-view description must specify a typed format, that is compatible with the resource format. So that means that you cannot create a resource-view description using any format with _TYPELESS in the name. You can however view a typeless resource by specifying a typed format for the view. For example, a DXGI_FORMAT_R32G32B32_TYPELESS resource can be viewed with one of these typed formats: DXGI_FORMAT_R32G32B32_FLOAT, DXGI_FORMAT_R32G32B32_UINT, and DXGI_FORMAT_R32G32B32_SINT, since these typed formats are compatible with the typeless resource.</p><p>Create a shader-resource-view description by calling <strong>ID3D11Device::CreateShaderResourceView</strong>. To view a shader-resource-view description, call <strong>ID3D11ShaderResourceView::GetDesc</strong>.</p>
    /// </remarks>
    /// <doc-id>ff476211</doc-id>
    /// <unmanaged>D3D11_SHADER_RESOURCE_VIEW_DESC</unmanaged>
    /// <unmanaged-short>D3D11_SHADER_RESOURCE_VIEW_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ShaderResourceViewDescription
    {
        /// <summary>
        /// <p>Specifies the elements in a buffer resource to use in a shader-resource view.</p>
        /// </summary>
        /// <remarks>
        /// <p> The <strong><see cref = "SharpDX.Direct3D11.BufferResource"/></strong> structure is a member of the  <strong><see cref = "SharpDX.Direct3D11.ShaderResourceViewDescription"/></strong> structure, which represents a shader-resource view description. You can create a shader-resource view by calling the <strong>ID3D11Device::CreateShaderResourceView</strong> method. </p>
        /// </remarks>
        /// <doc-id>ff476094</doc-id>
        /// <unmanaged>D3D11_BUFFER_SRV</unmanaged>
        /// <unmanaged-short>D3D11_BUFFER_SRV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct BufferResource
        {
            /// <summary>
            /// <dd> <p> Number of bytes between the beginning of the buffer and the first element to access. </p> </dd>
            /// </summary>
            /// <doc-id>ff476094</doc-id>
            /// <unmanaged>FirstElement</unmanaged>
            /// <unmanaged-short>FirstElement</unmanaged-short>
            [System.Runtime.InteropServices.FieldOffset(0)]
            public System.Int32 FirstElement;
            /// <summary>
            /// <dd> <p> The offset of the first element in the view to access, relative to element 0. </p> </dd>
            /// </summary>
            /// <doc-id>ff476094</doc-id>
            /// <unmanaged>ElementOffset</unmanaged>
            /// <unmanaged-short>ElementOffset</unmanaged-short>
            [System.Runtime.InteropServices.FieldOffset(0)]
            public System.Int32 ElementOffset;
            /// <summary>
            /// <dd> <p> The total number of elements in the view. </p> </dd>
            /// </summary>
            /// <doc-id>ff476094</doc-id>
            /// <unmanaged>NumElements</unmanaged>
            /// <unmanaged-short>NumElements</unmanaged-short>
            [System.Runtime.InteropServices.FieldOffset(4)]
            public System.Int32 ElementCount;
            /// <summary>
            /// <dd> <p> The width of each element (in bytes). This can be determined from the format stored in the shader-resource-view description. </p> </dd>
            /// </summary>
            /// <doc-id>ff476094</doc-id>
            /// <unmanaged>ElementWidth</unmanaged>
            /// <unmanaged-short>ElementWidth</unmanaged-short>
            [System.Runtime.InteropServices.FieldOffset(4)]
            public System.Int32 ElementWidth;
        }

        /// <summary>
        /// <p>Describes the elements in a raw buffer resource to use in a shader-resource view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is used by <strong><see cref = "SharpDX.Direct3D11.ShaderResourceViewDescription"/></strong> to create a raw view of a buffer.</p>
        /// </remarks>
        /// <doc-id>ff476090</doc-id>
        /// <unmanaged>D3D11_BUFFEREX_SRV</unmanaged>
        /// <unmanaged-short>D3D11_BUFFEREX_SRV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct ExtendedBufferResource
        {
            /// <summary>
            /// <dd> <p>The index of the first element to be accessed by the view.</p> </dd>
            /// </summary>
            /// <doc-id>ff476090</doc-id>
            /// <unmanaged>FirstElement</unmanaged>
            /// <unmanaged-short>FirstElement</unmanaged-short>
            public System.Int32 FirstElement;
            /// <summary>
            /// <dd> <p>The number of elements in the resource.</p> </dd>
            /// </summary>
            /// <doc-id>ff476090</doc-id>
            /// <unmanaged>NumElements</unmanaged>
            /// <unmanaged-short>NumElements</unmanaged-short>
            public System.Int32 ElementCount;
            /// <summary>
            /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.ShaderResourceViewExtendedBufferFlags"/></strong>-typed value that identifies view options for the buffer. Currently, the only option is to identify a raw view of the buffer. For more info about raw viewing of buffers, see Raw Views of Buffers.</p> </dd>
            /// </summary>
            /// <doc-id>ff476090</doc-id>
            /// <unmanaged>Flags</unmanaged>
            /// <unmanaged-short>Flags</unmanaged-short>
            public SharpDX.Direct3D11.ShaderResourceViewExtendedBufferFlags Flags;
        }

        /// <summary>
        /// <p>Specifies the subresource from a 1D texture to use in a shader-resource view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a shader-resource-view description (see <strong><see cref = "SharpDX.Direct3D11.ShaderResourceViewDescription"/></strong>).</p><p>As an example, assuming <strong>MostDetailedMip</strong> = 6 and <strong>MipLevels</strong> = 2, the view will have access to 2 mipmap levels, 6 and 7, of the original texture for which <strong>ID3D11Device::CreateShaderResourceView</strong> creates the view. In this situation, <strong>MostDetailedMip</strong> is greater than the <strong>MipLevels</strong> in the view. However, <strong>MostDetailedMip</strong> is not greater than the <strong>MipLevels</strong> in the original resource.</p>
        /// </remarks>
        /// <doc-id>ff476231</doc-id>
        /// <unmanaged>D3D11_TEX1D_SRV</unmanaged>
        /// <unmanaged-short>D3D11_TEX1D_SRV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture1DResource
        {
            /// <summary>
            /// <dd> <p>Index of the most detailed mipmap level to use; this number is between 0 and <strong>MipLevels</strong> (from the original Texture1D for which <strong>ID3D11Device::CreateShaderResourceView</strong> creates a view) -1.</p> </dd>
            /// </summary>
            /// <doc-id>ff476231</doc-id>
            /// <unmanaged>MostDetailedMip</unmanaged>
            /// <unmanaged-short>MostDetailedMip</unmanaged-short>
            public System.Int32 MostDetailedMip;
            /// <summary>
            /// <dd> <p>The maximum number of mipmap levels for the view  of the texture. See the remarks.</p> <p>Set to -1 to indicate all the mipmap levels from <strong>MostDetailedMip</strong> on down to least detailed.</p> </dd>
            /// </summary>
            /// <doc-id>ff476231</doc-id>
            /// <unmanaged>MipLevels</unmanaged>
            /// <unmanaged-short>MipLevels</unmanaged-short>
            public System.Int32 MipLevels;
        }

        /// <summary>
        /// <p>Specifies the subresources from an array of 1D textures to use in a shader-resource view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a shader-resource-view description (see <strong><see cref = "SharpDX.Direct3D11.ShaderResourceViewDescription"/></strong>).</p>
        /// </remarks>
        /// <doc-id>ff476227</doc-id>
        /// <unmanaged>D3D11_TEX1D_ARRAY_SRV</unmanaged>
        /// <unmanaged-short>D3D11_TEX1D_ARRAY_SRV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture1DArrayResource
        {
            /// <summary>
            /// <dd> <p>Index of the most detailed mipmap level to use; this number is between 0 and <strong>MipLevels</strong> (from the original Texture1D for which <strong>ID3D11Device::CreateShaderResourceView</strong> creates a view) -1.</p> </dd>
            /// </summary>
            /// <doc-id>ff476227</doc-id>
            /// <unmanaged>MostDetailedMip</unmanaged>
            /// <unmanaged-short>MostDetailedMip</unmanaged-short>
            public System.Int32 MostDetailedMip;
            /// <summary>
            /// <dd> <p>The maximum number of mipmap levels for the view of the texture. See the remarks in <strong><see cref = "SharpDX.Direct3D11.Texture1DResource"/></strong>.</p> <p>Set to -1 to indicate all the mipmap levels from <strong>MostDetailedMip</strong> on down to least detailed.</p> </dd>
            /// </summary>
            /// <doc-id>ff476227</doc-id>
            /// <unmanaged>MipLevels</unmanaged>
            /// <unmanaged-short>MipLevels</unmanaged-short>
            public System.Int32 MipLevels;
            /// <summary>
            /// <dd> <p>The index of the first texture to use in an array of textures.</p> </dd>
            /// </summary>
            /// <doc-id>ff476227</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p>Number of textures in the array.</p> </dd>
            /// </summary>
            /// <doc-id>ff476227</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
        }

        /// <summary>
        /// <p>Specifies the subresource from a 2D texture to use in a shader-resource view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a shader-resource-view description (see <strong><see cref = "SharpDX.Direct3D11.ShaderResourceViewDescription"/></strong>).</p>
        /// </remarks>
        /// <doc-id>ff476245</doc-id>
        /// <unmanaged>D3D11_TEX2D_SRV</unmanaged>
        /// <unmanaged-short>D3D11_TEX2D_SRV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DResource
        {
            /// <summary>
            /// <dd> <p>Index of the most detailed mipmap level to use; this number is between 0 and <strong>MipLevels</strong> (from the original Texture2D for which <strong>ID3D11Device::CreateShaderResourceView</strong> creates a view) -1.</p> </dd>
            /// </summary>
            /// <doc-id>ff476245</doc-id>
            /// <unmanaged>MostDetailedMip</unmanaged>
            /// <unmanaged-short>MostDetailedMip</unmanaged-short>
            public System.Int32 MostDetailedMip;
            /// <summary>
            /// <dd> <p>The maximum number of mipmap levels for the view of the texture. See the remarks in <strong><see cref = "SharpDX.Direct3D11.Texture1DResource"/></strong>.</p> <p>Set to -1 to indicate all the mipmap levels from <strong>MostDetailedMip</strong> on down to least detailed.</p> </dd>
            /// </summary>
            /// <doc-id>ff476245</doc-id>
            /// <unmanaged>MipLevels</unmanaged>
            /// <unmanaged-short>MipLevels</unmanaged-short>
            public System.Int32 MipLevels;
        }

        /// <summary>
        /// <p>Specifies the subresources from an array of 2D textures to use in a shader-resource view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a shader-resource-view description (see <strong><see cref = "SharpDX.Direct3D11.ShaderResourceViewDescription"/></strong>).</p>
        /// </remarks>
        /// <doc-id>ff476241</doc-id>
        /// <unmanaged>D3D11_TEX2D_ARRAY_SRV</unmanaged>
        /// <unmanaged-short>D3D11_TEX2D_ARRAY_SRV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DArrayResource
        {
            /// <summary>
            /// <dd> <p>Index of the most detailed mipmap level to use; this number is between 0 and <strong>MipLevels</strong> (from the original Texture2D for which <strong>ID3D11Device::CreateShaderResourceView</strong> creates a view) -1.</p> </dd>
            /// </summary>
            /// <doc-id>ff476241</doc-id>
            /// <unmanaged>MostDetailedMip</unmanaged>
            /// <unmanaged-short>MostDetailedMip</unmanaged-short>
            public System.Int32 MostDetailedMip;
            /// <summary>
            /// <dd> <p>The maximum number of mipmap levels for the view of the texture. See the remarks in <strong><see cref = "SharpDX.Direct3D11.Texture1DResource"/></strong>.</p> <p>Set to -1 to indicate all the mipmap levels from <strong>MostDetailedMip</strong> on down to least detailed.</p> </dd>
            /// </summary>
            /// <doc-id>ff476241</doc-id>
            /// <unmanaged>MipLevels</unmanaged>
            /// <unmanaged-short>MipLevels</unmanaged-short>
            public System.Int32 MipLevels;
            /// <summary>
            /// <dd> <p>The index of the first texture to use in an array of textures.</p> </dd>
            /// </summary>
            /// <doc-id>ff476241</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p>Number of textures in the array.</p> </dd>
            /// </summary>
            /// <doc-id>ff476241</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
        }

        /// <summary>
        /// <p>Specifies the subresources from a 3D texture to use in a shader-resource view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a shader-resource-view description (see <strong><see cref = "SharpDX.Direct3D11.ShaderResourceViewDescription"/></strong>).</p>
        /// </remarks>
        /// <doc-id>ff476248</doc-id>
        /// <unmanaged>D3D11_TEX3D_SRV</unmanaged>
        /// <unmanaged-short>D3D11_TEX3D_SRV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture3DResource
        {
            /// <summary>
            /// <dd> <p>Index of the most detailed mipmap level to use; this number is between 0 and <strong>MipLevels</strong> (from the original Texture3D for which <strong>ID3D11Device::CreateShaderResourceView</strong> creates a view) -1.</p> </dd>
            /// </summary>
            /// <doc-id>ff476248</doc-id>
            /// <unmanaged>MostDetailedMip</unmanaged>
            /// <unmanaged-short>MostDetailedMip</unmanaged-short>
            public System.Int32 MostDetailedMip;
            /// <summary>
            /// <dd> <p>The maximum number of mipmap levels for the view of the texture. See the remarks in <strong><see cref = "SharpDX.Direct3D11.Texture1DResource"/></strong>.</p> <p>Set to -1 to indicate all the mipmap levels from <strong>MostDetailedMip</strong> on down to least detailed.</p> </dd>
            /// </summary>
            /// <doc-id>ff476248</doc-id>
            /// <unmanaged>MipLevels</unmanaged>
            /// <unmanaged-short>MipLevels</unmanaged-short>
            public System.Int32 MipLevels;
        }

        /// <summary>
        /// <p>Specifies the subresource from a cube texture to use in a shader-resource view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a shader-resource-view description (see <strong><see cref = "SharpDX.Direct3D11.ShaderResourceViewDescription"/></strong>).</p>
        /// </remarks>
        /// <doc-id>ff476251</doc-id>
        /// <unmanaged>D3D11_TEXCUBE_SRV</unmanaged>
        /// <unmanaged-short>D3D11_TEXCUBE_SRV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct TextureCubeResource
        {
            /// <summary>
            /// <dd> <p>Index of the most detailed mipmap level to use; this number is between 0 and <strong>MipLevels</strong> (from the original TextureCube for which <strong>ID3D11Device::CreateShaderResourceView</strong> creates a view) -1.</p> </dd>
            /// </summary>
            /// <doc-id>ff476251</doc-id>
            /// <unmanaged>MostDetailedMip</unmanaged>
            /// <unmanaged-short>MostDetailedMip</unmanaged-short>
            public System.Int32 MostDetailedMip;
            /// <summary>
            /// <dd> <p>The maximum number of mipmap levels for the view of the texture. See the remarks in <strong><see cref = "SharpDX.Direct3D11.Texture1DResource"/></strong>.</p> <p>Set to -1 to indicate all the mipmap levels from <strong>MostDetailedMip</strong> on down to least detailed.</p> </dd>
            /// </summary>
            /// <doc-id>ff476251</doc-id>
            /// <unmanaged>MipLevels</unmanaged>
            /// <unmanaged-short>MipLevels</unmanaged-short>
            public System.Int32 MipLevels;
        }

        /// <summary>
        /// <p>Specifies the subresources from an array of cube textures to use in a shader-resource view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a shader-resource-view description (see <strong><see cref = "SharpDX.Direct3D11.ShaderResourceViewDescription"/></strong>).</p>
        /// </remarks>
        /// <doc-id>ff476250</doc-id>
        /// <unmanaged>D3D11_TEXCUBE_ARRAY_SRV</unmanaged>
        /// <unmanaged-short>D3D11_TEXCUBE_ARRAY_SRV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct TextureCubeArrayResource
        {
            /// <summary>
            /// <dd> <p>Index of the most detailed mipmap level to use; this number is between 0 and <strong>MipLevels</strong> (from the original TextureCube for which <strong>ID3D11Device::CreateShaderResourceView</strong> creates a view) -1.</p> </dd>
            /// </summary>
            /// <doc-id>ff476250</doc-id>
            /// <unmanaged>MostDetailedMip</unmanaged>
            /// <unmanaged-short>MostDetailedMip</unmanaged-short>
            public System.Int32 MostDetailedMip;
            /// <summary>
            /// <dd> <p>The maximum number of mipmap levels for the view of the texture. See the remarks in <strong><see cref = "SharpDX.Direct3D11.Texture1DResource"/></strong>.</p> <p>Set to -1 to indicate all the mipmap levels from <strong>MostDetailedMip</strong> on down to least detailed.</p> </dd>
            /// </summary>
            /// <doc-id>ff476250</doc-id>
            /// <unmanaged>MipLevels</unmanaged>
            /// <unmanaged-short>MipLevels</unmanaged-short>
            public System.Int32 MipLevels;
            /// <summary>
            /// <dd> <p>Index of the first 2D texture to use.</p> </dd>
            /// </summary>
            /// <doc-id>ff476250</doc-id>
            /// <unmanaged>First2DArrayFace</unmanaged>
            /// <unmanaged-short>First2DArrayFace</unmanaged-short>
            public System.Int32 First2DArrayFace;
            /// <summary>
            /// <dd> <p>Number of cube textures in the array.</p> </dd>
            /// </summary>
            /// <doc-id>ff476250</doc-id>
            /// <unmanaged>NumCubes</unmanaged>
            /// <unmanaged-short>NumCubes</unmanaged-short>
            public System.Int32 CubeCount;
        }

        /// <summary>
        /// <p>Specifies the subresources from a multisampled 2D texture to use in a shader-resource view.</p>
        /// </summary>
        /// <remarks>
        /// <p>Since a multisampled 2D texture contains a single subresource, there is actually nothing to specify in <see cref = "SharpDX.Direct3D11.Texture2DMultisampledResource"/>. Consequently, <strong>UnusedField_NothingToDefine</strong> is included so that this structure will compile in C.</p>
        /// </remarks>
        /// <doc-id>ff476238</doc-id>
        /// <unmanaged>D3D11_TEX2DMS_SRV</unmanaged>
        /// <unmanaged-short>D3D11_TEX2DMS_SRV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DMultisampledResource
        {
            /// <summary>
            /// <dd> <p>Integer of any value. See remarks.</p> </dd>
            /// </summary>
            /// <doc-id>ff476238</doc-id>
            /// <unmanaged>UnusedField_NothingToDefine</unmanaged>
            /// <unmanaged-short>UnusedField_NothingToDefine</unmanaged-short>
            public System.Int32 UnusedFieldNothingToDefine;
        }

        /// <summary>
        /// <p>Specifies the subresources from an array of multisampled 2D textures to use in a shader-resource view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is one member of a shader-resource-view description (see <strong><see cref = "SharpDX.Direct3D11.ShaderResourceViewDescription"/></strong>).</p>
        /// </remarks>
        /// <doc-id>ff476235</doc-id>
        /// <unmanaged>D3D11_TEX2DMS_ARRAY_SRV</unmanaged>
        /// <unmanaged-short>D3D11_TEX2DMS_ARRAY_SRV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DMultisampledArrayResource
        {
            /// <summary>
            /// <dd> <p>The index of the first texture to use in an array of textures.</p> </dd>
            /// </summary>
            /// <doc-id>ff476235</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p>Number of textures to use.</p> </dd>
            /// </summary>
            /// <doc-id>ff476235</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
        }

        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.DXGI.Format"/></strong> specifying the viewing format. See remarks.</p> </dd>
        /// </summary>
        /// <doc-id>ff476211</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p>The resource type of the view. See <strong>D3D11_SRV_DIMENSION</strong>. This should be the same as the resource type of the underlying resource. This parameter also determines which _SRV to use in the union below.</p> </dd>
        /// </summary>
        /// <doc-id>ff476211</doc-id>
        /// <unmanaged>ViewDimension</unmanaged>
        /// <unmanaged-short>ViewDimension</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(4)]
        public SharpDX.Direct3D.ShaderResourceViewDimension Dimension;
        /// <summary>
        /// <dd> <p>View the resource as a buffer using information from a shader-resource view (see <strong><see cref = "SharpDX.Direct3D11.BufferResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476211</doc-id>
        /// <unmanaged>Buffer</unmanaged>
        /// <unmanaged-short>Buffer</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.ShaderResourceViewDescription.BufferResource Buffer;
        /// <summary>
        /// <dd> <p>View the resource as a 1D texture using information from a shader-resource view (see <strong><see cref = "SharpDX.Direct3D11.Texture1DResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476211</doc-id>
        /// <unmanaged>Texture1D</unmanaged>
        /// <unmanaged-short>Texture1D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.ShaderResourceViewDescription.Texture1DResource Texture1D;
        /// <summary>
        /// <dd> <p>View the resource as a 1D-texture array using information from a shader-resource view (see <strong><see cref = "SharpDX.Direct3D11.Texture1DArrayResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476211</doc-id>
        /// <unmanaged>Texture1DArray</unmanaged>
        /// <unmanaged-short>Texture1DArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.ShaderResourceViewDescription.Texture1DArrayResource Texture1DArray;
        /// <summary>
        /// <dd> <p>View the resource as a 2D-texture using information from a shader-resource view (see <strong><see cref = "SharpDX.Direct3D11.Texture2DResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476211</doc-id>
        /// <unmanaged>Texture2D</unmanaged>
        /// <unmanaged-short>Texture2D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.ShaderResourceViewDescription.Texture2DResource Texture2D;
        /// <summary>
        /// <dd> <p>View the resource as a 2D-texture array using information from a shader-resource view (see <strong><see cref = "SharpDX.Direct3D11.Texture2DArrayResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476211</doc-id>
        /// <unmanaged>Texture2DArray</unmanaged>
        /// <unmanaged-short>Texture2DArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.ShaderResourceViewDescription.Texture2DArrayResource Texture2DArray;
        /// <summary>
        /// <dd> <p>View the resource as a 2D-multisampled texture using information from a shader-resource view (see <strong><see cref = "SharpDX.Direct3D11.Texture2DMultisampledResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476211</doc-id>
        /// <unmanaged>Texture2DMS</unmanaged>
        /// <unmanaged-short>Texture2DMS</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.ShaderResourceViewDescription.Texture2DMultisampledResource Texture2DMS;
        /// <summary>
        /// <dd> <p>View the resource as a 2D-multisampled-texture array using information from a shader-resource view (see <strong><see cref = "SharpDX.Direct3D11.Texture2DMultisampledArrayResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476211</doc-id>
        /// <unmanaged>Texture2DMSArray</unmanaged>
        /// <unmanaged-short>Texture2DMSArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.ShaderResourceViewDescription.Texture2DMultisampledArrayResource Texture2DMSArray;
        /// <summary>
        /// <dd> <p>View the resource as a 3D texture using information from a shader-resource view (see <strong><see cref = "SharpDX.Direct3D11.Texture3DResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476211</doc-id>
        /// <unmanaged>Texture3D</unmanaged>
        /// <unmanaged-short>Texture3D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.ShaderResourceViewDescription.Texture3DResource Texture3D;
        /// <summary>
        /// <dd> <p>View the resource as a 3D-cube texture using information from a shader-resource view (see <strong><see cref = "SharpDX.Direct3D11.TextureCubeResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476211</doc-id>
        /// <unmanaged>TextureCube</unmanaged>
        /// <unmanaged-short>TextureCube</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.ShaderResourceViewDescription.TextureCubeResource TextureCube;
        /// <summary>
        /// <dd> <p>View the resource as a 3D-cube-texture array using information from a shader-resource view (see <strong><see cref = "SharpDX.Direct3D11.TextureCubeArrayResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476211</doc-id>
        /// <unmanaged>TextureCubeArray</unmanaged>
        /// <unmanaged-short>TextureCubeArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.ShaderResourceViewDescription.TextureCubeArrayResource TextureCubeArray;
        /// <summary>
        /// <dd> <p>View the resource as a raw buffer using information from a shader-resource view (see <strong><see cref = "SharpDX.Direct3D11.ExtendedBufferResource"/></strong>). For more info about raw viewing of buffers, see Raw Views of Buffers.</p> </dd>
        /// </summary>
        /// <doc-id>ff476211</doc-id>
        /// <unmanaged>BufferEx</unmanaged>
        /// <unmanaged-short>BufferEx</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.ShaderResourceViewDescription.ExtendedBufferResource BufferEx;
    }

    /// <summary>
    /// <p>Describes a shader-resource view.</p>
    /// </summary>
    /// <remarks>
    /// <p>A view is a format-specific way to look at the data in a resource. The view determines what data to look at, and how it is cast when read.</p><p>When viewing a resource, the resource-view description must specify a typed format, that is compatible with the resource format. So that means that you cannot create a resource-view description using any format with _TYPELESS in the name. You can however view a typeless resource by specifying a typed format for the view. For example, a DXGI_FORMAT_R32G32B32_TYPELESS resource can be viewed with one of these typed formats: DXGI_FORMAT_R32G32B32_FLOAT, DXGI_FORMAT_R32G32B32_UINT, and DXGI_FORMAT_R32G32B32_SINT, since these typed formats are compatible with the typeless resource.</p><p>Create a shader-resource-view description by calling <strong>ID3D11Device3::CreateShaderResourceView1</strong>. To view a shader-resource-view description, call <strong>ID3D11ShaderResourceView1::GetDesc1</strong>.</p>
    /// </remarks>
    /// <doc-id>dn899159</doc-id>
    /// <unmanaged>D3D11_SHADER_RESOURCE_VIEW_DESC1</unmanaged>
    /// <unmanaged-short>D3D11_SHADER_RESOURCE_VIEW_DESC1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct ShaderResourceViewDescription1
    {
        /// <summary>
        /// <p>Describes the subresource from a 2D texture to use in a shader-resource view.</p>
        /// </summary>
        /// <doc-id>dn899164</doc-id>
        /// <unmanaged>D3D11_TEX2D_SRV1</unmanaged>
        /// <unmanaged-short>D3D11_TEX2D_SRV1</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DResource1
        {
            /// <summary>
            /// <dd> <p> Index of the most detailed mipmap level to use; this number is between 0 and (<strong>MipLevels</strong> (from the original Texture2D for which  <strong>ID3D11Device3::CreateShaderResourceView1</strong> creates a view) - 1 ). </p> </dd>
            /// </summary>
            /// <doc-id>dn899164</doc-id>
            /// <unmanaged>MostDetailedMip</unmanaged>
            /// <unmanaged-short>MostDetailedMip</unmanaged-short>
            public System.Int32 MostDetailedMip;
            /// <summary>
            /// <dd> <p> The maximum number of mipmap levels for the view of the texture. See the remarks in <strong><see cref = "SharpDX.Direct3D11.Texture1DResource"/></strong>. </p> <p> Set to -1 to indicate all the mipmap levels from <strong>MostDetailedMip</strong> on down to least detailed. </p> </dd>
            /// </summary>
            /// <doc-id>dn899164</doc-id>
            /// <unmanaged>MipLevels</unmanaged>
            /// <unmanaged-short>MipLevels</unmanaged-short>
            public System.Int32 MipLevels;
            /// <summary>
            /// <dd> <p>The index (plane slice number) of the plane to use in the texture.</p> </dd>
            /// </summary>
            /// <doc-id>dn899164</doc-id>
            /// <unmanaged>PlaneSlice</unmanaged>
            /// <unmanaged-short>PlaneSlice</unmanaged-short>
            public System.Int32 PlaneSlice;
        }

        /// <summary>
        /// <p>Describes the subresources from an array of 2D textures to use in a shader-resource view.</p>
        /// </summary>
        /// <doc-id>dn899161</doc-id>
        /// <unmanaged>D3D11_TEX2D_ARRAY_SRV1</unmanaged>
        /// <unmanaged-short>D3D11_TEX2D_ARRAY_SRV1</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DArrayResource1
        {
            /// <summary>
            /// <dd> <p> Index of the most detailed mipmap level to use; this number is between 0 and ( <strong>MipLevels</strong> (from the original Texture2D for which  <strong>ID3D11Device3::CreateShaderResourceView1</strong> creates a view) - 1). </p> </dd>
            /// </summary>
            /// <doc-id>dn899161</doc-id>
            /// <unmanaged>MostDetailedMip</unmanaged>
            /// <unmanaged-short>MostDetailedMip</unmanaged-short>
            public System.Int32 MostDetailedMip;
            /// <summary>
            /// <dd> <p> The maximum number of mipmap levels for the view of the texture. See the remarks in <strong><see cref = "SharpDX.Direct3D11.Texture1DResource"/></strong>. </p> <p> Set to -1 to indicate all the mipmap levels from <strong>MostDetailedMip</strong> on down to least detailed. </p> </dd>
            /// </summary>
            /// <doc-id>dn899161</doc-id>
            /// <unmanaged>MipLevels</unmanaged>
            /// <unmanaged-short>MipLevels</unmanaged-short>
            public System.Int32 MipLevels;
            /// <summary>
            /// <dd> <p>The index of the first texture to use in an array of textures.</p> </dd>
            /// </summary>
            /// <doc-id>dn899161</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p>Number of textures in the array.</p> </dd>
            /// </summary>
            /// <doc-id>dn899161</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
            /// <summary>
            /// <dd> <p>The index (plane slice number) of the plane to use in an array of textures.</p> </dd>
            /// </summary>
            /// <doc-id>dn899161</doc-id>
            /// <unmanaged>PlaneSlice</unmanaged>
            /// <unmanaged-short>PlaneSlice</unmanaged-short>
            public System.Int32 PlaneSlice;
        }

        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.DXGI.Format"/></strong>-typed value that  specifies the viewing format. See remarks.</p> </dd>
        /// </summary>
        /// <doc-id>dn899159</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p>A <strong>D3D11_SRV_DIMENSION</strong>-typed value that  specifies the resource type of the view. This type is the same as the resource type of the underlying resource. This member also determines which _SRV to use in the union below.</p> </dd>
        /// </summary>
        /// <doc-id>dn899159</doc-id>
        /// <unmanaged>ViewDimension</unmanaged>
        /// <unmanaged-short>ViewDimension</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(4)]
        public SharpDX.Direct3D.ShaderResourceViewDimension Dimension;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.BufferResource"/></strong> structure that views the resource as a buffer.</p> </dd>
        /// </summary>
        /// <doc-id>dn899159</doc-id>
        /// <unmanaged>Buffer</unmanaged>
        /// <unmanaged-short>Buffer</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.ShaderResourceViewDescription.BufferResource Buffer;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.Texture1DResource"/></strong> structure that views the resource as a 1D texture.</p> </dd>
        /// </summary>
        /// <doc-id>dn899159</doc-id>
        /// <unmanaged>Texture1D</unmanaged>
        /// <unmanaged-short>Texture1D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.ShaderResourceViewDescription.Texture1DResource Texture1D;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.Texture1DArrayResource"/></strong> structure that views the resource as a 1D-texture array.</p> </dd>
        /// </summary>
        /// <doc-id>dn899159</doc-id>
        /// <unmanaged>Texture1DArray</unmanaged>
        /// <unmanaged-short>Texture1DArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.ShaderResourceViewDescription.Texture1DArrayResource Texture1DArray;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.Texture2DResource1"/></strong> structure that views the resource as a 2D-texture.</p> </dd>
        /// </summary>
        /// <doc-id>dn899159</doc-id>
        /// <unmanaged>Texture2D</unmanaged>
        /// <unmanaged-short>Texture2D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.ShaderResourceViewDescription1.Texture2DResource1 Texture2D;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.Texture2DArrayResource1"/></strong> structure that views the resource as a 2D-texture array.</p> </dd>
        /// </summary>
        /// <doc-id>dn899159</doc-id>
        /// <unmanaged>Texture2DArray</unmanaged>
        /// <unmanaged-short>Texture2DArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.ShaderResourceViewDescription1.Texture2DArrayResource1 Texture2DArray;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.Texture2DMultisampledResource"/></strong> structure that views the resource as a 2D-multisampled texture.</p> </dd>
        /// </summary>
        /// <doc-id>dn899159</doc-id>
        /// <unmanaged>Texture2DMS</unmanaged>
        /// <unmanaged-short>Texture2DMS</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.ShaderResourceViewDescription.Texture2DMultisampledResource Texture2DMS;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.Texture2DMultisampledArrayResource"/></strong> structure that views the resource as a 2D-multisampled-texture array.</p> </dd>
        /// </summary>
        /// <doc-id>dn899159</doc-id>
        /// <unmanaged>Texture2DMSArray</unmanaged>
        /// <unmanaged-short>Texture2DMSArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.ShaderResourceViewDescription.Texture2DMultisampledArrayResource Texture2DMSArray;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.Texture3DResource"/></strong> structure that views the resource as a 3D texture.</p> </dd>
        /// </summary>
        /// <doc-id>dn899159</doc-id>
        /// <unmanaged>Texture3D</unmanaged>
        /// <unmanaged-short>Texture3D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.ShaderResourceViewDescription.Texture3DResource Texture3D;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.TextureCubeResource"/></strong> structure that views the resource as a 3D-cube texture.</p> </dd>
        /// </summary>
        /// <doc-id>dn899159</doc-id>
        /// <unmanaged>TextureCube</unmanaged>
        /// <unmanaged-short>TextureCube</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.ShaderResourceViewDescription.TextureCubeResource TextureCube;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.TextureCubeArrayResource"/></strong> structure that views the resource as a 3D-cube-texture array.</p> </dd>
        /// </summary>
        /// <doc-id>dn899159</doc-id>
        /// <unmanaged>TextureCubeArray</unmanaged>
        /// <unmanaged-short>TextureCubeArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.ShaderResourceViewDescription.TextureCubeArrayResource TextureCubeArray;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.ExtendedBufferResource"/></strong> structure that views the resource as a raw buffer. For more info about raw viewing of buffers, see Raw Views of Buffers.</p> </dd>
        /// </summary>
        /// <doc-id>dn899159</doc-id>
        /// <unmanaged>BufferEx</unmanaged>
        /// <unmanaged-short>BufferEx</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.ShaderResourceViewDescription.ExtendedBufferResource BufferEx;
    }

    /// <summary>
    /// <p>Description of a vertex element in a vertex buffer in an output slot.</p>
    /// </summary>
    /// <doc-id>ff476216</doc-id>
    /// <unmanaged>D3D11_SO_DECLARATION_ENTRY</unmanaged>
    /// <unmanaged-short>D3D11_SO_DECLARATION_ENTRY</unmanaged-short>
    public partial struct StreamOutputElement
    {
        /// <summary>
        /// <dd> <p>Zero-based, stream number.</p> </dd>
        /// </summary>
        /// <doc-id>ff476216</doc-id>
        /// <unmanaged>Stream</unmanaged>
        /// <unmanaged-short>Stream</unmanaged-short>
        public System.Int32 Stream;
        /// <summary>
        /// <dd> <p>Type of output element; possible values include: <strong>"POSITION"</strong>, <strong>"NORMAL"</strong>, or <strong>"TEXCOORD0"</strong>. Note that if <em>SemanticName</em> is <strong><c>null</c></strong> then  <em>ComponentCount</em> can be greater than 4 and the described entry will be a gap in the stream out where no data will be written. </p> </dd>
        /// </summary>
        /// <doc-id>ff476216</doc-id>
        /// <unmanaged>SemanticName</unmanaged>
        /// <unmanaged-short>SemanticName</unmanaged-short>
        public System.String SemanticName;
        /// <summary>
        /// <dd> <p>Output element's zero-based index. Should be used if, for example, you have more than one texture coordinate stored in each vertex.</p> </dd>
        /// </summary>
        /// <doc-id>ff476216</doc-id>
        /// <unmanaged>SemanticIndex</unmanaged>
        /// <unmanaged-short>SemanticIndex</unmanaged-short>
        public System.Int32 SemanticIndex;
        /// <summary>
        /// <dd> <p>Which component of the entry to begin writing out to. Valid values are 0 to 3. For example, if you only wish to output to the y and z components  of a position, then StartComponent should be 1 and ComponentCount should be 2.</p> </dd>
        /// </summary>
        /// <doc-id>ff476216</doc-id>
        /// <unmanaged>StartComponent</unmanaged>
        /// <unmanaged-short>StartComponent</unmanaged-short>
        public System.Byte StartComponent;
        /// <summary>
        /// <dd> <p>The number of components of the entry to write out to. Valid values are 1 to 4. For example, if you only wish to output to the y and z components  of a position, then StartComponent should be 1 and ComponentCount should be 2.  Note that if <em>SemanticName</em> is <strong><c>null</c></strong> then  <em>ComponentCount</em> can be greater than 4 and the described entry will be a gap in the stream out where no data will be written.</p> </dd>
        /// </summary>
        /// <doc-id>ff476216</doc-id>
        /// <unmanaged>ComponentCount</unmanaged>
        /// <unmanaged-short>ComponentCount</unmanaged-short>
        public System.Byte ComponentCount;
        /// <summary>
        /// <dd> <p>The associated stream output buffer that is bound to the pipeline  (see <strong>ID3D11DeviceContext::SOSetTargets</strong>).  The valid range for <em>OutputSlot</em> is 0 to 3.</p> </dd>
        /// </summary>
        /// <doc-id>ff476216</doc-id>
        /// <unmanaged>OutputSlot</unmanaged>
        /// <unmanaged-short>OutputSlot</unmanaged-short>
        public System.Byte OutputSlot;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Int32 Stream;
            public System.IntPtr SemanticName;
            public System.Int32 SemanticIndex;
            public System.Byte StartComponent;
            public System.Byte ComponentCount;
            public System.Byte OutputSlot;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.SemanticName);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Stream = @ref.Stream;
            SemanticName = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(@ref.SemanticName);
            SemanticIndex = @ref.SemanticIndex;
            StartComponent = @ref.StartComponent;
            ComponentCount = @ref.ComponentCount;
            OutputSlot = @ref.OutputSlot;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Stream = Stream;
            @ref.SemanticName = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(SemanticName);
            @ref.SemanticIndex = SemanticIndex;
            @ref.StartComponent = StartComponent;
            @ref.ComponentCount = ComponentCount;
            @ref.OutputSlot = OutputSlot;
        }
    }

    /// <summary>
    /// <p>Query information about the amount of data streamed out to the stream-output buffers in between <strong>ID3D11DeviceContext::Begin</strong> and <strong>ID3D11DeviceContext::End</strong>.</p>
    /// </summary>
    /// <doc-id>ff476193</doc-id>
    /// <unmanaged>D3D11_QUERY_DATA_SO_STATISTICS</unmanaged>
    /// <unmanaged-short>D3D11_QUERY_DATA_SO_STATISTICS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct StreamOutputStatistics
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ff476193</doc-id>
        /// <unmanaged>NumPrimitivesWritten</unmanaged>
        /// <unmanaged-short>NumPrimitivesWritten</unmanaged-short>
        public System.Int64 NumPrimitivesWritten;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>ff476193</doc-id>
        /// <unmanaged>PrimitivesStorageNeeded</unmanaged>
        /// <unmanaged-short>PrimitivesStorageNeeded</unmanaged-short>
        public System.Int64 PrimitivesStorageNeeded;
    }

    /// <summary>
    /// <p>Describes a tiled subresource volume.</p>
    /// </summary>
    /// <remarks>
    /// <p>Each packed mipmap is individually reported as 0 for <strong>WidthInTiles</strong>, <strong>HeightInTiles</strong> and <strong>DepthInTiles</strong>.
    /// </p><p>The total number of tiles in subresources is <strong>WidthInTiles</strong>*<strong>HeightInTiles</strong>*<strong>DepthInTiles</strong>. </p>
    /// </remarks>
    /// <doc-id>dn280434</doc-id>
    /// <unmanaged>D3D11_SUBRESOURCE_TILING</unmanaged>
    /// <unmanaged-short>D3D11_SUBRESOURCE_TILING</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct SubResourceTiling
    {
        /// <summary>
        /// <dd> <p>The width in tiles of the subresource.</p> </dd>
        /// </summary>
        /// <doc-id>dn280434</doc-id>
        /// <unmanaged>WidthInTiles</unmanaged>
        /// <unmanaged-short>WidthInTiles</unmanaged-short>
        public System.Int32 WidthInTiles;
        /// <summary>
        /// <dd> <p>The height in tiles of the subresource.</p> </dd>
        /// </summary>
        /// <doc-id>dn280434</doc-id>
        /// <unmanaged>HeightInTiles</unmanaged>
        /// <unmanaged-short>HeightInTiles</unmanaged-short>
        public System.Int16 HeightInTiles;
        /// <summary>
        /// <dd> <p>The depth in tiles of the subresource.</p> </dd>
        /// </summary>
        /// <doc-id>dn280434</doc-id>
        /// <unmanaged>DepthInTiles</unmanaged>
        /// <unmanaged-short>DepthInTiles</unmanaged-short>
        public System.Int16 DepthInTiles;
        /// <summary>
        /// <dd> <p>The index of the tile in the overall tiled subresource to start with. </p> <p> <strong>GetResourceTiling</strong> sets <strong>StartTileIndexInOverallResource</strong> to <strong>D3D11_PACKED_TILE</strong> (0xffffffff) to indicate that the whole 
        /// <strong><see cref = "SharpDX.Direct3D11.SubResourceTiling"/></strong> structure is meaningless, and the info to which the <em>pPackedMipDesc</em> parameter of <strong>GetResourceTiling</strong> points applies. For packed tiles, the description of the packed mipmaps comes from a <strong><see cref = "SharpDX.Direct3D11.PackedMipDescription"/></strong> structure instead.
        /// </p> </dd>
        /// </summary>
        /// <doc-id>dn280434</doc-id>
        /// <unmanaged>StartTileIndexInOverallResource</unmanaged>
        /// <unmanaged-short>StartTileIndexInOverallResource</unmanaged-short>
        public System.Int32 StartTileIndexInOverallResource;
    }

    /// <summary>
    /// <p>Describes a 1D texture.</p>
    /// </summary>
    /// <remarks>
    /// <p>This structure is used in a call to <strong>ID3D11Device::CreateTexture1D</strong>.</p><p>In addition to this structure, you can also use the <strong>CD3D11_TEXTURE1D_DESC</strong> derived structure, which is defined  in D3D11.h and behaves like an inherited class, to help create a texture description.</p><p>The texture size range is determined by the feature level at which you create the device and not the Microsoft Direct3D interface version. For example, if you use Microsoft Direct3D?10 hardware at feature level 10 (<strong>D3D_FEATURE_LEVEL_10_0</strong>) and call <strong>D3D11CreateDevice</strong> to create an <strong><see cref = "SharpDX.Direct3D11.Device"/></strong>, you must constrain the maximum texture size to D3D10_REQ_TEXTURE1D_U_DIMENSION (8192) when you create your 1D texture.</p>
    /// </remarks>
    /// <doc-id>ff476252</doc-id>
    /// <unmanaged>D3D11_TEXTURE1D_DESC</unmanaged>
    /// <unmanaged-short>D3D11_TEXTURE1D_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct Texture1DDescription
    {
        /// <summary>
        /// <dd> <p>Texture width (in texels). The  range is from 1 to <see cref = "MaximumTexture1DSize"/> (16384). However, the range is actually constrained by the feature level at which you create the rendering device. For more information about restrictions, see Remarks.</p> </dd>
        /// </summary>
        /// <doc-id>ff476252</doc-id>
        /// <unmanaged>Width</unmanaged>
        /// <unmanaged-short>Width</unmanaged-short>
        public System.Int32 Width;
        /// <summary>
        /// <dd> <p>The maximum number of mipmap levels in the texture. See the remarks in <strong><see cref = "SharpDX.Direct3D11.Texture1DResource"/></strong>. Use 1 for a multisampled texture; or 0 to generate a full set of subtextures.</p> </dd>
        /// </summary>
        /// <doc-id>ff476252</doc-id>
        /// <unmanaged>MipLevels</unmanaged>
        /// <unmanaged-short>MipLevels</unmanaged-short>
        public System.Int32 MipLevels;
        /// <summary>
        /// <dd> <p>Number of textures in the array. The  range is from 1 to <see cref = "MaximumTexture1DArraySize"/> (2048). However, the range is actually constrained by the feature level at which you create the rendering device. For more information about restrictions, see Remarks.</p> </dd>
        /// </summary>
        /// <doc-id>ff476252</doc-id>
        /// <unmanaged>ArraySize</unmanaged>
        /// <unmanaged-short>ArraySize</unmanaged-short>
        public System.Int32 ArraySize;
        /// <summary>
        /// <dd> <p>Texture format (see <strong><see cref = "SharpDX.DXGI.Format"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476252</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p>Value that identifies how the texture is to be read from and written to. The most common value is D3D11_USAGE_DEFAULT; see <strong><see cref = "SharpDX.Direct3D11.ResourceUsage"/></strong> for all possible values.</p> </dd>
        /// </summary>
        /// <doc-id>ff476252</doc-id>
        /// <unmanaged>Usage</unmanaged>
        /// <unmanaged-short>Usage</unmanaged-short>
        public SharpDX.Direct3D11.ResourceUsage Usage;
        /// <summary>
        /// <dd> <p>Flags (see <strong><see cref = "SharpDX.Direct3D11.BindFlags"/></strong>) for binding to pipeline stages. The flags can be combined by a logical OR. For a 1D texture, the allowable values are: D3D11_BIND_SHADER_RESOURCE, D3D11_BIND_RENDER_TARGET and D3D11_BIND_DEPTH_STENCIL.</p> </dd>
        /// </summary>
        /// <doc-id>ff476252</doc-id>
        /// <unmanaged>BindFlags</unmanaged>
        /// <unmanaged-short>BindFlags</unmanaged-short>
        public SharpDX.Direct3D11.BindFlags BindFlags;
        /// <summary>
        /// <dd> <p>Flags (see <strong><see cref = "SharpDX.Direct3D11.CpuAccessFlags"/></strong>) to specify the types of CPU access allowed. Use 0 if CPU access is not required. These flags can be combined with a logical OR.</p> </dd>
        /// </summary>
        /// <doc-id>ff476252</doc-id>
        /// <unmanaged>CPUAccessFlags</unmanaged>
        /// <unmanaged-short>CPUAccessFlags</unmanaged-short>
        public SharpDX.Direct3D11.CpuAccessFlags CpuAccessFlags;
        /// <summary>
        /// <dd> <p>Flags (see <strong><see cref = "SharpDX.Direct3D11.ResourceOptionFlags"/></strong>) that identify other, less common resource options. Use 0 if none of these flags apply. These flags can be combined with a logical OR.</p> </dd>
        /// </summary>
        /// <doc-id>ff476252</doc-id>
        /// <unmanaged>MiscFlags</unmanaged>
        /// <unmanaged-short>MiscFlags</unmanaged-short>
        public SharpDX.Direct3D11.ResourceOptionFlags OptionFlags;
    }

    /// <summary>
    /// <p>Identifies a texture resource for a video  processor output view.</p>
    /// </summary>
    /// <doc-id>hh447632</doc-id>
    /// <unmanaged>D3D11_TEX2D_ARRAY_VPOV</unmanaged>
    /// <unmanaged-short>D3D11_TEX2D_ARRAY_VPOV</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct Texture2DArrayVpov
    {
        /// <summary>
        /// <dd> <p>The zero-based index into the array of subtextures.</p> </dd>
        /// </summary>
        /// <doc-id>hh447632</doc-id>
        /// <unmanaged>MipSlice</unmanaged>
        /// <unmanaged-short>MipSlice</unmanaged-short>
        public System.Int32 MipSlice;
        /// <summary>
        /// <dd> <p>The index of the first texture to use.</p> </dd>
        /// </summary>
        /// <doc-id>hh447632</doc-id>
        /// <unmanaged>FirstArraySlice</unmanaged>
        /// <unmanaged-short>FirstArraySlice</unmanaged-short>
        public System.Int32 FirstArraySlice;
        /// <summary>
        /// <dd> <p>The number of textures in the array.</p> </dd>
        /// </summary>
        /// <doc-id>hh447632</doc-id>
        /// <unmanaged>ArraySize</unmanaged>
        /// <unmanaged-short>ArraySize</unmanaged-short>
        public System.Int32 ArraySize;
    }

    /// <summary>
    /// <p>Describes a 2D texture.</p>
    /// </summary>
    /// <remarks>
    /// <p>This structure is used in a call to <strong>ID3D11Device::CreateTexture2D</strong>.</p><p>In addition to this structure, you can also use the <strong>CD3D11_TEXTURE2D_DESC</strong> derived structure, which is defined  in D3D11.h and behaves like an inherited class, to help create a texture description.</p><p>The device places some size restrictions (must be multiples of a minimum size) for a subsampled, block compressed, or bit-format resource.</p><p>The texture size range is determined by the feature level at which you create the device and not the Microsoft Direct3D interface version. For example, if you use Microsoft Direct3D?10 hardware at feature level 10 (<strong>D3D_FEATURE_LEVEL_10_0</strong>) and call <strong>D3D11CreateDevice</strong> to create an <strong><see cref = "SharpDX.Direct3D11.Device"/></strong>, you must constrain the maximum texture size to D3D10_REQ_TEXTURE2D_U_OR_V_DIMENSION (8192) when you create your 2D texture.</p>
    /// </remarks>
    /// <doc-id>ff476253</doc-id>
    /// <unmanaged>D3D11_TEXTURE2D_DESC</unmanaged>
    /// <unmanaged-short>D3D11_TEXTURE2D_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct Texture2DDescription
    {
        /// <summary>
        /// <dd> <p>Texture width (in texels). The  range is from 1 to <see cref = "MaximumTexture2DSize"/> (16384). For a texture cube-map, the  range is from 1 to <see cref = "MaximumTextureCubeSize"/> (16384). However, the range is actually constrained by the feature level at which you create the rendering device. For more information about restrictions, see Remarks.</p> </dd>
        /// </summary>
        /// <doc-id>ff476253</doc-id>
        /// <unmanaged>Width</unmanaged>
        /// <unmanaged-short>Width</unmanaged-short>
        public System.Int32 Width;
        /// <summary>
        /// <dd> <p>Texture height (in texels). The  range is from 1 to <see cref = "MaximumTexture2DSize"/> (16384). For a texture cube-map, the  range is from 1 to <see cref = "MaximumTextureCubeSize"/> (16384). However, the range is actually constrained by the feature level at which you create the rendering device. For more information about restrictions, see Remarks.</p> </dd>
        /// </summary>
        /// <doc-id>ff476253</doc-id>
        /// <unmanaged>Height</unmanaged>
        /// <unmanaged-short>Height</unmanaged-short>
        public System.Int32 Height;
        /// <summary>
        /// <dd> <p>The maximum number of mipmap levels in the texture. See the remarks in <strong><see cref = "SharpDX.Direct3D11.Texture1DResource"/></strong>. Use 1 for a multisampled texture; or 0 to generate a full set of subtextures.</p> </dd>
        /// </summary>
        /// <doc-id>ff476253</doc-id>
        /// <unmanaged>MipLevels</unmanaged>
        /// <unmanaged-short>MipLevels</unmanaged-short>
        public System.Int32 MipLevels;
        /// <summary>
        /// <dd> <p>Number of textures in the texture array. The  range is from 1 to <see cref = "MaximumTexture2DArraySize"/> (2048). For a texture cube-map, this value is a multiple of 6 (that is, 6 times the value in the <strong>NumCubes</strong> member of <strong><see cref = "SharpDX.Direct3D11.TextureCubeArrayResource"/></strong>), and the  range is from 6 to 2046. The range is actually constrained by the feature level at which you create the rendering device. For more information about restrictions, see Remarks.</p> </dd>
        /// </summary>
        /// <doc-id>ff476253</doc-id>
        /// <unmanaged>ArraySize</unmanaged>
        /// <unmanaged-short>ArraySize</unmanaged-short>
        public System.Int32 ArraySize;
        /// <summary>
        /// <dd> <p>Texture format (see <strong><see cref = "SharpDX.DXGI.Format"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476253</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p>Structure that specifies multisampling parameters for the texture. See <strong><see cref = "SharpDX.DXGI.SampleDescription"/></strong>.</p> </dd>
        /// </summary>
        /// <doc-id>ff476253</doc-id>
        /// <unmanaged>SampleDesc</unmanaged>
        /// <unmanaged-short>SampleDesc</unmanaged-short>
        public SharpDX.DXGI.SampleDescription SampleDescription;
        /// <summary>
        /// <dd> <p>Value that identifies how the texture is to be read from and written to. The most common value is D3D11_USAGE_DEFAULT; see <strong><see cref = "SharpDX.Direct3D11.ResourceUsage"/></strong> for all possible values.</p> </dd>
        /// </summary>
        /// <doc-id>ff476253</doc-id>
        /// <unmanaged>Usage</unmanaged>
        /// <unmanaged-short>Usage</unmanaged-short>
        public SharpDX.Direct3D11.ResourceUsage Usage;
        /// <summary>
        /// <dd> <p>Flags (see <strong><see cref = "SharpDX.Direct3D11.BindFlags"/></strong>) for binding to pipeline stages. The flags can be combined by a logical OR.</p> </dd>
        /// </summary>
        /// <doc-id>ff476253</doc-id>
        /// <unmanaged>BindFlags</unmanaged>
        /// <unmanaged-short>BindFlags</unmanaged-short>
        public SharpDX.Direct3D11.BindFlags BindFlags;
        /// <summary>
        /// <dd> <p>Flags (see <strong><see cref = "SharpDX.Direct3D11.CpuAccessFlags"/></strong>) to specify the types of CPU access allowed. Use 0 if CPU access is not required. These flags can be combined with a logical OR.</p> </dd>
        /// </summary>
        /// <doc-id>ff476253</doc-id>
        /// <unmanaged>CPUAccessFlags</unmanaged>
        /// <unmanaged-short>CPUAccessFlags</unmanaged-short>
        public SharpDX.Direct3D11.CpuAccessFlags CpuAccessFlags;
        /// <summary>
        /// <dd> <p>Flags (see <strong><see cref = "SharpDX.Direct3D11.ResourceOptionFlags"/></strong>) that identify other, less common resource options. Use 0 if none of these flags apply. These flags can be combined by using a logical OR. For a texture cube-map, set the <strong>D3D11_RESOURCE_MISC_TEXTURECUBE</strong> flag. Cube-map arrays (that is, <strong>ArraySize</strong> &gt; 6) require feature level <strong>D3D_FEATURE_LEVEL_10_1</strong> or higher.</p> </dd>
        /// </summary>
        /// <doc-id>ff476253</doc-id>
        /// <unmanaged>MiscFlags</unmanaged>
        /// <unmanaged-short>MiscFlags</unmanaged-short>
        public SharpDX.Direct3D11.ResourceOptionFlags OptionFlags;
    }

    /// <summary>
    /// <p>Describes a 2D texture.</p>
    /// </summary>
    /// <remarks>
    /// <p>This structure is used in a call to <strong>ID3D11Device3::CreateTexture2D1</strong>.</p><p>In addition to this structure, you can also use the <strong>CD3D11_TEXTURE2D_DESC1</strong> derived structure, which is defined  in D3D11_3.h and behaves like an inherited class, to help create a texture description.</p><p>The device places some size restrictions (must be multiples of a minimum size) for a subsampled, block compressed, or bit-format resource.</p><p>The texture size range is determined by the feature level at which you create the device and not the Microsoft Direct3D interface version. For example, if you use Microsoft Direct3D?10 hardware at feature level 10 (<strong>D3D_FEATURE_LEVEL_10_0</strong>) and call <strong>D3D11CreateDevice</strong> to create an <strong><see cref = "SharpDX.Direct3D11.Device"/></strong>, you must constrain the maximum texture size to D3D10_REQ_TEXTURE2D_U_OR_V_DIMENSION (8192) when you create your 2D texture.</p>
    /// </remarks>
    /// <doc-id>dn899166</doc-id>
    /// <unmanaged>D3D11_TEXTURE2D_DESC1</unmanaged>
    /// <unmanaged-short>D3D11_TEXTURE2D_DESC1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct Texture2DDescription1
    {
        /// <summary>
        /// <dd> <p>Texture width (in texels). The  range is from 1 to <see cref = "MaximumTexture2DSize"/> (16384). For a texture cube-map, the  range is from 1 to <see cref = "MaximumTextureCubeSize"/> (16384). However, the range is actually constrained by the feature level at which you create the rendering device. For more information about restrictions, see Remarks.</p> </dd>
        /// </summary>
        /// <doc-id>dn899166</doc-id>
        /// <unmanaged>Width</unmanaged>
        /// <unmanaged-short>Width</unmanaged-short>
        public System.Int32 Width;
        /// <summary>
        /// <dd> <p>Texture height (in texels). The  range is from 1 to <see cref = "MaximumTexture2DSize"/> (16384). For a texture cube-map, the  range is from 1 to <see cref = "MaximumTextureCubeSize"/> (16384). However, the range is actually constrained by the feature level at which you create the rendering device. For more information about restrictions, see Remarks.</p> </dd>
        /// </summary>
        /// <doc-id>dn899166</doc-id>
        /// <unmanaged>Height</unmanaged>
        /// <unmanaged-short>Height</unmanaged-short>
        public System.Int32 Height;
        /// <summary>
        /// <dd> <p>The maximum number of mipmap levels in the texture. See the remarks in <strong><see cref = "SharpDX.Direct3D11.Texture1DResource"/></strong>. Use 1 for a multisampled texture; or 0 to generate a full set of subtextures.</p> </dd>
        /// </summary>
        /// <doc-id>dn899166</doc-id>
        /// <unmanaged>MipLevels</unmanaged>
        /// <unmanaged-short>MipLevels</unmanaged-short>
        public System.Int32 MipLevels;
        /// <summary>
        /// <dd> <p>Number of textures in the texture array. The  range is from 1 to <see cref = "MaximumTexture2DArraySize"/> (2048). For a texture cube-map, this value is a multiple of 6 (that is, 6 times the value in the <strong>NumCubes</strong> member of <strong><see cref = "SharpDX.Direct3D11.TextureCubeArrayResource"/></strong>), and the  range is from 6 to 2046. The range is actually constrained by the feature level at which you create the rendering device. For more information about restrictions, see Remarks.</p> </dd>
        /// </summary>
        /// <doc-id>dn899166</doc-id>
        /// <unmanaged>ArraySize</unmanaged>
        /// <unmanaged-short>ArraySize</unmanaged-short>
        public System.Int32 ArraySize;
        /// <summary>
        /// <dd> <p>Texture format (see <strong><see cref = "SharpDX.DXGI.Format"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>dn899166</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p>Structure that specifies multisampling parameters for the texture. See <strong><see cref = "SharpDX.DXGI.SampleDescription"/></strong>.</p> </dd>
        /// </summary>
        /// <doc-id>dn899166</doc-id>
        /// <unmanaged>SampleDesc</unmanaged>
        /// <unmanaged-short>SampleDesc</unmanaged-short>
        public SharpDX.DXGI.SampleDescription SampleDescription;
        /// <summary>
        /// <dd> <p>Value that identifies how the texture is to be read from and written to. The most common value is D3D11_USAGE_DEFAULT; see <strong><see cref = "SharpDX.Direct3D11.ResourceUsage"/></strong> for all possible values.</p> </dd>
        /// </summary>
        /// <doc-id>dn899166</doc-id>
        /// <unmanaged>Usage</unmanaged>
        /// <unmanaged-short>Usage</unmanaged-short>
        public SharpDX.Direct3D11.ResourceUsage Usage;
        /// <summary>
        /// <dd> <p>Flags (see <strong><see cref = "SharpDX.Direct3D11.BindFlags"/></strong>) for binding to pipeline stages. The flags can be combined by a logical OR.</p> </dd>
        /// </summary>
        /// <doc-id>dn899166</doc-id>
        /// <unmanaged>BindFlags</unmanaged>
        /// <unmanaged-short>BindFlags</unmanaged-short>
        public SharpDX.Direct3D11.BindFlags BindFlags;
        /// <summary>
        /// <dd> <p>Flags (see <strong><see cref = "SharpDX.Direct3D11.CpuAccessFlags"/></strong>) to specify the types of CPU access allowed. Use 0 if CPU access is not required. These flags can be combined with a logical OR.</p> </dd>
        /// </summary>
        /// <doc-id>dn899166</doc-id>
        /// <unmanaged>CPUAccessFlags</unmanaged>
        /// <unmanaged-short>CPUAccessFlags</unmanaged-short>
        public SharpDX.Direct3D11.CpuAccessFlags CpuAccessFlags;
        /// <summary>
        /// <dd> <p>Flags (see <strong><see cref = "SharpDX.Direct3D11.ResourceOptionFlags"/></strong>) that identify other, less common resource options. Use 0 if none of these flags apply. These flags can be combined by using a logical OR. For a texture cube-map, set the <strong>D3D11_RESOURCE_MISC_TEXTURECUBE</strong> flag. Cube-map arrays (that is, <strong>ArraySize</strong> &gt; 6) require feature level <strong>D3D_FEATURE_LEVEL_10_1</strong> or higher.</p> </dd>
        /// </summary>
        /// <doc-id>dn899166</doc-id>
        /// <unmanaged>MiscFlags</unmanaged>
        /// <unmanaged-short>MiscFlags</unmanaged-short>
        public SharpDX.Direct3D11.ResourceOptionFlags OptionFlags;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.TextureLayout"/></strong>-typed value that identifies the layout of the texture.</p> <p>The TextureLayout parameter selects both the actual layout of the texture in memory and the layout visible to the application while the texture is mapped.  These flags may not be requested without CPU access also requested.</p> <p>It is illegal to set CPU access flags on default textures without also setting TextureLayout to a value other than D3D11_TEXTURE_LAYOUT_UNDEFINED.  </p> <p>D3D11_TEXTURE_LAYOUT_ROW_MAJOR may only be used to create non-multisampled, textures with a single subresource (Planar YUV textures are supported).  These textures may only be used as a source and destination of copy operations, and BindFlags must be zero.
        /// </p> <p>D3D11_TEXTURE_LAYOUT_64K_STANDARD_SWIZZLE may only be used to create non-multisampled, non-depth-stencil textures.  </p> </dd>
        /// </summary>
        /// <doc-id>dn899166</doc-id>
        /// <unmanaged>TextureLayout</unmanaged>
        /// <unmanaged-short>TextureLayout</unmanaged-short>
        public SharpDX.Direct3D11.TextureLayout TextureLayout;
    }

    /// <summary>
    /// <p>Identifies the texture resource for a video  decoder output view.</p>
    /// </summary>
    /// <doc-id>hh447633</doc-id>
    /// <unmanaged>D3D11_TEX2D_VDOV</unmanaged>
    /// <unmanaged-short>D3D11_TEX2D_VDOV</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct Texture2DVdov
    {
        /// <summary>
        /// <dd> <p>The zero-based index of the texture.</p> </dd>
        /// </summary>
        /// <doc-id>hh447633</doc-id>
        /// <unmanaged>ArraySlice</unmanaged>
        /// <unmanaged-short>ArraySlice</unmanaged-short>
        public System.Int32 ArraySlice;
    }

    /// <summary>
    /// <p>Identifies the texture resource for a video  processor input view.</p>
    /// </summary>
    /// <doc-id>hh447634</doc-id>
    /// <unmanaged>D3D11_TEX2D_VPIV</unmanaged>
    /// <unmanaged-short>D3D11_TEX2D_VPIV</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct Texture2DVpiv
    {
        /// <summary>
        /// <dd> <p>The zero-based index into the array of subtextures.</p> </dd>
        /// </summary>
        /// <doc-id>hh447634</doc-id>
        /// <unmanaged>MipSlice</unmanaged>
        /// <unmanaged-short>MipSlice</unmanaged-short>
        public System.Int32 MipSlice;
        /// <summary>
        /// <dd> <p>The zero-based index of the texture.</p> </dd>
        /// </summary>
        /// <doc-id>hh447634</doc-id>
        /// <unmanaged>ArraySlice</unmanaged>
        /// <unmanaged-short>ArraySlice</unmanaged-short>
        public System.Int32 ArraySlice;
    }

    /// <summary>
    /// <p>Identifies a texture resource for a video  processor output view.</p>
    /// </summary>
    /// <doc-id>hh447635</doc-id>
    /// <unmanaged>D3D11_TEX2D_VPOV</unmanaged>
    /// <unmanaged-short>D3D11_TEX2D_VPOV</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct Texture2DVpov
    {
        /// <summary>
        /// <dd> <p>The zero-based index into the array of subtextures.</p> </dd>
        /// </summary>
        /// <doc-id>hh447635</doc-id>
        /// <unmanaged>MipSlice</unmanaged>
        /// <unmanaged-short>MipSlice</unmanaged-short>
        public System.Int32 MipSlice;
    }

    /// <summary>
    /// <p>Describes a 3D texture.</p>
    /// </summary>
    /// <remarks>
    /// <p>This structure is used in a call to <strong>ID3D11Device::CreateTexture3D</strong>.</p><p>In addition to this structure, you can also use the <strong>CD3D11_TEXTURE3D_DESC</strong> derived structure, which is defined  in D3D11.h and behaves like an inherited class, to help create a texture description.</p><p>The device restricts the size of subsampled, block compressed, and bit format resources to be multiples of sizes specific to each format.</p><p>The texture size range is determined by the feature level at which you create the device and not the Microsoft Direct3D interface version. For example, if you use Microsoft Direct3D?10 hardware at feature level 10 (<strong>D3D_FEATURE_LEVEL_10_0</strong>) and call <strong>D3D11CreateDevice</strong> to create an <strong><see cref = "SharpDX.Direct3D11.Device"/></strong>, you must constrain the maximum texture size to D3D10_REQ_TEXTURE3D_U_V_OR_W_DIMENSION (2048) when you create your 3D texture.</p>
    /// </remarks>
    /// <doc-id>ff476254</doc-id>
    /// <unmanaged>D3D11_TEXTURE3D_DESC</unmanaged>
    /// <unmanaged-short>D3D11_TEXTURE3D_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct Texture3DDescription
    {
        /// <summary>
        /// <dd> <p>Texture width (in texels). The  range is from 1 to <see cref = "MaximumTexture3DSize"/> (2048). However, the range is actually constrained by the feature level at which you create the rendering device. For more information about restrictions, see Remarks.</p> </dd>
        /// </summary>
        /// <doc-id>ff476254</doc-id>
        /// <unmanaged>Width</unmanaged>
        /// <unmanaged-short>Width</unmanaged-short>
        public System.Int32 Width;
        /// <summary>
        /// <dd> <p>Texture height (in texels). The  range is from 1 to <see cref = "MaximumTexture3DSize"/> (2048). However, the range is actually constrained by the feature level at which you create the rendering device. For more information about restrictions, see Remarks.</p> </dd>
        /// </summary>
        /// <doc-id>ff476254</doc-id>
        /// <unmanaged>Height</unmanaged>
        /// <unmanaged-short>Height</unmanaged-short>
        public System.Int32 Height;
        /// <summary>
        /// <dd> <p>Texture depth (in texels). The  range is from 1 to <see cref = "MaximumTexture3DSize"/> (2048). However, the range is actually constrained by the feature level at which you create the rendering device. For more information about restrictions, see Remarks.</p> </dd>
        /// </summary>
        /// <doc-id>ff476254</doc-id>
        /// <unmanaged>Depth</unmanaged>
        /// <unmanaged-short>Depth</unmanaged-short>
        public System.Int32 Depth;
        /// <summary>
        /// <dd> <p>The maximum number of mipmap levels in the texture. See the remarks in <strong><see cref = "SharpDX.Direct3D11.Texture1DResource"/></strong>. Use 1 for a multisampled texture; or 0 to generate a full set of subtextures.</p> </dd>
        /// </summary>
        /// <doc-id>ff476254</doc-id>
        /// <unmanaged>MipLevels</unmanaged>
        /// <unmanaged-short>MipLevels</unmanaged-short>
        public System.Int32 MipLevels;
        /// <summary>
        /// <dd> <p>Texture format (see <strong><see cref = "SharpDX.DXGI.Format"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476254</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p>Value that identifies how the texture is to be read from and written to. The most common value is D3D11_USAGE_DEFAULT; see <strong><see cref = "SharpDX.Direct3D11.ResourceUsage"/></strong> for all possible values.</p> </dd>
        /// </summary>
        /// <doc-id>ff476254</doc-id>
        /// <unmanaged>Usage</unmanaged>
        /// <unmanaged-short>Usage</unmanaged-short>
        public SharpDX.Direct3D11.ResourceUsage Usage;
        /// <summary>
        /// <dd> <p>Flags (see <strong><see cref = "SharpDX.Direct3D11.BindFlags"/></strong>) for binding to pipeline stages. The flags can be combined by a logical OR.</p> </dd>
        /// </summary>
        /// <doc-id>ff476254</doc-id>
        /// <unmanaged>BindFlags</unmanaged>
        /// <unmanaged-short>BindFlags</unmanaged-short>
        public SharpDX.Direct3D11.BindFlags BindFlags;
        /// <summary>
        /// <dd> <p>Flags (see <strong><see cref = "SharpDX.Direct3D11.CpuAccessFlags"/></strong>) to specify the types of CPU access allowed. Use 0 if CPU access is not required. These flags can be combined with a logical OR.</p> </dd>
        /// </summary>
        /// <doc-id>ff476254</doc-id>
        /// <unmanaged>CPUAccessFlags</unmanaged>
        /// <unmanaged-short>CPUAccessFlags</unmanaged-short>
        public SharpDX.Direct3D11.CpuAccessFlags CpuAccessFlags;
        /// <summary>
        /// <dd> <p>Flags (see <strong><see cref = "SharpDX.Direct3D11.ResourceOptionFlags"/></strong>) that identify other, less common resource options. Use 0 if none of these flags apply. These flags can be combined with a logical OR.</p> </dd>
        /// </summary>
        /// <doc-id>ff476254</doc-id>
        /// <unmanaged>MiscFlags</unmanaged>
        /// <unmanaged-short>MiscFlags</unmanaged-short>
        public SharpDX.Direct3D11.ResourceOptionFlags OptionFlags;
    }

    /// <summary>
    /// <p>Describes a 3D texture.</p>
    /// </summary>
    /// <remarks>
    /// <p>This structure is used in a call to <strong>ID3D11Device3::CreateTexture3D1</strong>.</p><p>In addition to this structure, you can also use the <strong>CD3D11_TEXTURE3D_DESC1</strong> derived structure, which is defined  in D3D11_3.h and behaves like an inherited class, to help create a texture description.</p><p>The device restricts the size of subsampled, block compressed, and bit format resources to be multiples of sizes specific to each format.</p><p>The texture size range is determined by the feature level at which you create the device and not the Microsoft Direct3D interface version. For example, if you use Microsoft Direct3D?10 hardware at feature level 10 (<strong>D3D_FEATURE_LEVEL_10_0</strong>) and call <strong>D3D11CreateDevice</strong> to create an <strong><see cref = "SharpDX.Direct3D11.Device"/></strong>, you must constrain the maximum texture size to D3D10_REQ_TEXTURE3D_U_V_OR_W_DIMENSION (2048) when you create your 3D texture.</p>
    /// </remarks>
    /// <doc-id>dn899167</doc-id>
    /// <unmanaged>D3D11_TEXTURE3D_DESC1</unmanaged>
    /// <unmanaged-short>D3D11_TEXTURE3D_DESC1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct Texture3DDescription1
    {
        /// <summary>
        /// <dd> <p>Texture width (in texels). The  range is from 1 to <see cref = "MaximumTexture3DSize"/> (2048). However, the range is actually constrained by the feature level at which you create the rendering device. For more information about restrictions, see Remarks.</p> </dd>
        /// </summary>
        /// <doc-id>dn899167</doc-id>
        /// <unmanaged>Width</unmanaged>
        /// <unmanaged-short>Width</unmanaged-short>
        public System.Int32 Width;
        /// <summary>
        /// <dd> <p>Texture height (in texels). The  range is from 1 to <see cref = "MaximumTexture3DSize"/> (2048). However, the range is actually constrained by the feature level at which you create the rendering device. For more information about restrictions, see Remarks.</p> </dd>
        /// </summary>
        /// <doc-id>dn899167</doc-id>
        /// <unmanaged>Height</unmanaged>
        /// <unmanaged-short>Height</unmanaged-short>
        public System.Int32 Height;
        /// <summary>
        /// <dd> <p>Texture depth (in texels). The  range is from 1 to <see cref = "MaximumTexture3DSize"/> (2048). However, the range is actually constrained by the feature level at which you create the rendering device. For more information about restrictions, see Remarks.</p> </dd>
        /// </summary>
        /// <doc-id>dn899167</doc-id>
        /// <unmanaged>Depth</unmanaged>
        /// <unmanaged-short>Depth</unmanaged-short>
        public System.Int32 Depth;
        /// <summary>
        /// <dd> <p>The maximum number of mipmap levels in the texture. See the remarks in <strong><see cref = "SharpDX.Direct3D11.Texture1DResource"/></strong>. Use 1 for a multisampled texture; or 0 to generate a full set of subtextures.</p> </dd>
        /// </summary>
        /// <doc-id>dn899167</doc-id>
        /// <unmanaged>MipLevels</unmanaged>
        /// <unmanaged-short>MipLevels</unmanaged-short>
        public System.Int32 MipLevels;
        /// <summary>
        /// <dd> <p>Texture format (see <strong><see cref = "SharpDX.DXGI.Format"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>dn899167</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p>Value that identifies how the texture is to be read from and written to. The most common value is D3D11_USAGE_DEFAULT; see <strong><see cref = "SharpDX.Direct3D11.ResourceUsage"/></strong> for all possible values.</p> </dd>
        /// </summary>
        /// <doc-id>dn899167</doc-id>
        /// <unmanaged>Usage</unmanaged>
        /// <unmanaged-short>Usage</unmanaged-short>
        public SharpDX.Direct3D11.ResourceUsage Usage;
        /// <summary>
        /// <dd> <p>Flags (see <strong><see cref = "SharpDX.Direct3D11.BindFlags"/></strong>) for binding to pipeline stages. The flags can be combined by a logical OR.</p> </dd>
        /// </summary>
        /// <doc-id>dn899167</doc-id>
        /// <unmanaged>BindFlags</unmanaged>
        /// <unmanaged-short>BindFlags</unmanaged-short>
        public SharpDX.Direct3D11.BindFlags BindFlags;
        /// <summary>
        /// <dd> <p>Flags (see <strong><see cref = "SharpDX.Direct3D11.CpuAccessFlags"/></strong>) to specify the types of CPU access allowed. Use 0 if CPU access is not required. These flags can be combined with a logical OR.</p> </dd>
        /// </summary>
        /// <doc-id>dn899167</doc-id>
        /// <unmanaged>CPUAccessFlags</unmanaged>
        /// <unmanaged-short>CPUAccessFlags</unmanaged-short>
        public SharpDX.Direct3D11.CpuAccessFlags CpuAccessFlags;
        /// <summary>
        /// <dd> <p>Flags (see <strong><see cref = "SharpDX.Direct3D11.ResourceOptionFlags"/></strong>) that identify other, less common resource options. Use 0 if none of these flags apply. These flags can be combined with a logical OR.</p> </dd>
        /// </summary>
        /// <doc-id>dn899167</doc-id>
        /// <unmanaged>MiscFlags</unmanaged>
        /// <unmanaged-short>MiscFlags</unmanaged-short>
        public SharpDX.Direct3D11.ResourceOptionFlags OptionFlags;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.TextureLayout"/></strong>-typed value that identifies the layout of the texture.</p> <p>The TextureLayout parameter selects both the actual layout of the texture in memory and the layout visible to the application while the texture is mapped.  These flags may not be requested without CPU access also requested.</p> <p>It is illegal to set CPU access flags on default textures without also setting Layout to a value other than D3D11_TEXTURE_LAYOUT_UNDEFINED.</p> <p>D3D11_TEXTURE_LAYOUT_ROW_MAJOR may not be used with 3D textures.  D3D11_TEXTURE_LAYOUT_64K_STANDARD_SWIZZLE may not be used with 3D textures that have mipmaps.</p> </dd>
        /// </summary>
        /// <doc-id>dn899167</doc-id>
        /// <unmanaged>TextureLayout</unmanaged>
        /// <unmanaged-short>TextureLayout</unmanaged-short>
        public SharpDX.Direct3D11.TextureLayout TextureLayout;
    }

    /// <summary>
    /// <p>Describes the coordinates of a tiled resource.</p>
    /// </summary>
    /// <doc-id>dn280437</doc-id>
    /// <unmanaged>D3D11_TILED_RESOURCE_COORDINATE</unmanaged>
    /// <unmanaged-short>D3D11_TILED_RESOURCE_COORDINATE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct TiledResourceCoordinate
    {
        /// <summary>
        /// <dd> <p>The x position of a tiled resource. Used for buffer and 1D, 2D, and 3D textures.</p> </dd>
        /// </summary>
        /// <doc-id>dn280437</doc-id>
        /// <unmanaged>X</unmanaged>
        /// <unmanaged-short>X</unmanaged-short>
        public System.Int32 X;
        /// <summary>
        /// <dd> <p>The y position of a tiled resource. Used for 2D and 3D textures.</p> </dd>
        /// </summary>
        /// <doc-id>dn280437</doc-id>
        /// <unmanaged>Y</unmanaged>
        /// <unmanaged-short>Y</unmanaged-short>
        public System.Int32 Y;
        /// <summary>
        /// <dd> <p>The z position of a tiled resource. Used for 3D textures.</p> </dd>
        /// </summary>
        /// <doc-id>dn280437</doc-id>
        /// <unmanaged>Z</unmanaged>
        /// <unmanaged-short>Z</unmanaged-short>
        public System.Int32 Z;
        /// <summary>
        /// <dd> <p>A subresource index value into mipmaps and arrays. Used for 1D, 2D, and 3D textures. </p> <p>For mipmaps that use nonstandard tiling, or are packed, or both use nonstandard tiling and are packed, any subresource value that indicates any of the packed mipmaps all refer to the same tile.</p> </dd>
        /// </summary>
        /// <doc-id>dn280437</doc-id>
        /// <unmanaged>Subresource</unmanaged>
        /// <unmanaged-short>Subresource</unmanaged-short>
        public System.Int32 Subresource;
    }

    /// <summary>
    /// <p>Describes the size of a tiled region.</p>
    /// </summary>
    /// <doc-id>dn280442</doc-id>
    /// <unmanaged>D3D11_TILE_REGION_SIZE</unmanaged>
    /// <unmanaged-short>D3D11_TILE_REGION_SIZE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct TileRegionSize
    {
        /// <summary>
        /// <dd> <p>The number of tiles in the tiled region.</p> </dd>
        /// </summary>
        /// <doc-id>dn280442</doc-id>
        /// <unmanaged>NumTiles</unmanaged>
        /// <unmanaged-short>NumTiles</unmanaged-short>
        public System.Int32 TileCount;
        /// <summary>
        /// <dd> <p>Specifies whether the runtime uses the <strong>Width</strong>, <strong>Height</strong>, and <strong>Depth</strong> members to define the region. </p> <p>If <strong>TRUE</strong>, the runtime uses the <strong>Width</strong>, <strong>Height</strong>, and <strong>Depth</strong> members to define the region. </p> <p>If <strong><see cref = "SharpDX.Result.False"/></strong>, the runtime ignores the <strong>Width</strong>, <strong>Height</strong>, and <strong>Depth</strong> members and uses the <strong>NumTiles</strong> member to traverse tiles in the resource linearly across x, then y, then z (as applicable) and then spills over mipmaps/arrays in subresource order.  For example, use this technique to map an entire resource at once.</p> <p>Regardless of whether you specify <strong>TRUE</strong> or <strong><see cref = "SharpDX.Result.False"/></strong> for <strong>bUseBox</strong>, you use a <strong><see cref = "SharpDX.Direct3D11.TiledResourceCoordinate"/></strong> structure to specify the starting location for the region within the resource as a separate parameter outside of this structure by using x, y, and z coordinates. </p> <p>When the region includes mipmaps that are packed with nonstandard tiling, <strong>bUseBox</strong> must be <strong><see cref = "SharpDX.Result.False"/></strong> because tile dimensions are not standard and the app only knows a count of how many tiles are consumed by the packed area, which is per array slice.  The corresponding (separate) starting location parameter uses x to offset into the flat range of tiles in this case, and y and z coordinates must each be 0.</p> </dd>
        /// </summary>
        /// <doc-id>dn280442</doc-id>
        /// <unmanaged>bUseBox</unmanaged>
        /// <unmanaged-short>bUseBox</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool BUseBox;
        /// <summary>
        /// <dd> <p>The width of the tiled region, in tiles. Used for buffer and 1D, 2D, and 3D textures. </p> </dd>
        /// </summary>
        /// <doc-id>dn280442</doc-id>
        /// <unmanaged>Width</unmanaged>
        /// <unmanaged-short>Width</unmanaged-short>
        public System.Int32 Width;
        /// <summary>
        /// <dd> <p>The height of the tiled region, in tiles. Used for 2D and 3D textures. </p> </dd>
        /// </summary>
        /// <doc-id>dn280442</doc-id>
        /// <unmanaged>Height</unmanaged>
        /// <unmanaged-short>Height</unmanaged-short>
        public System.Int16 Height;
        /// <summary>
        /// <dd> <p>The depth of the tiled region, in tiles. Used for 3D textures or arrays. For arrays, used for advancing in depth jumps to next slice of same mipmap size, which isn't contiguous in the subresource counting space if there are multiple mipmaps.</p> </dd>
        /// </summary>
        /// <doc-id>dn280442</doc-id>
        /// <unmanaged>Depth</unmanaged>
        /// <unmanaged-short>Depth</unmanaged-short>
        public System.Int16 Depth;
    }

    /// <summary>
    /// <p>Describes the shape of a tile by specifying its dimensions.</p>
    /// </summary>
    /// <remarks>
    /// <p>Texels are equivalent to pixels.  For untyped buffer resources, a texel is just a byte. For multisample antialiasing (MSAA) surfaces, the numbers are still in terms of pixels/texels.
    /// The values here are independent of the surface dimensions.  Even if the surface is smaller than what would fit in a tile, the full tile dimensions are reported here.
    /// </p>
    /// </remarks>
    /// <doc-id>dn280443</doc-id>
    /// <unmanaged>D3D11_TILE_SHAPE</unmanaged>
    /// <unmanaged-short>D3D11_TILE_SHAPE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct TileShape
    {
        /// <summary>
        /// <dd> <p>The width in texels of the tile.</p> </dd>
        /// </summary>
        /// <doc-id>dn280443</doc-id>
        /// <unmanaged>WidthInTexels</unmanaged>
        /// <unmanaged-short>WidthInTexels</unmanaged-short>
        public System.Int32 WidthInTexels;
        /// <summary>
        /// <dd> <p>The height in texels of the tile.</p> </dd>
        /// </summary>
        /// <doc-id>dn280443</doc-id>
        /// <unmanaged>HeightInTexels</unmanaged>
        /// <unmanaged-short>HeightInTexels</unmanaged-short>
        public System.Int32 HeightInTexels;
        /// <summary>
        /// <dd> <p>The depth in texels of the tile.</p> </dd>
        /// </summary>
        /// <doc-id>dn280443</doc-id>
        /// <unmanaged>DepthInTexels</unmanaged>
        /// <unmanaged-short>DepthInTexels</unmanaged-short>
        public System.Int32 DepthInTexels;
    }

    /// <summary>
    /// <p>Specifies the subresources from a resource that are accessible using an unordered-access view.</p>
    /// </summary>
    /// <remarks>
    /// <p>An unordered-access-view description is passed into <strong>ID3D11Device::CreateUnorderedAccessView</strong> to create a view.</p>
    /// </remarks>
    /// <doc-id>ff476258</doc-id>
    /// <unmanaged>D3D11_UNORDERED_ACCESS_VIEW_DESC</unmanaged>
    /// <unmanaged-short>D3D11_UNORDERED_ACCESS_VIEW_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct UnorderedAccessViewDescription
    {
        /// <summary>
        /// <p>Describes the elements in a buffer to use in a unordered-access view.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is used by a <strong><see cref = "SharpDX.Direct3D11.UnorderedAccessViewDescription"/></strong>.</p>
        /// </remarks>
        /// <doc-id>ff476095</doc-id>
        /// <unmanaged>D3D11_BUFFER_UAV</unmanaged>
        /// <unmanaged-short>D3D11_BUFFER_UAV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct BufferResource
        {
            /// <summary>
            /// <dd> <p>The zero-based index of the first element to be accessed.</p> </dd>
            /// </summary>
            /// <doc-id>ff476095</doc-id>
            /// <unmanaged>FirstElement</unmanaged>
            /// <unmanaged-short>FirstElement</unmanaged-short>
            public System.Int32 FirstElement;
            /// <summary>
            /// <dd> <p>The number of elements in the resource. For structured buffers, this is the number of structures in the buffer.</p> </dd>
            /// </summary>
            /// <doc-id>ff476095</doc-id>
            /// <unmanaged>NumElements</unmanaged>
            /// <unmanaged-short>NumElements</unmanaged-short>
            public System.Int32 ElementCount;
            /// <summary>
            /// <dd> <p>View options for the resource (see <strong><see cref = "SharpDX.Direct3D11.UnorderedAccessViewBufferFlags"/></strong>).</p> </dd>
            /// </summary>
            /// <doc-id>ff476095</doc-id>
            /// <unmanaged>Flags</unmanaged>
            /// <unmanaged-short>Flags</unmanaged-short>
            public SharpDX.Direct3D11.UnorderedAccessViewBufferFlags Flags;
        }

        /// <summary>
        /// <p>Describes a unordered-access 1D texture resource.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is used by a <strong><see cref = "SharpDX.Direct3D11.UnorderedAccessViewDescription"/></strong>.</p>
        /// </remarks>
        /// <doc-id>ff476232</doc-id>
        /// <unmanaged>D3D11_TEX1D_UAV</unmanaged>
        /// <unmanaged-short>D3D11_TEX1D_UAV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture1DResource
        {
            /// <summary>
            /// <dd> <p>The mipmap slice index.</p> </dd>
            /// </summary>
            /// <doc-id>ff476232</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
        }

        /// <summary>
        /// <p>Describes an array of unordered-access 1D texture resources.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is used by a <strong><see cref = "SharpDX.Direct3D11.UnorderedAccessViewDescription"/></strong>.</p>
        /// </remarks>
        /// <doc-id>ff476228</doc-id>
        /// <unmanaged>D3D11_TEX1D_ARRAY_UAV</unmanaged>
        /// <unmanaged-short>D3D11_TEX1D_ARRAY_UAV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture1DArrayResource
        {
            /// <summary>
            /// <dd> <p>The mipmap slice index.</p> </dd>
            /// </summary>
            /// <doc-id>ff476228</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
            /// <summary>
            /// <dd> <p>The zero-based index of the first array slice to be accessed.</p> </dd>
            /// </summary>
            /// <doc-id>ff476228</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p>The number of slices in the array.</p> </dd>
            /// </summary>
            /// <doc-id>ff476228</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
        }

        /// <summary>
        /// <p>Describes a unordered-access 2D texture resource.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is used by a <strong><see cref = "SharpDX.Direct3D11.UnorderedAccessViewDescription"/></strong>.</p>
        /// </remarks>
        /// <doc-id>ff476246</doc-id>
        /// <unmanaged>D3D11_TEX2D_UAV</unmanaged>
        /// <unmanaged-short>D3D11_TEX2D_UAV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DResource
        {
            /// <summary>
            /// <dd> <p>The mipmap slice index.</p> </dd>
            /// </summary>
            /// <doc-id>ff476246</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
        }

        /// <summary>
        /// <p>Describes an array of unordered-access 2D texture resources.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is used by a <strong><see cref = "SharpDX.Direct3D11.UnorderedAccessViewDescription"/></strong>.</p>
        /// </remarks>
        /// <doc-id>ff476242</doc-id>
        /// <unmanaged>D3D11_TEX2D_ARRAY_UAV</unmanaged>
        /// <unmanaged-short>D3D11_TEX2D_ARRAY_UAV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DArrayResource
        {
            /// <summary>
            /// <dd> <p>The mipmap slice index.</p> </dd>
            /// </summary>
            /// <doc-id>ff476242</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
            /// <summary>
            /// <dd> <p>The zero-based index of the first array slice to be accessed.</p> </dd>
            /// </summary>
            /// <doc-id>ff476242</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p>The number of slices in the array.</p> </dd>
            /// </summary>
            /// <doc-id>ff476242</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
        }

        /// <summary>
        /// <p>Describes a unordered-access 3D texture resource.</p>
        /// </summary>
        /// <remarks>
        /// <p>This structure is used by a <strong><see cref = "SharpDX.Direct3D11.UnorderedAccessViewDescription"/></strong>.</p>
        /// </remarks>
        /// <doc-id>ff476249</doc-id>
        /// <unmanaged>D3D11_TEX3D_UAV</unmanaged>
        /// <unmanaged-short>D3D11_TEX3D_UAV</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture3DResource
        {
            /// <summary>
            /// <dd> <p>The mipmap slice index.</p> </dd>
            /// </summary>
            /// <doc-id>ff476249</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
            /// <summary>
            /// <dd> <p>The zero-based index of the first depth slice to be accessed.</p> </dd>
            /// </summary>
            /// <doc-id>ff476249</doc-id>
            /// <unmanaged>FirstWSlice</unmanaged>
            /// <unmanaged-short>FirstWSlice</unmanaged-short>
            public System.Int32 FirstWSlice;
            /// <summary>
            /// <dd> <p>The number of depth slices.</p> </dd>
            /// </summary>
            /// <doc-id>ff476249</doc-id>
            /// <unmanaged>WSize</unmanaged>
            /// <unmanaged-short>WSize</unmanaged-short>
            public System.Int32 WSize;
        }

        /// <summary>
        /// <dd> <p>The data format (see <strong><see cref = "SharpDX.DXGI.Format"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476258</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p>The resource type (see <strong><see cref = "SharpDX.Direct3D11.UnorderedAccessViewDimension"/></strong>), which specifies how the resource will be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>ff476258</doc-id>
        /// <unmanaged>ViewDimension</unmanaged>
        /// <unmanaged-short>ViewDimension</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(4)]
        public SharpDX.Direct3D11.UnorderedAccessViewDimension Dimension;
        /// <summary>
        /// <dd> <p>Specifies which buffer elements can be accessed (see <strong><see cref = "SharpDX.Direct3D11.BufferResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476258</doc-id>
        /// <unmanaged>Buffer</unmanaged>
        /// <unmanaged-short>Buffer</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.UnorderedAccessViewDescription.BufferResource Buffer;
        /// <summary>
        /// <dd> <p>Specifies the subresources in a 1D texture that can be accessed (see <strong><see cref = "SharpDX.Direct3D11.Texture1DResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476258</doc-id>
        /// <unmanaged>Texture1D</unmanaged>
        /// <unmanaged-short>Texture1D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.UnorderedAccessViewDescription.Texture1DResource Texture1D;
        /// <summary>
        /// <dd> <p>Specifies the subresources in a 1D texture array that can be accessed (see <strong><see cref = "SharpDX.Direct3D11.Texture1DArrayResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476258</doc-id>
        /// <unmanaged>Texture1DArray</unmanaged>
        /// <unmanaged-short>Texture1DArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.UnorderedAccessViewDescription.Texture1DArrayResource Texture1DArray;
        /// <summary>
        /// <dd> <p>Specifies the subresources in a 2D texture that can be accessed (see <strong><see cref = "SharpDX.Direct3D11.Texture2DResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476258</doc-id>
        /// <unmanaged>Texture2D</unmanaged>
        /// <unmanaged-short>Texture2D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.UnorderedAccessViewDescription.Texture2DResource Texture2D;
        /// <summary>
        /// <dd> <p>Specifies the subresources in a 2D texture array that can be accessed (see <strong><see cref = "SharpDX.Direct3D11.Texture2DArrayResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476258</doc-id>
        /// <unmanaged>Texture2DArray</unmanaged>
        /// <unmanaged-short>Texture2DArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.UnorderedAccessViewDescription.Texture2DArrayResource Texture2DArray;
        /// <summary>
        /// <dd> <p>Specifies subresources in a 3D texture that can be accessed (see <strong><see cref = "SharpDX.Direct3D11.Texture3DResource"/></strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476258</doc-id>
        /// <unmanaged>Texture3D</unmanaged>
        /// <unmanaged-short>Texture3D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.UnorderedAccessViewDescription.Texture3DResource Texture3D;
    }

    /// <summary>
    /// <p>Describes the subresources from a resource that are accessible using an unordered-access view.</p>
    /// </summary>
    /// <remarks>
    /// <p>An unordered-access-view description is passed into <strong>ID3D11Device3::CreateUnorderedAccessView1</strong> to create a view.</p>
    /// </remarks>
    /// <doc-id>dn899203</doc-id>
    /// <unmanaged>D3D11_UNORDERED_ACCESS_VIEW_DESC1</unmanaged>
    /// <unmanaged-short>D3D11_UNORDERED_ACCESS_VIEW_DESC1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct UnorderedAccessViewDescription1
    {
        /// <summary>
        /// <p>Describes a unordered-access 2D texture resource.</p>
        /// </summary>
        /// <doc-id>dn899165</doc-id>
        /// <unmanaged>D3D11_TEX2D_UAV1</unmanaged>
        /// <unmanaged-short>D3D11_TEX2D_UAV1</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DResource
        {
            /// <summary>
            /// <dd> <p>The mipmap slice index.</p> </dd>
            /// </summary>
            /// <doc-id>dn899165</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
            /// <summary>
            /// <dd> <p>The index (plane slice number) of the plane to use in the texture.</p> </dd>
            /// </summary>
            /// <doc-id>dn899165</doc-id>
            /// <unmanaged>PlaneSlice</unmanaged>
            /// <unmanaged-short>PlaneSlice</unmanaged-short>
            public System.Int32 PlaneSlice;
        }

        /// <summary>
        /// <p>Describes an array of unordered-access 2D texture resources.</p>
        /// </summary>
        /// <doc-id>dn899162</doc-id>
        /// <unmanaged>D3D11_TEX2D_ARRAY_UAV1</unmanaged>
        /// <unmanaged-short>D3D11_TEX2D_ARRAY_UAV1</unmanaged-short>
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        public partial struct Texture2DArrayResource
        {
            /// <summary>
            /// <dd> <p>The mipmap slice index.</p> </dd>
            /// </summary>
            /// <doc-id>dn899162</doc-id>
            /// <unmanaged>MipSlice</unmanaged>
            /// <unmanaged-short>MipSlice</unmanaged-short>
            public System.Int32 MipSlice;
            /// <summary>
            /// <dd> <p>The zero-based index of the first array slice to be accessed.</p> </dd>
            /// </summary>
            /// <doc-id>dn899162</doc-id>
            /// <unmanaged>FirstArraySlice</unmanaged>
            /// <unmanaged-short>FirstArraySlice</unmanaged-short>
            public System.Int32 FirstArraySlice;
            /// <summary>
            /// <dd> <p>The number of slices in the array.</p> </dd>
            /// </summary>
            /// <doc-id>dn899162</doc-id>
            /// <unmanaged>ArraySize</unmanaged>
            /// <unmanaged-short>ArraySize</unmanaged-short>
            public System.Int32 ArraySize;
            /// <summary>
            /// <dd> <p>The index (plane slice number) of the plane to use in an array of textures.</p> </dd>
            /// </summary>
            /// <doc-id>dn899162</doc-id>
            /// <unmanaged>PlaneSlice</unmanaged>
            /// <unmanaged-short>PlaneSlice</unmanaged-short>
            public System.Int32 PlaneSlice;
        }

        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.DXGI.Format"/></strong>-typed value that specifies the data format.</p> </dd>
        /// </summary>
        /// <doc-id>dn899203</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.UnorderedAccessViewDimension"/></strong>-typed value that  specifies the resource type of the view. This type is the same as the resource type of the underlying resource. This member also determines which _UAV to use in the union below.</p> </dd>
        /// </summary>
        /// <doc-id>dn899203</doc-id>
        /// <unmanaged>ViewDimension</unmanaged>
        /// <unmanaged-short>ViewDimension</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(4)]
        public SharpDX.Direct3D11.UnorderedAccessViewDimension Dimension;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.BufferResource"/></strong> structure that specifies which buffer elements can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn899203</doc-id>
        /// <unmanaged>Buffer</unmanaged>
        /// <unmanaged-short>Buffer</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.UnorderedAccessViewDescription.BufferResource Buffer;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.Texture1DResource"/></strong> structure that specifies the subresources in a 1D texture that can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn899203</doc-id>
        /// <unmanaged>Texture1D</unmanaged>
        /// <unmanaged-short>Texture1D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.UnorderedAccessViewDescription.Texture1DResource Texture1D;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.Texture1DArrayResource"/></strong> structure that specifies the subresources in a 1D texture array that can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn899203</doc-id>
        /// <unmanaged>Texture1DArray</unmanaged>
        /// <unmanaged-short>Texture1DArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.UnorderedAccessViewDescription.Texture1DArrayResource Texture1DArray;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.Texture2DResource"/></strong> structure that specifies the subresources in a 2D texture that can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn899203</doc-id>
        /// <unmanaged>Texture2D</unmanaged>
        /// <unmanaged-short>Texture2D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.UnorderedAccessViewDescription1.Texture2DResource Texture2D;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.Texture2DArrayResource"/></strong> structure that specifies the subresources in a 2D texture array that can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn899203</doc-id>
        /// <unmanaged>Texture2DArray</unmanaged>
        /// <unmanaged-short>Texture2DArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.UnorderedAccessViewDescription1.Texture2DArrayResource Texture2DArray;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.Texture3DResource"/></strong> structure that specifies subresources in a 3D texture that can be accessed.</p> </dd>
        /// </summary>
        /// <doc-id>dn899203</doc-id>
        /// <unmanaged>Texture3D</unmanaged>
        /// <unmanaged-short>Texture3D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(8)]
        public SharpDX.Direct3D11.UnorderedAccessViewDescription.Texture3DResource Texture3D;
    }

    /// <summary>
    /// <p>Defines a color value for Microsoft Direct3D?11 video.</p>
    /// </summary>
    /// <remarks>
    /// <p>The anonymous union can represent both RGB and YCbCr colors. The interpretation of the union depends on the context. </p>
    /// </remarks>
    /// <doc-id>hh447637</doc-id>
    /// <unmanaged>D3D11_VIDEO_COLOR</unmanaged>
    /// <unmanaged-short>D3D11_VIDEO_COLOR</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoColor
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.VideoColorYCbCrA"/></strong> structure that contains a YCbCr color value. </p> </dd>
        /// </summary>
        /// <doc-id>hh447637</doc-id>
        /// <unmanaged>YCbCr</unmanaged>
        /// <unmanaged-short>YCbCr</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public SharpDX.Direct3D11.VideoColorYCbCrA YCbCr;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.VideoColorRgba"/></strong> structure that contains an RGB color value. </p> </dd>
        /// </summary>
        /// <doc-id>hh447637</doc-id>
        /// <unmanaged>RGBA</unmanaged>
        /// <unmanaged-short>RGBA</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public SharpDX.Direct3D11.VideoColorRgba Rgba;
    }

    /// <summary>
    /// <p>Specifies an RGB color value. </p>
    /// </summary>
    /// <remarks>
    /// <p>The RGB values have a nominal range of [0...1]. For an RGB format with  <em>n</em> bits per channel, the value of each color component is calculated as follows:</p><p><code>val = f * ((1 &lt; &lt; n)-1)</code></p><p>For example, for RGB-32 (8 bits per channel), <code>val = BYTE(f * 255.0)</code>.</p>
    /// </remarks>
    /// <doc-id>hh447638</doc-id>
    /// <unmanaged>D3D11_VIDEO_COLOR_RGBA</unmanaged>
    /// <unmanaged-short>D3D11_VIDEO_COLOR_RGBA</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoColorRgba
    {
        /// <summary>
        /// <dd> <p>The red value.</p> </dd>
        /// </summary>
        /// <doc-id>hh447638</doc-id>
        /// <unmanaged>R</unmanaged>
        /// <unmanaged-short>R</unmanaged-short>
        public System.Single R;
        /// <summary>
        /// <dd> <p>The green value.</p> </dd>
        /// </summary>
        /// <doc-id>hh447638</doc-id>
        /// <unmanaged>G</unmanaged>
        /// <unmanaged-short>G</unmanaged-short>
        public System.Single G;
        /// <summary>
        /// <dd> <p>The blue value.</p> </dd>
        /// </summary>
        /// <doc-id>hh447638</doc-id>
        /// <unmanaged>B</unmanaged>
        /// <unmanaged-short>B</unmanaged-short>
        public System.Single B;
        /// <summary>
        /// <dd> <p>The alpha value. Values range from 0 (transparent) to 1 (opaque).
        /// </p> </dd>
        /// </summary>
        /// <doc-id>hh447638</doc-id>
        /// <unmanaged>A</unmanaged>
        /// <unmanaged-short>A</unmanaged-short>
        public System.Single A;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D11_VIDEO_COLOR_YCbCrA</unmanaged>
    /// <unmanaged-short>D3D11_VIDEO_COLOR_YCbCrA</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoColorYCbCrA
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Y</unmanaged>
        /// <unmanaged-short>Y</unmanaged-short>
        public System.Single Y;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Cb</unmanaged>
        /// <unmanaged-short>Cb</unmanaged-short>
        public System.Single Cb;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>Cr</unmanaged>
        /// <unmanaged-short>Cr</unmanaged-short>
        public System.Single Cr;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>A</unmanaged>
        /// <unmanaged-short>A</unmanaged-short>
        public System.Single A;
    }

    /// <summary>
    /// <p>Describes the content-protection capabilities of a graphics driver.</p>
    /// </summary>
    /// <doc-id>hh447640</doc-id>
    /// <unmanaged>D3D11_VIDEO_CONTENT_PROTECTION_CAPS</unmanaged>
    /// <unmanaged-short>D3D11_VIDEO_CONTENT_PROTECTION_CAPS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoContentProtectionCaps
    {
        /// <summary>
        /// <dd> <p>A bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref = "SharpDX.Direct3D11.ContentProtectionCaps"/></strong> enumeration.</p> </dd>
        /// </summary>
        /// <doc-id>hh447640</doc-id>
        /// <unmanaged>Caps</unmanaged>
        /// <unmanaged-short>Caps</unmanaged-short>
        public System.Int32 Caps;
        /// <summary>
        /// <dd> <p>The number of cryptographic key-exchange types that are supported by the driver. To get the list of key-exchange types, call the <strong>ID3D11VideoDevice::CheckCryptoKeyExchange</strong> method.</p> </dd>
        /// </summary>
        /// <doc-id>hh447640</doc-id>
        /// <unmanaged>KeyExchangeTypeCount</unmanaged>
        /// <unmanaged-short>KeyExchangeTypeCount</unmanaged-short>
        public System.Int32 KeyExchangeTypeCount;
        /// <summary>
        /// <dd> <p>The encyrption block size, in bytes. The size of data to be encrypted must be a multiple of this value. </p> </dd>
        /// </summary>
        /// <doc-id>hh447640</doc-id>
        /// <unmanaged>BlockAlignmentSize</unmanaged>
        /// <unmanaged-short>BlockAlignmentSize</unmanaged-short>
        public System.Int32 BlockAlignmentSize;
        /// <summary>
        /// <dd> <p>The total amount of memory, in bytes, that can be used to hold protected surfaces.</p> </dd>
        /// </summary>
        /// <doc-id>hh447640</doc-id>
        /// <unmanaged>ProtectedMemorySize</unmanaged>
        /// <unmanaged-short>ProtectedMemorySize</unmanaged-short>
        public System.Int64 ProtectedMemorySize;
    }

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Provides data to the <strong>ID3D11VideoContext::DecoderBeginFrame</strong> method.</p>
    /// </summary>
    /// <remarks>
    /// <p>This structure is passed in the <em>pContentKey</em> parameter of the <strong>ID3D11VideoContext::DecoderBeginFrame</strong> function when <strong>D3D11_DECODER_ENCRYPTION_HW_CENC</strong> is specified in the <strong>guidConfigBitstreamEncryption</strong> member of the <strong><see cref = "SharpDX.Direct3D11.VideoDecoderConfig"/></strong> structure when creating the video decoder interface.</p>
    /// </remarks>
    /// <doc-id>dn894118</doc-id>
    /// <unmanaged>D3D11_VIDEO_DECODER_BEGIN_FRAME_CRYPTO_SESSION</unmanaged>
    /// <unmanaged-short>D3D11_VIDEO_DECODER_BEGIN_FRAME_CRYPTO_SESSION</unmanaged-short>
    public partial struct VideoDecoderBeginFrameCryptoSession
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn894118</doc-id>
        /// <unmanaged>pCryptoSession</unmanaged>
        /// <unmanaged-short>pCryptoSession</unmanaged-short>
        public SharpDX.Direct3D11.CryptoSession PCryptoSession;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn894118</doc-id>
        /// <unmanaged>BlobSize</unmanaged>
        /// <unmanaged-short>BlobSize</unmanaged-short>
        public System.Int32 BlobSize;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn894118</doc-id>
        /// <unmanaged>pBlob</unmanaged>
        /// <unmanaged-short>pBlob</unmanaged-short>
        public System.IntPtr PBlob;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn894118</doc-id>
        /// <unmanaged>pKeyInfoId</unmanaged>
        /// <unmanaged-short>pKeyInfoId</unmanaged-short>
        public System.IntPtr PKeyInfoId;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn894118</doc-id>
        /// <unmanaged>PrivateDataSize</unmanaged>
        /// <unmanaged-short>PrivateDataSize</unmanaged-short>
        public System.Int32 PrivateDataSize;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn894118</doc-id>
        /// <unmanaged>pPrivateData</unmanaged>
        /// <unmanaged-short>pPrivateData</unmanaged-short>
        public System.IntPtr PPrivateData;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr PCryptoSession;
            public System.Int32 BlobSize;
            public System.IntPtr PBlob;
            public System.IntPtr PKeyInfoId;
            public System.Int32 PrivateDataSize;
            public System.IntPtr PPrivateData;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            if (@ref.PCryptoSession != System.IntPtr.Zero)
                PCryptoSession = new SharpDX.Direct3D11.CryptoSession(@ref.PCryptoSession);
            else
                PCryptoSession = null;
            BlobSize = @ref.BlobSize;
            PBlob = @ref.PBlob;
            PKeyInfoId = @ref.PKeyInfoId;
            PrivateDataSize = @ref.PrivateDataSize;
            PPrivateData = @ref.PPrivateData;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.PCryptoSession = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.CryptoSession>(PCryptoSession);
            @ref.BlobSize = BlobSize;
            @ref.PBlob = PBlob;
            @ref.PKeyInfoId = PKeyInfoId;
            @ref.PrivateDataSize = PrivateDataSize;
            @ref.PPrivateData = PPrivateData;
        }
    }

    /// <summary>
    /// <p>Describes a compressed buffer for decoding.</p>
    /// </summary>
    /// <doc-id>hh447641</doc-id>
    /// <unmanaged>D3D11_VIDEO_DECODER_BUFFER_DESC</unmanaged>
    /// <unmanaged-short>D3D11_VIDEO_DECODER_BUFFER_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoDecoderBufferDescription
    {
        /// <summary>
        /// <dd> <p>The type of buffer, specified as a member of the <strong><see cref = "SharpDX.Direct3D11.VideoDecoderBufferType"/></strong> enumeration.</p> </dd>
        /// </summary>
        /// <doc-id>hh447641</doc-id>
        /// <unmanaged>BufferType</unmanaged>
        /// <unmanaged-short>BufferType</unmanaged-short>
        public SharpDX.Direct3D11.VideoDecoderBufferType BufferType;
        /// <summary>
        /// <dd> <p>Reserved.</p> </dd>
        /// </summary>
        /// <doc-id>hh447641</doc-id>
        /// <unmanaged>BufferIndex</unmanaged>
        /// <unmanaged-short>BufferIndex</unmanaged-short>
        public System.Int32 BufferIndex;
        /// <summary>
        /// <dd> <p>The offset of the relevant data from the beginning of the buffer, in bytes. This value must be zero. 
        /// </p> </dd>
        /// </summary>
        /// <doc-id>hh447641</doc-id>
        /// <unmanaged>DataOffset</unmanaged>
        /// <unmanaged-short>DataOffset</unmanaged-short>
        public System.Int32 DataOffset;
        /// <summary>
        /// <dd> <p>The macroblock address of the first macroblock in the buffer. The macroblock address is given in raster scan order.
        /// </p> </dd>
        /// </summary>
        /// <doc-id>hh447641</doc-id>
        /// <unmanaged>DataSize</unmanaged>
        /// <unmanaged-short>DataSize</unmanaged-short>
        public System.Int32 DataSize;
        /// <summary>
        /// <dd> <p>The macroblock address of the first macroblock in the buffer. The macroblock address is given in raster scan order.
        /// </p> </dd>
        /// </summary>
        /// <doc-id>hh447641</doc-id>
        /// <unmanaged>FirstMBaddress</unmanaged>
        /// <unmanaged-short>FirstMBaddress</unmanaged-short>
        public System.Int32 FirstMBaddress;
        /// <summary>
        /// <dd> <p>The number of macroblocks of data in the buffer. This count includes skipped macroblocks. </p> </dd>
        /// </summary>
        /// <doc-id>hh447641</doc-id>
        /// <unmanaged>NumMBsInBuffer</unmanaged>
        /// <unmanaged-short>NumMBsInBuffer</unmanaged-short>
        public System.Int32 NumMBsInBuffer;
        /// <summary>
        /// <dd> <p>Reserved. Set to zero.</p> </dd>
        /// </summary>
        /// <doc-id>hh447641</doc-id>
        /// <unmanaged>Width</unmanaged>
        /// <unmanaged-short>Width</unmanaged-short>
        public System.Int32 Width;
        /// <summary>
        /// <dd> <p>Reserved. Set to zero.</p> </dd>
        /// </summary>
        /// <doc-id>hh447641</doc-id>
        /// <unmanaged>Height</unmanaged>
        /// <unmanaged-short>Height</unmanaged-short>
        public System.Int32 Height;
        /// <summary>
        /// <dd> <p>Reserved. Set to zero.</p> </dd>
        /// </summary>
        /// <doc-id>hh447641</doc-id>
        /// <unmanaged>Stride</unmanaged>
        /// <unmanaged-short>Stride</unmanaged-short>
        public System.Int32 Stride;
        /// <summary>
        /// <dd> <p>Reserved. Set to zero.</p> </dd>
        /// </summary>
        /// <doc-id>hh447641</doc-id>
        /// <unmanaged>ReservedBits</unmanaged>
        /// <unmanaged-short>ReservedBits</unmanaged-short>
        public System.Int32 ReservedBits;
        /// <summary>
        /// <dd> <p>A reference to a buffer that contains an initialization vector (IV) for encrypted data. If the decode buffer does not contain encrypted data, set this member to <strong><c>null</c></strong>.</p> </dd>
        /// </summary>
        /// <doc-id>hh447641</doc-id>
        /// <unmanaged>pIV</unmanaged>
        /// <unmanaged-short>pIV</unmanaged-short>
        public System.IntPtr PIV;
        /// <summary>
        /// <dd> <p>The size of the buffer specified in the <strong>pIV</strong> parameter. If <strong>pIV</strong> is <strong><c>null</c></strong>, set this member to zero.</p> </dd>
        /// </summary>
        /// <doc-id>hh447641</doc-id>
        /// <unmanaged>IVSize</unmanaged>
        /// <unmanaged-short>IVSize</unmanaged-short>
        public System.Int32 IVSize;
        /// <summary>
        /// <dd> <p>If <strong>TRUE</strong>, the video surfaces are partially encrypted.</p> </dd>
        /// </summary>
        /// <doc-id>hh447641</doc-id>
        /// <unmanaged>PartialEncryption</unmanaged>
        /// <unmanaged-short>PartialEncryption</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool PartialEncryption;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.EncryptedBlockInformation"/></strong> structure that specifies which bytes of the surface are encrypted.</p> </dd>
        /// </summary>
        /// <doc-id>hh447641</doc-id>
        /// <unmanaged>EncryptedBlockInfo</unmanaged>
        /// <unmanaged-short>EncryptedBlockInfo</unmanaged-short>
        public SharpDX.Direct3D11.EncryptedBlockInformation EncryptedBlockInfo;
    }

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Describes a compressed buffer for decoding.</p>
    /// </summary>
    /// <doc-id>dn894119</doc-id>
    /// <unmanaged>D3D11_VIDEO_DECODER_BUFFER_DESC1</unmanaged>
    /// <unmanaged-short>D3D11_VIDEO_DECODER_BUFFER_DESC1</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoDecoderBufferDescription1
    {
        /// <summary>
        /// <dd> <p>The type of buffer.</p> </dd>
        /// </summary>
        /// <doc-id>dn894119</doc-id>
        /// <unmanaged>BufferType</unmanaged>
        /// <unmanaged-short>BufferType</unmanaged-short>
        public SharpDX.Direct3D11.VideoDecoderBufferType BufferType;
        /// <summary>
        /// <dd> <p>The offset of the relevant data from the beginning of the buffer, in bytes. This value must be zero. </p> </dd>
        /// </summary>
        /// <doc-id>dn894119</doc-id>
        /// <unmanaged>DataOffset</unmanaged>
        /// <unmanaged-short>DataOffset</unmanaged-short>
        public System.Int32 DataOffset;
        /// <summary>
        /// <dd> <p>Size of the relevant data.</p> </dd>
        /// </summary>
        /// <doc-id>dn894119</doc-id>
        /// <unmanaged>DataSize</unmanaged>
        /// <unmanaged-short>DataSize</unmanaged-short>
        public System.Int32 DataSize;
        /// <summary>
        /// <dd> <p>A reference to a buffer that contains an initialization vector (IV) for encrypted data. If the decode buffer does not contain encrypted data, set this member to <c>null</c>.</p> </dd>
        /// </summary>
        /// <doc-id>dn894119</doc-id>
        /// <unmanaged>pIV</unmanaged>
        /// <unmanaged-short>pIV</unmanaged-short>
        public System.IntPtr PIV;
        /// <summary>
        /// <dd> <p>The size of the buffer specified in the <em>pIV</em> parameter. If <em>pIV</em> is <c>null</c>, set this member to zero.</p> </dd>
        /// </summary>
        /// <doc-id>dn894119</doc-id>
        /// <unmanaged>IVSize</unmanaged>
        /// <unmanaged-short>IVSize</unmanaged-short>
        public System.Int32 IVSize;
        /// <summary>
        /// <dd> <p>A reference to an array of <strong><see cref = "SharpDX.Direct3D11.VideoDecoderSubSampleMappingBlock"/></strong> structures, which indicates exactly which bytes in the decode buffer are encrypted and which are in the clear.  If the decode buffer does not contain encrypted data, set this member to <c>null</c>.</p> <p>Values in the sub sample mapping blocks are relative to the start of the decode buffer.</p> </dd>
        /// </summary>
        /// <doc-id>dn894119</doc-id>
        /// <unmanaged>pSubSampleMappingBlock</unmanaged>
        /// <unmanaged-short>pSubSampleMappingBlock</unmanaged-short>
        public System.IntPtr PSubSampleMappingBlock;
        /// <summary>
        /// <dd> <p>The number of <strong><see cref = "SharpDX.Direct3D11.VideoDecoderSubSampleMappingBlock"/></strong> structures specified in the <em>pSubSampleMappingBlocks</em> parameter. If <em>pSubSampleMappingBlocks</em> is <c>null</c>, set this member to zero.</p> </dd>
        /// </summary>
        /// <doc-id>dn894119</doc-id>
        /// <unmanaged>SubSampleMappingCount</unmanaged>
        /// <unmanaged-short>SubSampleMappingCount</unmanaged-short>
        public System.Int32 SubSampleMappingCount;
    }

    /// <summary>
    /// No documentation.
    /// </summary>
    /// <unmanaged>D3D11_VIDEO_DECODER_BUFFER_DESC2</unmanaged>
    /// <unmanaged-short>D3D11_VIDEO_DECODER_BUFFER_DESC2</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoDecoderBufferDescription2
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>BufferType</unmanaged>
        /// <unmanaged-short>BufferType</unmanaged-short>
        public SharpDX.Direct3D11.VideoDecoderBufferType BufferType;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DataOffset</unmanaged>
        /// <unmanaged-short>DataOffset</unmanaged-short>
        public System.Int32 DataOffset;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>DataSize</unmanaged>
        /// <unmanaged-short>DataSize</unmanaged-short>
        public System.Int32 DataSize;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pIV</unmanaged>
        /// <unmanaged-short>pIV</unmanaged-short>
        public System.IntPtr PIV;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>IVSize</unmanaged>
        /// <unmanaged-short>IVSize</unmanaged-short>
        public System.Int32 IVSize;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>pSubSampleMappingBlock</unmanaged>
        /// <unmanaged-short>pSubSampleMappingBlock</unmanaged-short>
        public System.IntPtr PSubSampleMappingBlock;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SubSampleMappingCount</unmanaged>
        /// <unmanaged-short>SubSampleMappingCount</unmanaged-short>
        public System.Int32 SubSampleMappingCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>cBlocksStripeEncrypted</unmanaged>
        /// <unmanaged-short>cBlocksStripeEncrypted</unmanaged-short>
        public System.Int32 CBlocksStripeEncrypted;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>cBlocksStripeClear</unmanaged>
        /// <unmanaged-short>cBlocksStripeClear</unmanaged-short>
        public System.Int32 CBlocksStripeClear;
    }

    /// <summary>
    /// <p>Describes the configuration of a Microsoft Direct3D?11 decoder device for DirectX Video Acceleration (DXVA). </p>
    /// </summary>
    /// <doc-id>hh447643</doc-id>
    /// <unmanaged>D3D11_VIDEO_DECODER_CONFIG</unmanaged>
    /// <unmanaged-short>D3D11_VIDEO_DECODER_CONFIG</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoDecoderConfig
    {
        /// <summary>
        /// <dd> <p>If the bitstream data buffers are encrypted using the D3D11CryptoSession mechanism, this <see cref = "System.Guid"/> should be set to zero. If no encryption is applied, the value is <strong>DXVA_NoEncrypt</strong>. If <strong>ConfigBitstreamRaw</strong> is 0, the value must be <strong>DXVA_NoEncrypt</strong>. </p> </dd>
        /// </summary>
        /// <doc-id>hh447643</doc-id>
        /// <unmanaged>guidConfigBitstreamEncryption</unmanaged>
        /// <unmanaged-short>guidConfigBitstreamEncryption</unmanaged-short>
        public System.Guid GuidConfigBitstreamEncryption;
        /// <summary>
        /// <dd> <p>If the macroblock control data buffers are  encrypted using the D3D11CryptoSession mechanism, this <see cref = "System.Guid"/> should be set to zero.  If no encryption is applied, the value is <strong>DXVA_NoEncrypt</strong>. If <strong>ConfigBitstreamRaw</strong> is 1, the value must be <strong>DXVA_NoEncrypt</strong>. </p> </dd>
        /// </summary>
        /// <doc-id>hh447643</doc-id>
        /// <unmanaged>guidConfigMBcontrolEncryption</unmanaged>
        /// <unmanaged-short>guidConfigMBcontrolEncryption</unmanaged-short>
        public System.Guid GuidConfigMBcontrolEncryption;
        /// <summary>
        /// <dd> <p>If the residual difference decoding data buffers are  encrypted using the D3D11CryptoSession mechanism, this <see cref = "System.Guid"/> should be set to zero.   If no encryption is applied, the value is <strong>DXVA_NoEncrypt</strong>. If <strong>ConfigBitstreamRaw</strong> is 1, the value must be <strong>DXVA_NoEncrypt</strong>. </p> </dd>
        /// </summary>
        /// <doc-id>hh447643</doc-id>
        /// <unmanaged>guidConfigResidDiffEncryption</unmanaged>
        /// <unmanaged-short>guidConfigResidDiffEncryption</unmanaged-short>
        public System.Guid GuidConfigResidDiffEncryption;
        /// <summary>
        /// <dd> <p>Indicates whether the host-decoder sends raw bit-stream data. If the value is 1, the data for the pictures will be sent in bit-stream buffers as raw bit-stream content. If the value is 0, picture data will be sent using macroblock control command buffers. If either <strong>ConfigResidDiffHost</strong> or <strong>ConfigResidDiffAccelerator</strong> is 1, the value must be 0. </p> </dd>
        /// </summary>
        /// <doc-id>hh447643</doc-id>
        /// <unmanaged>ConfigBitstreamRaw</unmanaged>
        /// <unmanaged-short>ConfigBitstreamRaw</unmanaged-short>
        public System.Int32 ConfigBitstreamRaw;
        /// <summary>
        /// <dd> <p>Specifies whether macroblock control commands are in raster scan order or in arbitrary order. If the value is 1, the macroblock control commands within each macroblock control command buffer are in raster-scan order. If the value is 0, the order is arbitrary. For some types of bit streams, forcing raster order either greatly increases the number of required macroblock control buffers that must be processed, or requires host reordering of the control information. Therefore, supporting arbitrary order can be more efficient. </p> </dd>
        /// </summary>
        /// <doc-id>hh447643</doc-id>
        /// <unmanaged>ConfigMBcontrolRasterOrder</unmanaged>
        /// <unmanaged-short>ConfigMBcontrolRasterOrder</unmanaged-short>
        public System.Int32 ConfigMBcontrolRasterOrder;
        /// <summary>
        /// <dd> <p>Contains the host residual difference configuration. If the value is 1, some residual difference decoding data may be sent as blocks in the spatial domain from the host. If the value is 0, spatial domain data will not be sent. </p> </dd>
        /// </summary>
        /// <doc-id>hh447643</doc-id>
        /// <unmanaged>ConfigResidDiffHost</unmanaged>
        /// <unmanaged-short>ConfigResidDiffHost</unmanaged-short>
        public System.Int32 ConfigResidDiffHost;
        /// <summary>
        /// <dd> <p>Indicates the word size used to represent residual difference spatial-domain blocks for predicted (non-intra) pictures when using host-based residual difference decoding. </p> <p>If <strong>ConfigResidDiffHost</strong> is 1 and <strong>ConfigSpatialResid8</strong> is 1, the host will send residual difference spatial-domain blocks for non-intra macroblocks using 8-bit signed samples and for intra macroblocks in predicted (non-intra) pictures in a format that depends on the value of <strong>ConfigIntraResidUnsigned</strong>: </p> <ul> <li> If <strong>ConfigIntraResidUnsigned</strong> is 0, spatial-domain blocks for intra macroblocks are sent as 8-bit signed integer values relative to a constant reference value of 2^(BPP?1). </li> <li> If <strong>ConfigIntraResidUnsigned</strong> is 1, spatial-domain blocks for intra macroblocks are sent as 8-bit unsigned integer values relative to a constant reference value of 0. </li> </ul> <p> If <strong>ConfigResidDiffHost</strong> is 1 and <strong>ConfigSpatialResid8</strong> is 0, the host will send residual difference spatial-domain blocks of data for non-intra macroblocks using 16-bit signed samples and for intra macroblocks in predicted (non-intra) pictures in a format that depends on the value of <strong>ConfigIntraResidUnsigned</strong>: </p> <ul> <li> If <strong>ConfigIntraResidUnsigned</strong> is 0, spatial domain blocks for intra macroblocks are sent as 16-bit signed integer values relative to a constant reference value of 2^(BPP?1). </li> <li> If <strong>ConfigIntraResidUnsigned</strong> is 1, spatial domain blocks for intra macroblocks are sent as 16-bit unsigned integer values relative to a constant reference value of 0. </li> </ul> <p> If <strong>ConfigResidDiffHost</strong> is 0, <strong>ConfigSpatialResid8</strong> must be 0. </p> <p> For intra pictures, spatial-domain blocks must be sent using 8-bit samples if bits-per-pixel (BPP) is 8, and using 16-bit samples if BPP &gt; 8. If <strong>ConfigIntraResidUnsigned</strong> is 0, these samples are sent as signed integer values relative to a constant reference value of 2^(BPP?1), and if <strong>ConfigIntraResidUnsigned</strong> is 1, these samples are sent as unsigned integer values relative to a constant reference value of 0. </p> </dd>
        /// </summary>
        /// <doc-id>hh447643</doc-id>
        /// <unmanaged>ConfigSpatialResid8</unmanaged>
        /// <unmanaged-short>ConfigSpatialResid8</unmanaged-short>
        public System.Int32 ConfigSpatialResid8;
        /// <summary>
        /// <dd> <p> If the value is 1, 8-bit difference overflow blocks are subtracted rather than added. The value must be 0 unless <strong>ConfigSpatialResid8</strong> is 1. </p> <p> The ability to subtract differences rather than add them enables 8-bit difference decoding to be fully compliant with the full ?255 range of values required in video decoder specifications, because +255 cannot be represented as the addition of two signed 8-bit numbers, but any number in the range ?255 can be represented as the difference between two signed 8-bit numbers (+255 = +127 minus ?128).</p> </dd>
        /// </summary>
        /// <doc-id>hh447643</doc-id>
        /// <unmanaged>ConfigResid8Subtraction</unmanaged>
        /// <unmanaged-short>ConfigResid8Subtraction</unmanaged-short>
        public System.Int32 ConfigResid8Subtraction;
        /// <summary>
        /// <dd> <p> If the value is 1, spatial-domain blocks for intra macroblocks must be clipped to an 8-bit range on the host and spatial-domain blocks for non-intra macroblocks must be clipped to a 9-bit range on the host. If the value is 0, no such clipping is necessary by the host. </p> <p> The value must be 0 unless <strong>ConfigSpatialResid8</strong> is 0 and <strong>ConfigResidDiffHost</strong> is 1. </p> </dd>
        /// </summary>
        /// <doc-id>hh447643</doc-id>
        /// <unmanaged>ConfigSpatialHost8or9Clipping</unmanaged>
        /// <unmanaged-short>ConfigSpatialHost8or9Clipping</unmanaged-short>
        public System.Int32 ConfigSpatialHost8or9Clipping;
        /// <summary>
        /// <dd> <p> If the value is 1, any spatial-domain residual difference data must be sent in a chrominance-interleaved form matching the YUV format chrominance interleaving pattern. The value must be 0 unless <strong>ConfigResidDiffHost</strong> is 1 and the YUV format is NV12 or NV21. </p> </dd>
        /// </summary>
        /// <doc-id>hh447643</doc-id>
        /// <unmanaged>ConfigSpatialResidInterleaved</unmanaged>
        /// <unmanaged-short>ConfigSpatialResidInterleaved</unmanaged-short>
        public System.Int32 ConfigSpatialResidInterleaved;
        /// <summary>
        /// <dd> <p> Indicates the method of representation of spatial-domain blocks of residual difference data for intra blocks when using host-based difference decoding. </p> <p> If <strong>ConfigResidDiffHost</strong> is 1 and <strong>ConfigIntraResidUnsigned</strong> is 0, spatial-domain residual difference data blocks for intra macroblocks must be sent as follows: </p> <ul> <li> In a non-intra picture, if <strong>ConfigSpatialResid8</strong> is 0, the spatial-domain residual difference data blocks for intra macroblocks are sent as 16-bit signed integer values relative to a constant reference value of 2^(BPP?1). </li> <li> In a non-intra picture, if <strong>ConfigSpatialResid8</strong> is 1, the spatial-domain residual difference data blocks for intra macroblocks are sent as 8-bit signed integer values relative to a constant reference value of 2^(BPP?1). </li> <li> In an intra picture, if BPP is 8, the spatial-domain residual difference data blocks for intra macroblocks are sent as 8-bit signed integer values relative to a constant reference value of 2^(BPP?1), regardless of the value of <strong>ConfigSpatialResid8</strong>. </li> </ul> <p> If <strong>ConfigResidDiffHost</strong> is 1 and <strong>ConfigIntraResidUnsigned</strong> is 1, spatial-domain residual difference data blocks for intra macroblocks must be sent as follows: </p> <ul> <li> In a non-intra picture, if <strong>ConfigSpatialResid8</strong> is 0, the spatial-domain residual difference data blocks for intra macroblocks must be sent as 16-bit unsigned integer values relative to a constant reference value of 0. </li> <li> In a non-intra picture, if <strong>ConfigSpatialResid8</strong> is 1, the spatial-domain residual difference data blocks for intra macroblocks are sent as 8-bit unsigned integer values relative to a constant reference value of 0. </li> <li> In an intra picture, if BPP is 8, the spatial-domain residual difference data blocks for intra macroblocks are sent as 8-bit unsigned integer values relative to a constant reference value of 0, regardless of the value of <strong>ConfigSpatialResid8</strong>. </li> </ul> <p> The value of the member must be 0 unless <strong>ConfigResidDiffHost</strong> is 1. </p> </dd>
        /// </summary>
        /// <doc-id>hh447643</doc-id>
        /// <unmanaged>ConfigIntraResidUnsigned</unmanaged>
        /// <unmanaged-short>ConfigIntraResidUnsigned</unmanaged-short>
        public System.Int32 ConfigIntraResidUnsigned;
        /// <summary>
        /// <dd> <p> If the value is 1, transform-domain blocks of coefficient data may be sent from the host for accelerator-based IDCT. If the value is 0, accelerator-based IDCT will not be used. If both <strong>ConfigResidDiffHost</strong> and <strong>ConfigResidDiffAccelerator</strong> are 1, this indicates that some residual difference decoding will be done on the host and some on the accelerator, as indicated by macroblock-level control commands. </p> <p> The value must be 0 if <strong>ConfigBitstreamRaw</strong> is 1. </p> </dd>
        /// </summary>
        /// <doc-id>hh447643</doc-id>
        /// <unmanaged>ConfigResidDiffAccelerator</unmanaged>
        /// <unmanaged-short>ConfigResidDiffAccelerator</unmanaged-short>
        public System.Int32 ConfigResidDiffAccelerator;
        /// <summary>
        /// <dd> <p> If the value is 1, the inverse scan for transform-domain block processing will be performed on the host, and absolute indices will be sent instead for any transform coefficients. If the value is 0, the inverse scan will be performed on the accelerator. </p> <p> The value must be 0 if <strong>ConfigResidDiffAccelerator</strong> is 0 or if <strong>Config4GroupedCoefs</strong> is 1. </p> </dd>
        /// </summary>
        /// <doc-id>hh447643</doc-id>
        /// <unmanaged>ConfigHostInverseScan</unmanaged>
        /// <unmanaged-short>ConfigHostInverseScan</unmanaged-short>
        public System.Int32 ConfigHostInverseScan;
        /// <summary>
        /// <dd> <p> If the value is 1, the IDCT specified in Annex W of ITU-T Recommendation H.263 is used. If the value is 0, any compliant IDCT can be used for off-host IDCT. </p> <p> The H.263 annex does not comply with the IDCT requirements of MPEG-2 corrigendum 2, so the value must not be 1 for use with MPEG-2 video. </p> <p> The value must be 0 if <strong>ConfigResidDiffAccelerator</strong> is 0, indicating purely host-based residual difference decoding. </p> </dd>
        /// </summary>
        /// <doc-id>hh447643</doc-id>
        /// <unmanaged>ConfigSpecificIDCT</unmanaged>
        /// <unmanaged-short>ConfigSpecificIDCT</unmanaged-short>
        public System.Int32 ConfigSpecificIDCT;
        /// <summary>
        /// <dd> <p> If the value is 1, transform coefficients for off-host IDCT will be sent using the <strong>DXVA_TCoef4Group</strong> structure. If the value is 0, the <strong>DXVA_TCoefSingle</strong> structure is used. The value must be 0 if <strong>ConfigResidDiffAccelerator</strong> is 0 or if <strong>ConfigHostInverseScan</strong> is 1. </p> </dd>
        /// </summary>
        /// <doc-id>hh447643</doc-id>
        /// <unmanaged>Config4GroupedCoefs</unmanaged>
        /// <unmanaged-short>Config4GroupedCoefs</unmanaged-short>
        public System.Int32 Config4GroupedCoefs;
        /// <summary>
        /// <dd> <p> Specifies how many frames the decoder device processes at any one time. </p> </dd>
        /// </summary>
        /// <doc-id>hh447643</doc-id>
        /// <unmanaged>ConfigMinRenderTargetBuffCount</unmanaged>
        /// <unmanaged-short>ConfigMinRenderTargetBuffCount</unmanaged-short>
        public System.Int16 ConfigMinRenderTargetBuffCount;
        /// <summary>
        /// <dd> <p> Contains decoder-specific configuration information. </p> </dd>
        /// </summary>
        /// <doc-id>hh447643</doc-id>
        /// <unmanaged>ConfigDecoderSpecific</unmanaged>
        /// <unmanaged-short>ConfigDecoderSpecific</unmanaged-short>
        public System.Int16 ConfigDecoderSpecific;
    }

    /// <summary>
    /// <p>Describes a video stream for a Microsoft Direct3D?11 video decoder or video processor.  </p>
    /// </summary>
    /// <doc-id>hh447644</doc-id>
    /// <unmanaged>D3D11_VIDEO_DECODER_DESC</unmanaged>
    /// <unmanaged-short>D3D11_VIDEO_DECODER_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoDecoderDescription
    {
        /// <summary>
        /// <dd> <p>The decoding profile. To get the list of profiles supported by the device, call the <strong>ID3D11VideoDevice::GetVideoDecoderProfile</strong> method.</p> </dd>
        /// </summary>
        /// <doc-id>hh447644</doc-id>
        /// <unmanaged>Guid</unmanaged>
        /// <unmanaged-short>Guid</unmanaged-short>
        public System.Guid Guid;
        /// <summary>
        /// <dd> <p>The width of the video frame, in pixels.  </p> </dd>
        /// </summary>
        /// <doc-id>hh447644</doc-id>
        /// <unmanaged>SampleWidth</unmanaged>
        /// <unmanaged-short>SampleWidth</unmanaged-short>
        public System.Int32 SampleWidth;
        /// <summary>
        /// <dd> <p>The height of the video frame, in pixels.  </p> </dd>
        /// </summary>
        /// <doc-id>hh447644</doc-id>
        /// <unmanaged>SampleHeight</unmanaged>
        /// <unmanaged-short>SampleHeight</unmanaged-short>
        public System.Int32 SampleHeight;
        /// <summary>
        /// <dd> <p>The output surface format, specified as a <strong><see cref = "SharpDX.DXGI.Format"/></strong> value.</p> </dd>
        /// </summary>
        /// <doc-id>hh447644</doc-id>
        /// <unmanaged>OutputFormat</unmanaged>
        /// <unmanaged-short>OutputFormat</unmanaged-short>
        public SharpDX.DXGI.Format OutputFormat;
    }

    /// <summary>
    /// <p>Contains driver-specific data for the <strong>ID3D11VideoContext::DecoderExtension</strong> method.</p>
    /// </summary>
    /// <remarks>
    /// <p>The exact meaning of each structure member depends on the value of <strong>Function</strong>.</p>
    /// </remarks>
    /// <doc-id>hh447645</doc-id>
    /// <unmanaged>D3D11_VIDEO_DECODER_EXTENSION</unmanaged>
    /// <unmanaged-short>D3D11_VIDEO_DECODER_EXTENSION</unmanaged-short>
    public partial struct VideoDecoderExtension
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447645</doc-id>
        /// <unmanaged>Function</unmanaged>
        /// <unmanaged-short>Function</unmanaged-short>
        public System.Int32 Function;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447645</doc-id>
        /// <unmanaged>pPrivateInputData</unmanaged>
        /// <unmanaged-short>pPrivateInputData</unmanaged-short>
        public System.IntPtr PPrivateInputData;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447645</doc-id>
        /// <unmanaged>PrivateInputDataSize</unmanaged>
        /// <unmanaged-short>PrivateInputDataSize</unmanaged-short>
        public System.Int32 PrivateInputDataSize;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447645</doc-id>
        /// <unmanaged>pPrivateOutputData</unmanaged>
        /// <unmanaged-short>pPrivateOutputData</unmanaged-short>
        public System.IntPtr PPrivateOutputData;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447645</doc-id>
        /// <unmanaged>PrivateOutputDataSize</unmanaged>
        /// <unmanaged-short>PrivateOutputDataSize</unmanaged-short>
        public System.Int32 PrivateOutputDataSize;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447645</doc-id>
        /// <unmanaged>ResourceCount</unmanaged>
        /// <unmanaged-short>ResourceCount</unmanaged-short>
        public System.Int32 ResourceCount;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447645</doc-id>
        /// <unmanaged>ppResourceList</unmanaged>
        /// <unmanaged-short>ppResourceList</unmanaged-short>
        public SharpDX.Direct3D11.Resource PpResourceList;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Int32 Function;
            public System.IntPtr PPrivateInputData;
            public System.Int32 PrivateInputDataSize;
            public System.IntPtr PPrivateOutputData;
            public System.Int32 PrivateOutputDataSize;
            public System.Int32 ResourceCount;
            public System.IntPtr PpResourceList;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Function = @ref.Function;
            PPrivateInputData = @ref.PPrivateInputData;
            PrivateInputDataSize = @ref.PrivateInputDataSize;
            PPrivateOutputData = @ref.PPrivateOutputData;
            PrivateOutputDataSize = @ref.PrivateOutputDataSize;
            ResourceCount = @ref.ResourceCount;
            if (@ref.PpResourceList != System.IntPtr.Zero)
                PpResourceList = new SharpDX.Direct3D11.Resource(@ref.PpResourceList);
            else
                PpResourceList = null;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Function = Function;
            @ref.PPrivateInputData = PPrivateInputData;
            @ref.PrivateInputDataSize = PrivateInputDataSize;
            @ref.PPrivateOutputData = PPrivateOutputData;
            @ref.PrivateOutputDataSize = PrivateOutputDataSize;
            @ref.ResourceCount = ResourceCount;
            @ref.PpResourceList = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(PpResourceList);
        }
    }

    /// <summary>
    /// <p>Describes a video decoder output view.</p>
    /// </summary>
    /// <doc-id>hh447646</doc-id>
    /// <unmanaged>D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC</unmanaged>
    /// <unmanaged-short>D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoDecoderOutputViewDescription
    {
        /// <summary>
        /// <dd> <p>The decoding profile. To get the list of profiles supported by the device, call the <strong>ID3D11VideoDevice::GetVideoDecoderProfile</strong> method.</p> </dd>
        /// </summary>
        /// <doc-id>hh447646</doc-id>
        /// <unmanaged>DecodeProfile</unmanaged>
        /// <unmanaged-short>DecodeProfile</unmanaged-short>
        public System.Guid DecodeProfile;
        /// <summary>
        /// <dd> <p>The resource type of the view, specified as a member of the <strong><see cref = "SharpDX.Direct3D11.VdovDimension"/></strong> enumeration.</p> </dd>
        /// </summary>
        /// <doc-id>hh447646</doc-id>
        /// <unmanaged>ViewDimension</unmanaged>
        /// <unmanaged-short>ViewDimension</unmanaged-short>
        public SharpDX.Direct3D11.VdovDimension Dimension;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.Texture2DVdov"/></strong> structure that identifies the texture resource for the output view.</p> </dd>
        /// </summary>
        /// <doc-id>hh447646</doc-id>
        /// <unmanaged>Texture2D</unmanaged>
        /// <unmanaged-short>Texture2D</unmanaged-short>
        public SharpDX.Direct3D11.Texture2DVdov Texture2D;
    }

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Describes a sub sample mapping block.</p>
    /// </summary>
    /// <remarks>
    /// <p>Values in the sub sample mapping blocks are relative to the start of the decode buffer.</p>
    /// </remarks>
    /// <doc-id>dn894121</doc-id>
    /// <unmanaged>D3D11_VIDEO_DECODER_SUB_SAMPLE_MAPPING_BLOCK</unmanaged>
    /// <unmanaged-short>D3D11_VIDEO_DECODER_SUB_SAMPLE_MAPPING_BLOCK</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoDecoderSubSampleMappingBlock
    {
        /// <summary>
        /// <dd> <p>The number of clear (non-encrypted) bytes at the start of the block.</p> </dd>
        /// </summary>
        /// <doc-id>dn894121</doc-id>
        /// <unmanaged>ClearSize</unmanaged>
        /// <unmanaged-short>ClearSize</unmanaged-short>
        public System.Int32 ClearSize;
        /// <summary>
        /// <dd> <p>The number of encrypted bytes following the clear bytes.</p> </dd>
        /// </summary>
        /// <doc-id>dn894121</doc-id>
        /// <unmanaged>EncryptedSize</unmanaged>
        /// <unmanaged-short>EncryptedSize</unmanaged-short>
        public System.Int32 EncryptedSize;
    }

    /// <summary>
    /// <p>Describes the capabilities of a Microsoft Direct3D?11 video processor.</p>
    /// </summary>
    /// <remarks>
    /// <p>The video processor stores state information for each input stream. These states persist between blits. With each blit, the application selects which streams to enable or disable. Disabling a stream does not affect the state information for that stream.</p><p>The <strong>MaxStreamStates</strong> member gives the maximum number of stream states that can be saved. The <strong>MaxInputStreams</strong> member gives the maximum number of streams that can be enabled during a blit. These two values can differ. </p>
    /// </remarks>
    /// <doc-id>hh447650</doc-id>
    /// <unmanaged>D3D11_VIDEO_PROCESSOR_CAPS</unmanaged>
    /// <unmanaged-short>D3D11_VIDEO_PROCESSOR_CAPS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoProcessorCaps
    {
        /// <summary>
        /// <dd> <p>A bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref = "SharpDX.Direct3D11.VideoProcessorDeviceCaps"/></strong> enumeration.</p> </dd>
        /// </summary>
        /// <doc-id>hh447650</doc-id>
        /// <unmanaged>DeviceCaps</unmanaged>
        /// <unmanaged-short>DeviceCaps</unmanaged-short>
        public System.Int32 DeviceCaps;
        /// <summary>
        /// <dd> <p>A bitwise <strong>OR</strong> of zero or more flags from the   <strong><see cref = "SharpDX.Direct3D11.VideoProcessorFeatureCaps"/></strong> enumeration.</p> </dd>
        /// </summary>
        /// <doc-id>hh447650</doc-id>
        /// <unmanaged>FeatureCaps</unmanaged>
        /// <unmanaged-short>FeatureCaps</unmanaged-short>
        public System.Int32 FeatureCaps;
        /// <summary>
        /// <dd> <p>A bitwise <strong>OR</strong> of zero or more flags from the  <strong>D3D11_VIDEO_PROCESSPR_FILTER_CAPS</strong> enumeration.</p> </dd>
        /// </summary>
        /// <doc-id>hh447650</doc-id>
        /// <unmanaged>FilterCaps</unmanaged>
        /// <unmanaged-short>FilterCaps</unmanaged-short>
        public System.Int32 FilterCaps;
        /// <summary>
        /// <dd> <p>A bitwise <strong>OR</strong> of zero or more flags from the  <strong><see cref = "SharpDX.Direct3D11.VideoProcessorFormatCaps"/></strong> enumeration.</p> </dd>
        /// </summary>
        /// <doc-id>hh447650</doc-id>
        /// <unmanaged>InputFormatCaps</unmanaged>
        /// <unmanaged-short>InputFormatCaps</unmanaged-short>
        public System.Int32 InputFormatCaps;
        /// <summary>
        /// <dd> <p>A bitwise <strong>OR</strong> of zero or more flags from the  <strong><see cref = "SharpDX.Direct3D11.VideoProcessorAutoStreamCaps"/></strong> enumeration.</p> </dd>
        /// </summary>
        /// <doc-id>hh447650</doc-id>
        /// <unmanaged>AutoStreamCaps</unmanaged>
        /// <unmanaged-short>AutoStreamCaps</unmanaged-short>
        public System.Int32 AutoStreamCaps;
        /// <summary>
        /// <dd> <p>A bitwise <strong>OR</strong> of zero or more flags from the   <strong><see cref = "SharpDX.Direct3D11.VideoProcessorStereoCaps"/></strong> enumeration.</p> </dd>
        /// </summary>
        /// <doc-id>hh447650</doc-id>
        /// <unmanaged>StereoCaps</unmanaged>
        /// <unmanaged-short>StereoCaps</unmanaged-short>
        public System.Int32 StereoCaps;
        /// <summary>
        /// <dd> <p>The number of frame-rate conversion capabilities. To enumerate the frame-rate conversion capabilities, call the <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorRateConversionCaps</strong> method.</p> </dd>
        /// </summary>
        /// <doc-id>hh447650</doc-id>
        /// <unmanaged>RateConversionCapsCount</unmanaged>
        /// <unmanaged-short>RateConversionCapsCount</unmanaged-short>
        public System.Int32 RateConversionCapsCount;
        /// <summary>
        /// <dd> <p>The maximum number of input streams that can be enabled at the same time. </p> </dd>
        /// </summary>
        /// <doc-id>hh447650</doc-id>
        /// <unmanaged>MaxInputStreams</unmanaged>
        /// <unmanaged-short>MaxInputStreams</unmanaged-short>
        public System.Int32 MaxInputStreams;
        /// <summary>
        /// <dd> <p>The maximum number of input streams for which the device can store state data.</p> </dd>
        /// </summary>
        /// <doc-id>hh447650</doc-id>
        /// <unmanaged>MaxStreamStates</unmanaged>
        /// <unmanaged-short>MaxStreamStates</unmanaged-short>
        public System.Int32 MaxStreamStates;
    }

    /// <summary>
    /// <p>Specifies the color space for video processing.</p>
    /// </summary>
    /// <remarks>
    /// <p>The <strong>RGB_Range</strong> member applies to RGB output, while the <strong>YCbCr_Matrix</strong> and <strong>YCbCr_xvYCC</strong> members apply to YCbCr output. If the driver performs color-space conversion on the background color, it uses the values that apply to both color spaces. </p><p>If the driver supports extended YCbCr (xvYCC), it returns the <strong>D3D11_VIDEO_PROCESSOR_DEVICE_CAPS_xvYCC</strong> capabilities flag in the <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> method. Otherwise, the driver ignores the value of <strong>YCbCr_xvYCC</strong> and treats all YCbCr output as conventional YCbCr. </p><p>If extended YCbCr is supported, it can be used with either transfer matrix. Extended YCbCr does not change the black point or white point?the black point is still 16 and the white point is still 235. However, extended YCbCr explicitly allows blacker-than-black values in the range 1?15, and whiter-than-white values in the range 236?254. When extended YCbCr is used, the driver should not clip the luma values to the nominal 16?235 range.</p>
    /// </remarks>
    /// <doc-id>hh447651</doc-id>
    /// <unmanaged>D3D11_VIDEO_PROCESSOR_COLOR_SPACE</unmanaged>
    /// <unmanaged-short>D3D11_VIDEO_PROCESSOR_COLOR_SPACE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoProcessorColorSpace
    {
        /// <summary>
        /// <dd> <p>Specifies whether the output is intended for playback or video processing (such as editing or authoring). The device can optimize the processing based on the type. The default state value is 0 (playback).  </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0</dt> </dl> </td><td> <p>Playback</p> </td></tr> <tr><td> <dl> <dt>1</dt> </dl> </td><td> <p>Video processing</p> </td></tr> </table> <p>?</p> </dd>
        /// </summary>
        /// <doc-id>hh447651</doc-id>
        /// <unmanaged>Usage</unmanaged>
        /// <unmanaged-short>Usage</unmanaged-short>
        public bool Usage
        {
            get => 0 != ((_Usage >> 0) & 1);
            set => this._Usage = (System.Int32)((this._Usage & ~(1 << 0)) | (((value ? 1 : 0) & 1) << 0));
        }

        [System.Runtime.InteropServices.FieldOffset(0)]
        internal System.Int32 _Usage;
        /// <summary>
        /// <dd> <p>Specifies the RGB color range. The default state value is 0 (full range). </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0</dt> </dl> </td><td> <p>Full range (0-255)</p> </td></tr> <tr><td> <dl> <dt>1</dt> </dl> </td><td> <p>Limited range (16-235)</p> </td></tr> </table> <p>?</p> </dd>
        /// </summary>
        /// <doc-id>hh447651</doc-id>
        /// <unmanaged>RGB_Range</unmanaged>
        /// <unmanaged-short>RGB_Range</unmanaged-short>
        public bool RgbRange
        {
            get => 0 != ((_RgbRange >> 1) & 1);
            set => this._RgbRange = (System.Int32)((this._RgbRange & ~(1 << 1)) | (((value ? 1 : 0) & 1) << 1));
        }

        [System.Runtime.InteropServices.FieldOffset(0)]
        internal System.Int32 _RgbRange;
        /// <summary>
        /// <dd> <p>Specifies the YCbCr transfer matrix. The default state value is 0 (BT.601). </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0</dt> </dl> </td><td> <p>ITU-R BT.601</p> </td></tr> <tr><td> <dl> <dt>1</dt> </dl> </td><td> <p>ITU-R BT.709</p> </td></tr> </table> <p>?</p> </dd>
        /// </summary>
        /// <doc-id>hh447651</doc-id>
        /// <unmanaged>YCbCr_Matrix</unmanaged>
        /// <unmanaged-short>YCbCr_Matrix</unmanaged-short>
        public bool YCbCrMatrix
        {
            get => 0 != ((_YCbCrMatrix >> 2) & 1);
            set => this._YCbCrMatrix = (System.Int32)((this._YCbCrMatrix & ~(1 << 2)) | (((value ? 1 : 0) & 1) << 2));
        }

        [System.Runtime.InteropServices.FieldOffset(0)]
        internal System.Int32 _YCbCrMatrix;
        /// <summary>
        /// <dd> <p>Specifies whether the output uses conventional YCbCr or extended YCbCr (xvYCC). The default state value is zero (conventional YCbCr). </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0</dt> </dl> </td><td> <p>Conventional YCbCr</p> </td></tr> <tr><td> <dl> <dt>1</dt> </dl> </td><td> <p>Extended YCbCr (xvYCC)</p> </td></tr> </table> <p>?</p> </dd>
        /// </summary>
        /// <doc-id>hh447651</doc-id>
        /// <unmanaged>YCbCr_xvYCC</unmanaged>
        /// <unmanaged-short>YCbCr_xvYCC</unmanaged-short>
        public bool YCbCrXvYCC
        {
            get => 0 != ((_YCbCrXvYCC >> 3) & 1);
            set => this._YCbCrXvYCC = (System.Int32)((this._YCbCrXvYCC & ~(1 << 3)) | (((value ? 1 : 0) & 1) << 3));
        }

        [System.Runtime.InteropServices.FieldOffset(0)]
        internal System.Int32 _YCbCrXvYCC;
        /// <summary>
        /// <dd> <p>Specifies the <strong><see cref = "SharpDX.Direct3D11.VideoProcessorNominalRange"/></strong>. </p> <p>Introduced in Windows?8.1.</p> </dd>
        /// </summary>
        /// <doc-id>hh447651</doc-id>
        /// <unmanaged>Nominal_Range</unmanaged>
        /// <unmanaged-short>Nominal_Range</unmanaged-short>
        public System.Int32 NominalRange
        {
            get => (System.Int32)((_NominalRange >> 4) & 3);
            set => this._NominalRange = (System.Int32)((this._NominalRange & ~(3 << 4)) | ((value & 3) << 4));
        }

        [System.Runtime.InteropServices.FieldOffset(0)]
        internal System.Int32 _NominalRange;
        /// <summary>
        /// <dd> <p>Reserved. Set to zero.</p> </dd>
        /// </summary>
        /// <doc-id>hh447651</doc-id>
        /// <unmanaged>Reserved</unmanaged>
        /// <unmanaged-short>Reserved</unmanaged-short>
        public System.Int32 Reserved
        {
            get => (System.Int32)((_Reserved >> 6) & 67108863);
            set => this._Reserved = (System.Int32)((this._Reserved & ~(67108863 << 6)) | ((value & 67108863) << 6));
        }

        [System.Runtime.InteropServices.FieldOffset(0)]
        internal System.Int32 _Reserved;
    }

    /// <summary>
    /// <p>Describes a video stream for a video processor.</p>
    /// </summary>
    /// <doc-id>hh447652</doc-id>
    /// <unmanaged>D3D11_VIDEO_PROCESSOR_CONTENT_DESC</unmanaged>
    /// <unmanaged-short>D3D11_VIDEO_PROCESSOR_CONTENT_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoProcessorContentDescription
    {
        /// <summary>
        /// <dd> <p>A member of the <strong><see cref = "SharpDX.Direct3D11.VideoFrameFormat"/></strong> enumeration that describes how the video stream is interlaced.</p> </dd>
        /// </summary>
        /// <doc-id>hh447652</doc-id>
        /// <unmanaged>InputFrameFormat</unmanaged>
        /// <unmanaged-short>InputFrameFormat</unmanaged-short>
        public SharpDX.Direct3D11.VideoFrameFormat InputFrameFormat;
        /// <summary>
        /// <dd> <p>The frame rate of the input video stream, specified as a <strong><see cref = "SharpDX.DXGI.Rational"/></strong> structure. </p> </dd>
        /// </summary>
        /// <doc-id>hh447652</doc-id>
        /// <unmanaged>InputFrameRate</unmanaged>
        /// <unmanaged-short>InputFrameRate</unmanaged-short>
        public SharpDX.DXGI.Rational InputFrameRate;
        /// <summary>
        /// <dd> <p>The width of the input frames, in pixels.</p> </dd>
        /// </summary>
        /// <doc-id>hh447652</doc-id>
        /// <unmanaged>InputWidth</unmanaged>
        /// <unmanaged-short>InputWidth</unmanaged-short>
        public System.Int32 InputWidth;
        /// <summary>
        /// <dd> <p>The height of the input frames, in pixels.</p> </dd>
        /// </summary>
        /// <doc-id>hh447652</doc-id>
        /// <unmanaged>InputHeight</unmanaged>
        /// <unmanaged-short>InputHeight</unmanaged-short>
        public System.Int32 InputHeight;
        /// <summary>
        /// <dd> <p>The frame rate of the output video stream, specified as a <strong><see cref = "SharpDX.DXGI.Rational"/></strong> structure. </p> </dd>
        /// </summary>
        /// <doc-id>hh447652</doc-id>
        /// <unmanaged>OutputFrameRate</unmanaged>
        /// <unmanaged-short>OutputFrameRate</unmanaged-short>
        public SharpDX.DXGI.Rational OutputFrameRate;
        /// <summary>
        /// <dd> <p>The width of the output frames, in pixels. </p> </dd>
        /// </summary>
        /// <doc-id>hh447652</doc-id>
        /// <unmanaged>OutputWidth</unmanaged>
        /// <unmanaged-short>OutputWidth</unmanaged-short>
        public System.Int32 OutputWidth;
        /// <summary>
        /// <dd> <p>The height of the output frames, in pixels.</p> </dd>
        /// </summary>
        /// <doc-id>hh447652</doc-id>
        /// <unmanaged>OutputHeight</unmanaged>
        /// <unmanaged-short>OutputHeight</unmanaged-short>
        public System.Int32 OutputHeight;
        /// <summary>
        /// <dd> <p>A member of the <strong><see cref = "SharpDX.Direct3D11.VideoUsage"/></strong> enumeration that describes how the video processor will be used. The value indicates the desired trade-off between speed and video quality. The driver uses this flag as a hint when it creates the video processor.</p> </dd>
        /// </summary>
        /// <doc-id>hh447652</doc-id>
        /// <unmanaged>Usage</unmanaged>
        /// <unmanaged-short>Usage</unmanaged-short>
        public SharpDX.Direct3D11.VideoUsage Usage;
    }

    /// <summary>
    /// <p>Specifies a custom rate for frame-rate conversion or inverse telecine (IVTC). </p>
    /// </summary>
    /// <remarks>
    /// <p>The <strong>CustomRate</strong> member gives the rate conversion factor, while the remaining members define the pattern of input and output samples.</p>
    /// </remarks>
    /// <doc-id>hh447653</doc-id>
    /// <unmanaged>D3D11_VIDEO_PROCESSOR_CUSTOM_RATE</unmanaged>
    /// <unmanaged-short>D3D11_VIDEO_PROCESSOR_CUSTOM_RATE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoProcessorCustomRate
    {
        /// <summary>
        /// <dd> <p>The ratio of the output frame rate to the input frame rate, expressed as a <strong><see cref = "SharpDX.DXGI.Rational"/></strong> structure that holds a rational number. </p> </dd>
        /// </summary>
        /// <doc-id>hh447653</doc-id>
        /// <unmanaged>CustomRate</unmanaged>
        /// <unmanaged-short>CustomRate</unmanaged-short>
        public SharpDX.DXGI.Rational CustomRate;
        /// <summary>
        /// <dd> <p>The number of output frames that will be generated for every <em>N</em> input samples, where <em>N</em> = <strong>InputFramesOrFields</strong>. </p> </dd>
        /// </summary>
        /// <doc-id>hh447653</doc-id>
        /// <unmanaged>OutputFrames</unmanaged>
        /// <unmanaged-short>OutputFrames</unmanaged-short>
        public System.Int32 OutputFrames;
        /// <summary>
        /// <dd> <p>If <strong>TRUE</strong>, the input stream must be interlaced. Otherwise, the input stream must be progressive. </p> </dd>
        /// </summary>
        /// <doc-id>hh447653</doc-id>
        /// <unmanaged>InputInterlaced</unmanaged>
        /// <unmanaged-short>InputInterlaced</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool InputInterlaced;
        /// <summary>
        /// <dd> <p>The number of input fields or frames for every <em>N</em> output frames that will be generated, where <em>N</em> = <strong>OutputFrames</strong>. </p> </dd>
        /// </summary>
        /// <doc-id>hh447653</doc-id>
        /// <unmanaged>InputFramesOrFields</unmanaged>
        /// <unmanaged-short>InputFramesOrFields</unmanaged-short>
        public System.Int32 InputFramesOrFields;
    }

    /// <summary>
    /// <p>Defines the range of supported values for an image filter. </p>
    /// </summary>
    /// <remarks>
    /// <p>The multiplier enables the filter range to have a fractional step value.</p><p>For example, a hue filter might have an actual range of [?180.0 ... +180.0] with a step size of 0.25. The device would report the following range and multiplier:</p><ul> <li>Minimum: ?720</li> <li>Maximum: +720</li> <li>Multiplier: 0.25</li> </ul><p>In this case,  a filter value of 2 would be interpreted by the device as 0.50 (or 2 ? 0.25).</p><p>The device should use  a multiplier that can be represented exactly as a base-2 fraction.</p>
    /// </remarks>
    /// <doc-id>hh447657</doc-id>
    /// <unmanaged>D3D11_VIDEO_PROCESSOR_FILTER_RANGE</unmanaged>
    /// <unmanaged-short>D3D11_VIDEO_PROCESSOR_FILTER_RANGE</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoProcessorFilterRange
    {
        /// <summary>
        /// <dd> <p>The minimum value of the filter. </p> </dd>
        /// </summary>
        /// <doc-id>hh447657</doc-id>
        /// <unmanaged>Minimum</unmanaged>
        /// <unmanaged-short>Minimum</unmanaged-short>
        public System.Int32 Minimum;
        /// <summary>
        /// <dd> <p>The maximum value of the filter. </p> </dd>
        /// </summary>
        /// <doc-id>hh447657</doc-id>
        /// <unmanaged>Maximum</unmanaged>
        /// <unmanaged-short>Maximum</unmanaged-short>
        public System.Int32 Maximum;
        /// <summary>
        /// <dd> <p>The default value of the filter. </p> </dd>
        /// </summary>
        /// <doc-id>hh447657</doc-id>
        /// <unmanaged>Default</unmanaged>
        /// <unmanaged-short>Default</unmanaged-short>
        public System.Int32 Default;
        /// <summary>
        /// <dd> <p>A multiplier. Use the following formula to translate the filter setting into the actual filter value: <em>Actual Value</em> = <em>Set Value</em>???<em>Multiplier</em>.</p> </dd>
        /// </summary>
        /// <doc-id>hh447657</doc-id>
        /// <unmanaged>Multiplier</unmanaged>
        /// <unmanaged-short>Multiplier</unmanaged-short>
        public System.Single Multiplier;
    }

    /// <summary>
    /// <p>Describes a video processor input view.</p>
    /// </summary>
    /// <doc-id>hh447660</doc-id>
    /// <unmanaged>D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC</unmanaged>
    /// <unmanaged-short>D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoProcessorInputViewDescription
    {
        /// <summary>
        /// <dd> <p>The surface format. If zero, the driver uses the DXGI format that was used to create the resource. If you are using feature level 9, the value must be zero.</p> </dd>
        /// </summary>
        /// <doc-id>hh447660</doc-id>
        /// <unmanaged>FourCC</unmanaged>
        /// <unmanaged-short>FourCC</unmanaged-short>
        public System.Int32 FourCC;
        /// <summary>
        /// <dd> <p>The resource type of the view, specified as a member of the <strong><see cref = "SharpDX.Direct3D11.VpivDimension"/></strong> enumeration.</p> </dd>
        /// </summary>
        /// <doc-id>hh447660</doc-id>
        /// <unmanaged>ViewDimension</unmanaged>
        /// <unmanaged-short>ViewDimension</unmanaged-short>
        public SharpDX.Direct3D11.VpivDimension Dimension;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.Texture2DVpiv"/></strong> structure that identifies the texture resource.</p> </dd>
        /// </summary>
        /// <doc-id>hh447660</doc-id>
        /// <unmanaged>Texture2D</unmanaged>
        /// <unmanaged-short>Texture2D</unmanaged-short>
        public SharpDX.Direct3D11.Texture2DVpiv Texture2D;
    }

    /// <summary>
    /// <p>Describes a video processor output view.</p>
    /// </summary>
    /// <doc-id>hh447663</doc-id>
    /// <unmanaged>D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC</unmanaged>
    /// <unmanaged-short>D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoProcessorOutputViewDescription
    {
        /// <summary>
        /// <dd> <p>The resource type of the view, specified as a member of the <strong><see cref = "SharpDX.Direct3D11.VpovDimension"/></strong> enumeration.</p> </dd>
        /// </summary>
        /// <doc-id>hh447663</doc-id>
        /// <unmanaged>ViewDimension</unmanaged>
        /// <unmanaged-short>ViewDimension</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public SharpDX.Direct3D11.VpovDimension Dimension;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.Texture2DVpov"/></strong> structure that identifies the texture resource for the output view. </p> <p>Use this member of the union when <strong>ViewDimension</strong> equals <strong>D3D11_VPOV_DIMENSION_TEXTURE2D</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>hh447663</doc-id>
        /// <unmanaged>Texture2D</unmanaged>
        /// <unmanaged-short>Texture2D</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(4)]
        public SharpDX.Direct3D11.Texture2DVpov Texture2D;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D11.Texture2DArrayVpov"/></strong> structure that identifies the texture array for the output view. </p> <p>Use this member of the union when <strong>ViewDimension</strong> equals <strong>D3D11_VPOV_DIMENSION_TEXTURE2DARRAY</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>hh447663</doc-id>
        /// <unmanaged>Texture2DArray</unmanaged>
        /// <unmanaged-short>Texture2DArray</unmanaged-short>
        [System.Runtime.InteropServices.FieldOffset(4)]
        public SharpDX.Direct3D11.Texture2DArrayVpov Texture2DArray;
    }

    /// <summary>
    /// <p>Defines a group of video processor capabilities that are associated with frame-rate conversion, including deinterlacing and inverse telecine.</p>
    /// </summary>
    /// <doc-id>hh447665</doc-id>
    /// <unmanaged>D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS</unmanaged>
    /// <unmanaged-short>D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoProcessorRateConversionCaps
    {
        /// <summary>
        /// <dd> <p>The number of past reference frames required to perform the optimal video processing. </p> </dd>
        /// </summary>
        /// <doc-id>hh447665</doc-id>
        /// <unmanaged>PastFrames</unmanaged>
        /// <unmanaged-short>PastFrames</unmanaged-short>
        public System.Int32 PastFrames;
        /// <summary>
        /// <dd> <p>The number of future reference frames required to perform the optimal video processing. </p> </dd>
        /// </summary>
        /// <doc-id>hh447665</doc-id>
        /// <unmanaged>FutureFrames</unmanaged>
        /// <unmanaged-short>FutureFrames</unmanaged-short>
        public System.Int32 FutureFrames;
        /// <summary>
        /// <dd> <p>A bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref = "SharpDX.Direct3D11.VideoProcessorProcessorCaps"/></strong> enumeration. </p> </dd>
        /// </summary>
        /// <doc-id>hh447665</doc-id>
        /// <unmanaged>ProcessorCaps</unmanaged>
        /// <unmanaged-short>ProcessorCaps</unmanaged-short>
        public System.Int32 ProcessorCaps;
        /// <summary>
        /// <dd> <p>A bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref = "SharpDX.Direct3D11.VideoProcessorItelecineCaps"/></strong> enumeration. </p> </dd>
        /// </summary>
        /// <doc-id>hh447665</doc-id>
        /// <unmanaged>ITelecineCaps</unmanaged>
        /// <unmanaged-short>ITelecineCaps</unmanaged-short>
        public System.Int32 ITelecineCaps;
        /// <summary>
        /// <dd> <p>The number of custom frame rates that the driver supports. To get the list of custom frame rates, call the <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCustomRate</strong> method.</p> </dd>
        /// </summary>
        /// <doc-id>hh447665</doc-id>
        /// <unmanaged>CustomRateCount</unmanaged>
        /// <unmanaged-short>CustomRateCount</unmanaged-short>
        public System.Int32 CustomRateCount;
    }

    /// <summary>
    /// <p>Contains stream-level data for the <strong>ID3D11VideoContext::VideoProcessorBlt</strong> method. </p>
    /// </summary>
    /// <remarks>
    /// <p>If the stereo 3D format is <strong>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_SEPARATE</strong>, the <strong>ppPastSurfaces</strong>, <strong>pInputSurface</strong>, and <strong>ppFutureSurfaces</strong> members contain the left view.</p>
    /// </remarks>
    /// <doc-id>hh447670</doc-id>
    /// <unmanaged>D3D11_VIDEO_PROCESSOR_STREAM</unmanaged>
    /// <unmanaged-short>D3D11_VIDEO_PROCESSOR_STREAM</unmanaged-short>
    public partial struct VideoProcessorStream
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447670</doc-id>
        /// <unmanaged>Enable</unmanaged>
        /// <unmanaged-short>Enable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool Enable;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447670</doc-id>
        /// <unmanaged>OutputIndex</unmanaged>
        /// <unmanaged-short>OutputIndex</unmanaged-short>
        public System.Int32 OutputIndex;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447670</doc-id>
        /// <unmanaged>InputFrameOrField</unmanaged>
        /// <unmanaged-short>InputFrameOrField</unmanaged-short>
        public System.Int32 InputFrameOrField;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447670</doc-id>
        /// <unmanaged>PastFrames</unmanaged>
        /// <unmanaged-short>PastFrames</unmanaged-short>
        public System.Int32 PastFrames;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447670</doc-id>
        /// <unmanaged>FutureFrames</unmanaged>
        /// <unmanaged-short>FutureFrames</unmanaged-short>
        public System.Int32 FutureFrames;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447670</doc-id>
        /// <unmanaged>ppPastSurfaces</unmanaged>
        /// <unmanaged-short>ppPastSurfaces</unmanaged-short>
        public SharpDX.Direct3D11.VideoProcessorInputView PpPastSurfaces;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447670</doc-id>
        /// <unmanaged>pInputSurface</unmanaged>
        /// <unmanaged-short>pInputSurface</unmanaged-short>
        public SharpDX.Direct3D11.VideoProcessorInputView PInputSurface;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447670</doc-id>
        /// <unmanaged>ppFutureSurfaces</unmanaged>
        /// <unmanaged-short>ppFutureSurfaces</unmanaged-short>
        public SharpDX.Direct3D11.VideoProcessorInputView PpFutureSurfaces;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447670</doc-id>
        /// <unmanaged>ppPastSurfacesRight</unmanaged>
        /// <unmanaged-short>ppPastSurfacesRight</unmanaged-short>
        public SharpDX.Direct3D11.VideoProcessorInputView PpPastSurfacesRight;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447670</doc-id>
        /// <unmanaged>pInputSurfaceRight</unmanaged>
        /// <unmanaged-short>pInputSurfaceRight</unmanaged-short>
        public SharpDX.Direct3D11.VideoProcessorInputView PInputSurfaceRight;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>hh447670</doc-id>
        /// <unmanaged>ppFutureSurfacesRight</unmanaged>
        /// <unmanaged-short>ppFutureSurfacesRight</unmanaged-short>
        public SharpDX.Direct3D11.VideoProcessorInputView PpFutureSurfacesRight;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.Mathematics.Interop.RawBool Enable;
            public System.Int32 OutputIndex;
            public System.Int32 InputFrameOrField;
            public System.Int32 PastFrames;
            public System.Int32 FutureFrames;
            public System.IntPtr PpPastSurfaces;
            public System.IntPtr PInputSurface;
            public System.IntPtr PpFutureSurfaces;
            public System.IntPtr PpPastSurfacesRight;
            public System.IntPtr PInputSurfaceRight;
            public System.IntPtr PpFutureSurfacesRight;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Enable = @ref.Enable;
            OutputIndex = @ref.OutputIndex;
            InputFrameOrField = @ref.InputFrameOrField;
            PastFrames = @ref.PastFrames;
            FutureFrames = @ref.FutureFrames;
            if (@ref.PpPastSurfaces != System.IntPtr.Zero)
                PpPastSurfaces = new SharpDX.Direct3D11.VideoProcessorInputView(@ref.PpPastSurfaces);
            else
                PpPastSurfaces = null;
            if (@ref.PInputSurface != System.IntPtr.Zero)
                PInputSurface = new SharpDX.Direct3D11.VideoProcessorInputView(@ref.PInputSurface);
            else
                PInputSurface = null;
            if (@ref.PpFutureSurfaces != System.IntPtr.Zero)
                PpFutureSurfaces = new SharpDX.Direct3D11.VideoProcessorInputView(@ref.PpFutureSurfaces);
            else
                PpFutureSurfaces = null;
            if (@ref.PpPastSurfacesRight != System.IntPtr.Zero)
                PpPastSurfacesRight = new SharpDX.Direct3D11.VideoProcessorInputView(@ref.PpPastSurfacesRight);
            else
                PpPastSurfacesRight = null;
            if (@ref.PInputSurfaceRight != System.IntPtr.Zero)
                PInputSurfaceRight = new SharpDX.Direct3D11.VideoProcessorInputView(@ref.PInputSurfaceRight);
            else
                PInputSurfaceRight = null;
            if (@ref.PpFutureSurfacesRight != System.IntPtr.Zero)
                PpFutureSurfacesRight = new SharpDX.Direct3D11.VideoProcessorInputView(@ref.PpFutureSurfacesRight);
            else
                PpFutureSurfacesRight = null;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Enable = Enable;
            @ref.OutputIndex = OutputIndex;
            @ref.InputFrameOrField = InputFrameOrField;
            @ref.PastFrames = PastFrames;
            @ref.FutureFrames = FutureFrames;
            @ref.PpPastSurfaces = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessorInputView>(PpPastSurfaces);
            @ref.PInputSurface = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessorInputView>(PInputSurface);
            @ref.PpFutureSurfaces = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessorInputView>(PpFutureSurfaces);
            @ref.PpPastSurfacesRight = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessorInputView>(PpPastSurfacesRight);
            @ref.PInputSurfaceRight = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessorInputView>(PInputSurfaceRight);
            @ref.PpFutureSurfacesRight = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessorInputView>(PpFutureSurfacesRight);
        }
    }

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Provides information about the input streams passed into the <strong>ID3DVideoContext1::VideoProcessorGetBehaviorHints</strong> method.</p>
    /// </summary>
    /// <doc-id>dn894123</doc-id>
    /// <unmanaged>D3D11_VIDEO_PROCESSOR_STREAM_BEHAVIOR_HINT</unmanaged>
    /// <unmanaged-short>D3D11_VIDEO_PROCESSOR_STREAM_BEHAVIOR_HINT</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoProcessorStreamBehaviorHint
    {
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn894123</doc-id>
        /// <unmanaged>Enable</unmanaged>
        /// <unmanaged-short>Enable</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool Enable;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn894123</doc-id>
        /// <unmanaged>Width</unmanaged>
        /// <unmanaged-short>Width</unmanaged-short>
        public System.Int32 Width;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn894123</doc-id>
        /// <unmanaged>Height</unmanaged>
        /// <unmanaged-short>Height</unmanaged-short>
        public System.Int32 Height;
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <doc-id>dn894123</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        public SharpDX.DXGI.Format Format;
    }

    /// <summary>
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Describes a video sample.</p>
    /// </summary>
    /// <doc-id>dn894124</doc-id>
    /// <unmanaged>D3D11_VIDEO_SAMPLE_DESC</unmanaged>
    /// <unmanaged-short>D3D11_VIDEO_SAMPLE_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct VideoSampleDescription
    {
        /// <summary>
        /// <dd> <p>The width of the video sample.</p> </dd>
        /// </summary>
        /// <doc-id>dn894124</doc-id>
        /// <unmanaged>Width</unmanaged>
        /// <unmanaged-short>Width</unmanaged-short>
        public System.Int32 Width;
        /// <summary>
        /// <dd> <p>The height of the video sample.</p> </dd>
        /// </summary>
        /// <doc-id>dn894124</doc-id>
        /// <unmanaged>Height</unmanaged>
        /// <unmanaged-short>Height</unmanaged-short>
        public System.Int32 Height;
        /// <summary>
        /// <dd> <p>The format of the video sample.</p> </dd>
        /// </summary>
        /// <doc-id>dn894124</doc-id>
        /// <unmanaged>Format</unmanaged>
        /// <unmanaged-short>Format</unmanaged-short>
        public SharpDX.DXGI.Format Format;
        /// <summary>
        /// <dd> <p>The colorspace of the sample.</p> </dd>
        /// </summary>
        /// <doc-id>dn894124</doc-id>
        /// <unmanaged>ColorSpace</unmanaged>
        /// <unmanaged-short>ColorSpace</unmanaged-short>
        public SharpDX.DXGI.ColorSpaceType ColorSpace;
    }
}