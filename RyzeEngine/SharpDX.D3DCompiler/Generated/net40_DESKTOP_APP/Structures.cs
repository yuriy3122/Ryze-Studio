// <auto-generated/>

namespace SharpDX.D3DCompiler
{
    /// <summary>
    /// <p>Describes a shader constant-buffer.</p>
    /// </summary>
    /// <remarks>
    /// <p>Constants are supplied to shaders in a shader-constant buffer. Get the description of a shader-constant-buffer by calling <strong>ID3D11ShaderReflectionConstantBuffer::GetDesc</strong>.</p>
    /// </remarks>
    /// <doc-id>ff476208</doc-id>
    /// <unmanaged>D3D11_SHADER_BUFFER_DESC</unmanaged>
    /// <unmanaged-short>D3D11_SHADER_BUFFER_DESC</unmanaged-short>
    public partial struct ConstantBufferDescription
    {
        /// <summary>
        /// <dd> <p>The name of the buffer.</p> </dd>
        /// </summary>
        /// <doc-id>ff476208</doc-id>
        /// <unmanaged>Name</unmanaged>
        /// <unmanaged-short>Name</unmanaged-short>
        public System.String Name;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.D3DCompiler.ConstantBufferType"/></strong>-typed value that indicates the intended use of the constant data.</p> </dd>
        /// </summary>
        /// <doc-id>ff476208</doc-id>
        /// <unmanaged>Type</unmanaged>
        /// <unmanaged-short>Type</unmanaged-short>
        public SharpDX.D3DCompiler.ConstantBufferType Type;
        /// <summary>
        /// <dd> <p>The number of unique variables.</p> </dd>
        /// </summary>
        /// <doc-id>ff476208</doc-id>
        /// <unmanaged>Variables</unmanaged>
        /// <unmanaged-short>Variables</unmanaged-short>
        public System.Int32 VariableCount;
        /// <summary>
        /// <dd> <p>Buffer size (in bytes).</p> </dd>
        /// </summary>
        /// <doc-id>ff476208</doc-id>
        /// <unmanaged>Size</unmanaged>
        /// <unmanaged-short>Size</unmanaged-short>
        public System.Int32 Size;
        /// <summary>
        /// <dd> <p>A combination of <strong><see cref = "SharpDX.D3DCompiler.ConstantBufferFlags"/></strong>-typed values that are combined by using a bitwise OR operation. The resulting value specifies properties for the shader constant-buffer.</p> </dd>
        /// </summary>
        /// <doc-id>ff476208</doc-id>
        /// <unmanaged>uFlags</unmanaged>
        /// <unmanaged-short>uFlags</unmanaged-short>
        public SharpDX.D3DCompiler.ConstantBufferFlags Flags;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr Name;
            public SharpDX.D3DCompiler.ConstantBufferType Type;
            public System.Int32 VariableCount;
            public System.Int32 Size;
            public SharpDX.D3DCompiler.ConstantBufferFlags Flags;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.Name);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Name = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(@ref.Name);
            Type = @ref.Type;
            VariableCount = @ref.VariableCount;
            Size = @ref.Size;
            Flags = @ref.Flags;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(Name);
            @ref.Type = Type;
            @ref.VariableCount = VariableCount;
            @ref.Size = Size;
            @ref.Flags = Flags;
        }
    }

    /// <summary>
    /// <p>Describes a function.</p>
    /// </summary>
    /// <doc-id>dn280416</doc-id>
    /// <unmanaged>D3D11_FUNCTION_DESC</unmanaged>
    /// <unmanaged-short>D3D11_FUNCTION_DESC</unmanaged-short>
    public partial struct FunctionDescription
    {
        /// <summary>
        /// <dd> <p>The shader version.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>Version</unmanaged>
        /// <unmanaged-short>Version</unmanaged-short>
        public System.Int32 Version;
        /// <summary>
        /// <dd> <p>The name of the originator of the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>Creator</unmanaged>
        /// <unmanaged-short>Creator</unmanaged-short>
        public System.String Creator;
        /// <summary>
        /// <dd> <p>A combination of <strong>D3DCOMPILE Constants</strong> that are combined by using a bitwise OR operation. The resulting value specifies shader compilation and parsing.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        public System.Int32 Flags;
        /// <summary>
        /// <dd> <p>The number of constant buffers for the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>ConstantBuffers</unmanaged>
        /// <unmanaged-short>ConstantBuffers</unmanaged-short>
        public System.Int32 ConstantBuffers;
        /// <summary>
        /// <dd> <p>The number of bound resources for the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>BoundResources</unmanaged>
        /// <unmanaged-short>BoundResources</unmanaged-short>
        public System.Int32 BoundResources;
        /// <summary>
        /// <dd> <p>The number of emitted instructions for the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>InstructionCount</unmanaged>
        /// <unmanaged-short>InstructionCount</unmanaged-short>
        public System.Int32 InstructionCount;
        /// <summary>
        /// <dd> <p>The number of temporary registers used by the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>TempRegisterCount</unmanaged>
        /// <unmanaged-short>TempRegisterCount</unmanaged-short>
        public System.Int32 TempRegisterCount;
        /// <summary>
        /// <dd> <p>The number of temporary arrays used by the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>TempArrayCount</unmanaged>
        /// <unmanaged-short>TempArrayCount</unmanaged-short>
        public System.Int32 TempArrayCount;
        /// <summary>
        /// <dd> <p>The number of constant defines for the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>DefCount</unmanaged>
        /// <unmanaged-short>DefCount</unmanaged-short>
        public System.Int32 DefCount;
        /// <summary>
        /// <dd> <p>The number of declarations (input + output) for the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>DclCount</unmanaged>
        /// <unmanaged-short>DclCount</unmanaged-short>
        public System.Int32 DclCount;
        /// <summary>
        /// <dd> <p>The number of non-categorized texture instructions for the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>TextureNormalInstructions</unmanaged>
        /// <unmanaged-short>TextureNormalInstructions</unmanaged-short>
        public System.Int32 TextureNormalInstructions;
        /// <summary>
        /// <dd> <p>The number of texture load instructions for the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>TextureLoadInstructions</unmanaged>
        /// <unmanaged-short>TextureLoadInstructions</unmanaged-short>
        public System.Int32 TextureLoadInstructions;
        /// <summary>
        /// <dd> <p>The number of texture comparison instructions for the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>TextureCompInstructions</unmanaged>
        /// <unmanaged-short>TextureCompInstructions</unmanaged-short>
        public System.Int32 TextureCompInstructions;
        /// <summary>
        /// <dd> <p>The number of texture bias instructions for the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>TextureBiasInstructions</unmanaged>
        /// <unmanaged-short>TextureBiasInstructions</unmanaged-short>
        public System.Int32 TextureBiasInstructions;
        /// <summary>
        /// <dd> <p>The number of texture gradient instructions for the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>TextureGradientInstructions</unmanaged>
        /// <unmanaged-short>TextureGradientInstructions</unmanaged-short>
        public System.Int32 TextureGradientInstructions;
        /// <summary>
        /// <dd> <p>The number of floating point arithmetic instructions used by the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>FloatInstructionCount</unmanaged>
        /// <unmanaged-short>FloatInstructionCount</unmanaged-short>
        public System.Int32 FloatInstructionCount;
        /// <summary>
        /// <dd> <p>The number of signed integer arithmetic instructions used by the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>IntInstructionCount</unmanaged>
        /// <unmanaged-short>IntInstructionCount</unmanaged-short>
        public System.Int32 IntInstructionCount;
        /// <summary>
        /// <dd> <p>The number of unsigned integer arithmetic instructions used by the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>UintInstructionCount</unmanaged>
        /// <unmanaged-short>UintInstructionCount</unmanaged-short>
        public System.Int32 UintInstructionCount;
        /// <summary>
        /// <dd> <p>The number of static flow control instructions used by the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>StaticFlowControlCount</unmanaged>
        /// <unmanaged-short>StaticFlowControlCount</unmanaged-short>
        public System.Int32 StaticFlowControlCount;
        /// <summary>
        /// <dd> <p>The number of dynamic flow control instructions used by the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>DynamicFlowControlCount</unmanaged>
        /// <unmanaged-short>DynamicFlowControlCount</unmanaged-short>
        public System.Int32 DynamicFlowControlCount;
        /// <summary>
        /// <dd> <p>The number of macro instructions used by the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>MacroInstructionCount</unmanaged>
        /// <unmanaged-short>MacroInstructionCount</unmanaged-short>
        public System.Int32 MacroInstructionCount;
        /// <summary>
        /// <dd> <p>The number of array instructions used by the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>ArrayInstructionCount</unmanaged>
        /// <unmanaged-short>ArrayInstructionCount</unmanaged-short>
        public System.Int32 ArrayInstructionCount;
        /// <summary>
        /// <dd> <p>The number of mov instructions used by the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>MovInstructionCount</unmanaged>
        /// <unmanaged-short>MovInstructionCount</unmanaged-short>
        public System.Int32 MovInstructionCount;
        /// <summary>
        /// <dd> <p>The number of movc instructions used by the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>MovcInstructionCount</unmanaged>
        /// <unmanaged-short>MovcInstructionCount</unmanaged-short>
        public System.Int32 MovcInstructionCount;
        /// <summary>
        /// <dd> <p>The number of type conversion instructions used by the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>ConversionInstructionCount</unmanaged>
        /// <unmanaged-short>ConversionInstructionCount</unmanaged-short>
        public System.Int32 ConversionInstructionCount;
        /// <summary>
        /// <dd> <p>The number of bitwise arithmetic instructions used by the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>BitwiseInstructionCount</unmanaged>
        /// <unmanaged-short>BitwiseInstructionCount</unmanaged-short>
        public System.Int32 BitwiseInstructionCount;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D.FeatureLevel"/></strong>-typed value that specifies the minimum Direct3D feature level target of the function byte code.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>MinFeatureLevel</unmanaged>
        /// <unmanaged-short>MinFeatureLevel</unmanaged-short>
        public SharpDX.Direct3D.FeatureLevel MinFeatureLevel;
        /// <summary>
        /// <dd> <p>A value that contains a combination of one or more shader requirements flags; each flag specifies a requirement of the shader. A default value of 0 means there are no requirements. For a list of values, see <strong>ID3D11ShaderReflection::GetRequiresFlags</strong>. </p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>RequiredFeatureFlags</unmanaged>
        /// <unmanaged-short>RequiredFeatureFlags</unmanaged-short>
        public System.Int64 RequiredFeatureFlags;
        /// <summary>
        /// <dd> <p>The name of the function.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>Name</unmanaged>
        /// <unmanaged-short>Name</unmanaged-short>
        public System.String Name;
        /// <summary>
        /// <dd> <p>The number of logical parameters in the function signature, not including the return value.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>FunctionParameterCount</unmanaged>
        /// <unmanaged-short>FunctionParameterCount</unmanaged-short>
        public System.Int32 FunctionParameterCount;
        /// <summary>
        /// <dd> <p>Indicates whether the function returns a value. <strong>TRUE</strong> indicates it returns a value; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong> (it is a subroutine).</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>HasReturn</unmanaged>
        /// <unmanaged-short>HasReturn</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool HasReturn;
        /// <summary>
        /// <dd> <p>Indicates whether there is a Direct3D 10Level9 vertex shader blob. <strong>TRUE</strong> indicates there is a 10Level9 vertex shader blob; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>Has10Level9VertexShader</unmanaged>
        /// <unmanaged-short>Has10Level9VertexShader</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool Has10Level9VertexShader;
        /// <summary>
        /// <dd> <p>Indicates whether there is a Direct3D 10Level9 pixel shader blob. <strong>TRUE</strong> indicates there is a 10Level9 pixel shader blob; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd>
        /// </summary>
        /// <doc-id>dn280416</doc-id>
        /// <unmanaged>Has10Level9PixelShader</unmanaged>
        /// <unmanaged-short>Has10Level9PixelShader</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool Has10Level9PixelShader;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Int32 Version;
            public System.IntPtr Creator;
            public System.Int32 Flags;
            public System.Int32 ConstantBuffers;
            public System.Int32 BoundResources;
            public System.Int32 InstructionCount;
            public System.Int32 TempRegisterCount;
            public System.Int32 TempArrayCount;
            public System.Int32 DefCount;
            public System.Int32 DclCount;
            public System.Int32 TextureNormalInstructions;
            public System.Int32 TextureLoadInstructions;
            public System.Int32 TextureCompInstructions;
            public System.Int32 TextureBiasInstructions;
            public System.Int32 TextureGradientInstructions;
            public System.Int32 FloatInstructionCount;
            public System.Int32 IntInstructionCount;
            public System.Int32 UintInstructionCount;
            public System.Int32 StaticFlowControlCount;
            public System.Int32 DynamicFlowControlCount;
            public System.Int32 MacroInstructionCount;
            public System.Int32 ArrayInstructionCount;
            public System.Int32 MovInstructionCount;
            public System.Int32 MovcInstructionCount;
            public System.Int32 ConversionInstructionCount;
            public System.Int32 BitwiseInstructionCount;
            public SharpDX.Direct3D.FeatureLevel MinFeatureLevel;
            public System.Int64 RequiredFeatureFlags;
            public System.IntPtr Name;
            public System.Int32 FunctionParameterCount;
            public SharpDX.Mathematics.Interop.RawBool HasReturn;
            public SharpDX.Mathematics.Interop.RawBool Has10Level9VertexShader;
            public SharpDX.Mathematics.Interop.RawBool Has10Level9PixelShader;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.Creator);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.Name);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Version = @ref.Version;
            Creator = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(@ref.Creator);
            Flags = @ref.Flags;
            ConstantBuffers = @ref.ConstantBuffers;
            BoundResources = @ref.BoundResources;
            InstructionCount = @ref.InstructionCount;
            TempRegisterCount = @ref.TempRegisterCount;
            TempArrayCount = @ref.TempArrayCount;
            DefCount = @ref.DefCount;
            DclCount = @ref.DclCount;
            TextureNormalInstructions = @ref.TextureNormalInstructions;
            TextureLoadInstructions = @ref.TextureLoadInstructions;
            TextureCompInstructions = @ref.TextureCompInstructions;
            TextureBiasInstructions = @ref.TextureBiasInstructions;
            TextureGradientInstructions = @ref.TextureGradientInstructions;
            FloatInstructionCount = @ref.FloatInstructionCount;
            IntInstructionCount = @ref.IntInstructionCount;
            UintInstructionCount = @ref.UintInstructionCount;
            StaticFlowControlCount = @ref.StaticFlowControlCount;
            DynamicFlowControlCount = @ref.DynamicFlowControlCount;
            MacroInstructionCount = @ref.MacroInstructionCount;
            ArrayInstructionCount = @ref.ArrayInstructionCount;
            MovInstructionCount = @ref.MovInstructionCount;
            MovcInstructionCount = @ref.MovcInstructionCount;
            ConversionInstructionCount = @ref.ConversionInstructionCount;
            BitwiseInstructionCount = @ref.BitwiseInstructionCount;
            MinFeatureLevel = @ref.MinFeatureLevel;
            RequiredFeatureFlags = @ref.RequiredFeatureFlags;
            Name = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(@ref.Name);
            FunctionParameterCount = @ref.FunctionParameterCount;
            HasReturn = @ref.HasReturn;
            Has10Level9VertexShader = @ref.Has10Level9VertexShader;
            Has10Level9PixelShader = @ref.Has10Level9PixelShader;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Version = Version;
            @ref.Creator = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(Creator);
            @ref.Flags = Flags;
            @ref.ConstantBuffers = ConstantBuffers;
            @ref.BoundResources = BoundResources;
            @ref.InstructionCount = InstructionCount;
            @ref.TempRegisterCount = TempRegisterCount;
            @ref.TempArrayCount = TempArrayCount;
            @ref.DefCount = DefCount;
            @ref.DclCount = DclCount;
            @ref.TextureNormalInstructions = TextureNormalInstructions;
            @ref.TextureLoadInstructions = TextureLoadInstructions;
            @ref.TextureCompInstructions = TextureCompInstructions;
            @ref.TextureBiasInstructions = TextureBiasInstructions;
            @ref.TextureGradientInstructions = TextureGradientInstructions;
            @ref.FloatInstructionCount = FloatInstructionCount;
            @ref.IntInstructionCount = IntInstructionCount;
            @ref.UintInstructionCount = UintInstructionCount;
            @ref.StaticFlowControlCount = StaticFlowControlCount;
            @ref.DynamicFlowControlCount = DynamicFlowControlCount;
            @ref.MacroInstructionCount = MacroInstructionCount;
            @ref.ArrayInstructionCount = ArrayInstructionCount;
            @ref.MovInstructionCount = MovInstructionCount;
            @ref.MovcInstructionCount = MovcInstructionCount;
            @ref.ConversionInstructionCount = ConversionInstructionCount;
            @ref.BitwiseInstructionCount = BitwiseInstructionCount;
            @ref.MinFeatureLevel = MinFeatureLevel;
            @ref.RequiredFeatureFlags = RequiredFeatureFlags;
            @ref.Name = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(Name);
            @ref.FunctionParameterCount = FunctionParameterCount;
            @ref.HasReturn = HasReturn;
            @ref.Has10Level9VertexShader = Has10Level9VertexShader;
            @ref.Has10Level9PixelShader = Has10Level9PixelShader;
        }
    }

    /// <summary>
    /// <p>Describes how a shader resource is bound to a shader input.</p>
    /// </summary>
    /// <remarks>
    /// <p>Get a shader-input-signature description by calling <strong>ID3D11ShaderReflection::GetResourceBindingDesc</strong> or <strong>ID3D11ShaderReflection::GetResourceBindingDescByName</strong>.</p>
    /// </remarks>
    /// <doc-id>ff476210</doc-id>
    /// <unmanaged>D3D11_SHADER_INPUT_BIND_DESC</unmanaged>
    /// <unmanaged-short>D3D11_SHADER_INPUT_BIND_DESC</unmanaged-short>
    public partial struct InputBindingDescription
    {
        /// <summary>
        /// <dd> <p>Name of the shader resource.</p> </dd>
        /// </summary>
        /// <doc-id>ff476210</doc-id>
        /// <unmanaged>Name</unmanaged>
        /// <unmanaged-short>Name</unmanaged-short>
        public System.String Name;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.D3DCompiler.ShaderInputType"/></strong>-typed value that identifies the type of data in the resource.</p> </dd>
        /// </summary>
        /// <doc-id>ff476210</doc-id>
        /// <unmanaged>Type</unmanaged>
        /// <unmanaged-short>Type</unmanaged-short>
        public SharpDX.D3DCompiler.ShaderInputType Type;
        /// <summary>
        /// <dd> <p>Starting bind point.</p> </dd>
        /// </summary>
        /// <doc-id>ff476210</doc-id>
        /// <unmanaged>BindPoint</unmanaged>
        /// <unmanaged-short>BindPoint</unmanaged-short>
        public System.Int32 BindPoint;
        /// <summary>
        /// <dd> <p>Number of contiguous bind points for arrays.</p> </dd>
        /// </summary>
        /// <doc-id>ff476210</doc-id>
        /// <unmanaged>BindCount</unmanaged>
        /// <unmanaged-short>BindCount</unmanaged-short>
        public System.Int32 BindCount;
        /// <summary>
        /// <dd> <p>A combination of <strong><see cref = "SharpDX.D3DCompiler.ShaderInputFlags"/></strong>-typed values for shader input-parameter options.  </p> </dd>
        /// </summary>
        /// <doc-id>ff476210</doc-id>
        /// <unmanaged>uFlags</unmanaged>
        /// <unmanaged-short>uFlags</unmanaged-short>
        public SharpDX.D3DCompiler.ShaderInputFlags Flags;
        /// <summary>
        /// <dd> <p>If the input is a texture, the <strong><see cref = "SharpDX.D3DCompiler.ResourceReturnType"/></strong>-typed value that identifies the return type.</p> </dd>
        /// </summary>
        /// <doc-id>ff476210</doc-id>
        /// <unmanaged>ReturnType</unmanaged>
        /// <unmanaged-short>ReturnType</unmanaged-short>
        public SharpDX.D3DCompiler.ResourceReturnType ReturnType;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D.ShaderResourceViewDimension"/></strong>-typed value that identifies the dimensions of the bound resource.</p> </dd>
        /// </summary>
        /// <doc-id>ff476210</doc-id>
        /// <unmanaged>Dimension</unmanaged>
        /// <unmanaged-short>Dimension</unmanaged-short>
        public SharpDX.Direct3D.ShaderResourceViewDimension Dimension;
        /// <summary>
        /// <dd> <p>The number of samples for a multisampled texture; when a texture isn't multisampled, the value is set to -1 (0xFFFFFFFF). </p> </dd>
        /// </summary>
        /// <doc-id>ff476210</doc-id>
        /// <unmanaged>NumSamples</unmanaged>
        /// <unmanaged-short>NumSamples</unmanaged-short>
        public System.Int32 NumSamples;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr Name;
            public SharpDX.D3DCompiler.ShaderInputType Type;
            public System.Int32 BindPoint;
            public System.Int32 BindCount;
            public SharpDX.D3DCompiler.ShaderInputFlags Flags;
            public SharpDX.D3DCompiler.ResourceReturnType ReturnType;
            public SharpDX.Direct3D.ShaderResourceViewDimension Dimension;
            public System.Int32 NumSamples;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.Name);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Name = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(@ref.Name);
            Type = @ref.Type;
            BindPoint = @ref.BindPoint;
            BindCount = @ref.BindCount;
            Flags = @ref.Flags;
            ReturnType = @ref.ReturnType;
            Dimension = @ref.Dimension;
            NumSamples = @ref.NumSamples;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(Name);
            @ref.Type = Type;
            @ref.BindPoint = BindPoint;
            @ref.BindCount = BindCount;
            @ref.Flags = Flags;
            @ref.ReturnType = ReturnType;
            @ref.Dimension = Dimension;
            @ref.NumSamples = NumSamples;
        }
    }

    /// <summary>
    /// <p>Describes a library.</p>
    /// </summary>
    /// <doc-id>dn280417</doc-id>
    /// <unmanaged>D3D11_LIBRARY_DESC</unmanaged>
    /// <unmanaged-short>D3D11_LIBRARY_DESC</unmanaged-short>
    public partial struct LibraryDescription
    {
        /// <summary>
        /// <dd> <p>The name of the originator of the library.</p> </dd>
        /// </summary>
        /// <doc-id>dn280417</doc-id>
        /// <unmanaged>Creator</unmanaged>
        /// <unmanaged-short>Creator</unmanaged-short>
        public System.String Creator;
        /// <summary>
        /// <dd> <p>A combination of <strong>D3DCOMPILE Constants</strong> that are combined by using a bitwise OR operation. The resulting value specifies how the compiler compiles.</p> </dd>
        /// </summary>
        /// <doc-id>dn280417</doc-id>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        public System.Int32 Flags;
        /// <summary>
        /// <dd> <p>The number of functions exported from the library.</p> </dd>
        /// </summary>
        /// <doc-id>dn280417</doc-id>
        /// <unmanaged>FunctionCount</unmanaged>
        /// <unmanaged-short>FunctionCount</unmanaged-short>
        public System.Int32 FunctionCount;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr Creator;
            public System.Int32 Flags;
            public System.Int32 FunctionCount;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.Creator);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Creator = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(@ref.Creator);
            Flags = @ref.Flags;
            FunctionCount = @ref.FunctionCount;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Creator = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(Creator);
            @ref.Flags = Flags;
            @ref.FunctionCount = FunctionCount;
        }
    }

    /// <summary>
    /// <p>Describes a function parameter. </p>
    /// </summary>
    /// <remarks>
    /// <p>Get a function-parameter description by calling <strong>ID3D11FunctionParameterReflection::GetDesc</strong>.</p>
    /// </remarks>
    /// <doc-id>dn280419</doc-id>
    /// <unmanaged>D3D11_PARAMETER_DESC</unmanaged>
    /// <unmanaged-short>D3D11_PARAMETER_DESC</unmanaged-short>
    public partial struct ParameterDescription
    {
        /// <summary>
        /// <dd> <p>The name of the function parameter.</p> </dd>
        /// </summary>
        /// <doc-id>dn280419</doc-id>
        /// <unmanaged>Name</unmanaged>
        /// <unmanaged-short>Name</unmanaged-short>
        public System.String Name;
        /// <summary>
        /// <dd> <p>The HLSL semantic that is associated with this function parameter. This name includes the index, for example, SV_Target[n].</p> </dd>
        /// </summary>
        /// <doc-id>dn280419</doc-id>
        /// <unmanaged>SemanticName</unmanaged>
        /// <unmanaged-short>SemanticName</unmanaged-short>
        public System.String SemanticName;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.D3DCompiler.ShaderVariableType"/></strong>-typed value that identifies the variable type for the parameter.</p> </dd>
        /// </summary>
        /// <doc-id>dn280419</doc-id>
        /// <unmanaged>Type</unmanaged>
        /// <unmanaged-short>Type</unmanaged-short>
        public SharpDX.D3DCompiler.ShaderVariableType Type;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.D3DCompiler.ShaderVariableClass"/></strong>-typed value that identifies the variable class for the parameter as one of scalar, vector, matrix, object, and so on.</p> </dd>
        /// </summary>
        /// <doc-id>dn280419</doc-id>
        /// <unmanaged>Class</unmanaged>
        /// <unmanaged-short>Class</unmanaged-short>
        public SharpDX.D3DCompiler.ShaderVariableClass Class;
        /// <summary>
        /// <dd> <p>The number of rows for a matrix parameter.</p> </dd>
        /// </summary>
        /// <doc-id>dn280419</doc-id>
        /// <unmanaged>Rows</unmanaged>
        /// <unmanaged-short>Rows</unmanaged-short>
        public System.Int32 Rows;
        /// <summary>
        /// <dd> <p>The number of columns for a matrix parameter.</p> </dd>
        /// </summary>
        /// <doc-id>dn280419</doc-id>
        /// <unmanaged>Columns</unmanaged>
        /// <unmanaged-short>Columns</unmanaged-short>
        public System.Int32 Columns;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D.InterpolationMode"/></strong>-typed value that identifies the interpolation mode for the parameter.</p> </dd>
        /// </summary>
        /// <doc-id>dn280419</doc-id>
        /// <unmanaged>InterpolationMode</unmanaged>
        /// <unmanaged-short>InterpolationMode</unmanaged-short>
        public SharpDX.Direct3D.InterpolationMode InterpolationMode;
        /// <summary>
        /// <dd> <p>A combination of <strong><see cref = "SharpDX.D3DCompiler.ParameterFlags"/></strong>-typed values that are combined by using a bitwise OR operation. The resulting value specifies semantic flags for the parameter.</p> </dd>
        /// </summary>
        /// <doc-id>dn280419</doc-id>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        public SharpDX.D3DCompiler.ParameterFlags Flags;
        /// <summary>
        /// <dd> <p>The first input register for this parameter.</p> </dd>
        /// </summary>
        /// <doc-id>dn280419</doc-id>
        /// <unmanaged>FirstInRegister</unmanaged>
        /// <unmanaged-short>FirstInRegister</unmanaged-short>
        public System.Int32 FirstInRegister;
        /// <summary>
        /// <dd> <p>The first input register component for this parameter.</p> </dd>
        /// </summary>
        /// <doc-id>dn280419</doc-id>
        /// <unmanaged>FirstInComponent</unmanaged>
        /// <unmanaged-short>FirstInComponent</unmanaged-short>
        public System.Int32 FirstInComponent;
        /// <summary>
        /// <dd> <p>The first output register for this parameter.</p> </dd>
        /// </summary>
        /// <doc-id>dn280419</doc-id>
        /// <unmanaged>FirstOutRegister</unmanaged>
        /// <unmanaged-short>FirstOutRegister</unmanaged-short>
        public System.Int32 FirstOutRegister;
        /// <summary>
        /// <dd> <p>The first output register component for this parameter.</p> </dd>
        /// </summary>
        /// <doc-id>dn280419</doc-id>
        /// <unmanaged>FirstOutComponent</unmanaged>
        /// <unmanaged-short>FirstOutComponent</unmanaged-short>
        public System.Int32 FirstOutComponent;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr Name;
            public System.IntPtr SemanticName;
            public SharpDX.D3DCompiler.ShaderVariableType Type;
            public SharpDX.D3DCompiler.ShaderVariableClass Class;
            public System.Int32 Rows;
            public System.Int32 Columns;
            public SharpDX.Direct3D.InterpolationMode InterpolationMode;
            public SharpDX.D3DCompiler.ParameterFlags Flags;
            public System.Int32 FirstInRegister;
            public System.Int32 FirstInComponent;
            public System.Int32 FirstOutRegister;
            public System.Int32 FirstOutComponent;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.Name);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.SemanticName);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Name = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(@ref.Name);
            SemanticName = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(@ref.SemanticName);
            Type = @ref.Type;
            Class = @ref.Class;
            Rows = @ref.Rows;
            Columns = @ref.Columns;
            InterpolationMode = @ref.InterpolationMode;
            Flags = @ref.Flags;
            FirstInRegister = @ref.FirstInRegister;
            FirstInComponent = @ref.FirstInComponent;
            FirstOutRegister = @ref.FirstOutRegister;
            FirstOutComponent = @ref.FirstOutComponent;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(Name);
            @ref.SemanticName = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(SemanticName);
            @ref.Type = Type;
            @ref.Class = Class;
            @ref.Rows = Rows;
            @ref.Columns = Columns;
            @ref.InterpolationMode = InterpolationMode;
            @ref.Flags = Flags;
            @ref.FirstInRegister = FirstInRegister;
            @ref.FirstInComponent = FirstInComponent;
            @ref.FirstOutRegister = FirstOutRegister;
            @ref.FirstOutComponent = FirstOutComponent;
        }
    }

    /// <summary>
    /// <p>Describes shader data.</p>
    /// </summary>
    /// <remarks>
    /// <p>An array of <strong><see cref = "SharpDX.D3DCompiler.ShaderData"/></strong> structures is passed to <strong>D3DCompressShaders</strong> to compress the shader data into a more compact form.</p>
    /// </remarks>
    /// <doc-id>ff728721</doc-id>
    /// <unmanaged>D3D_SHADER_DATA</unmanaged>
    /// <unmanaged-short>D3D_SHADER_DATA</unmanaged-short>
    internal partial struct ShaderData
    {
        /// <summary>
        /// <dd> <p>A reference to shader data.</p> </dd>
        /// </summary>
        /// <doc-id>ff728721</doc-id>
        /// <unmanaged>pBytecode</unmanaged>
        /// <unmanaged-short>pBytecode</unmanaged-short>
        public System.IntPtr BytecodePtr;
        /// <summary>
        /// <dd> <p>Length of shader data that <strong>pBytecode</strong> points to.</p> </dd>
        /// </summary>
        /// <doc-id>ff728721</doc-id>
        /// <unmanaged>BytecodeLength</unmanaged>
        /// <unmanaged-short>BytecodeLength</unmanaged-short>
        public SharpDX.PointerSize BytecodeLength;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr BytecodePtr;
            public System.IntPtr BytecodeLength;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            BytecodePtr = @ref.BytecodePtr;
            BytecodeLength = (SharpDX.PointerSize)@ref.BytecodeLength;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.BytecodePtr = BytecodePtr;
            @ref.BytecodeLength = (System.IntPtr)BytecodeLength;
        }
    }

    /// <summary>
    /// <p>Describes a shader.</p>
    /// </summary>
    /// <remarks>
    /// <p>A shader is written in HLSL and compiled into an intermediate language by the HLSL compiler. The shader description returns information about the compiled shader. Get a shader description by calling <strong>ID3D11ShaderReflection::GetDesc</strong>.</p>
    /// </remarks>
    /// <doc-id>ff476209</doc-id>
    /// <unmanaged>D3D11_SHADER_DESC</unmanaged>
    /// <unmanaged-short>D3D11_SHADER_DESC</unmanaged-short>
    public partial struct ShaderDescription
    {
        /// <summary>
        /// <dd> <p>Shader version.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>Version</unmanaged>
        /// <unmanaged-short>Version</unmanaged-short>
        public System.Int32 Version;
        /// <summary>
        /// <dd> <p>The name of the originator of the shader.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>Creator</unmanaged>
        /// <unmanaged-short>Creator</unmanaged-short>
        public System.String Creator;
        /// <summary>
        /// <dd> <p>Shader compilation/parse flags.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        public SharpDX.D3DCompiler.ShaderFlags Flags;
        /// <summary>
        /// <dd> <p>The number of shader-constant buffers.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>ConstantBuffers</unmanaged>
        /// <unmanaged-short>ConstantBuffers</unmanaged-short>
        public System.Int32 ConstantBuffers;
        /// <summary>
        /// <dd> <p>The number of resource (textures and buffers) bound to a shader.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>BoundResources</unmanaged>
        /// <unmanaged-short>BoundResources</unmanaged-short>
        public System.Int32 BoundResources;
        /// <summary>
        /// <dd> <p>The number of parameters in the input signature.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>InputParameters</unmanaged>
        /// <unmanaged-short>InputParameters</unmanaged-short>
        public System.Int32 InputParameters;
        /// <summary>
        /// <dd> <p>The number of parameters in the output signature.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>OutputParameters</unmanaged>
        /// <unmanaged-short>OutputParameters</unmanaged-short>
        public System.Int32 OutputParameters;
        /// <summary>
        /// <dd> <p>The number of intermediate-language instructions in the compiled shader.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>InstructionCount</unmanaged>
        /// <unmanaged-short>InstructionCount</unmanaged-short>
        public System.Int32 InstructionCount;
        /// <summary>
        /// <dd> <p>The number of temporary registers in the compiled shader.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>TempRegisterCount</unmanaged>
        /// <unmanaged-short>TempRegisterCount</unmanaged-short>
        public System.Int32 TempRegisterCount;
        /// <summary>
        /// <dd> <p>Number of temporary arrays used.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>TempArrayCount</unmanaged>
        /// <unmanaged-short>TempArrayCount</unmanaged-short>
        public System.Int32 TempArrayCount;
        /// <summary>
        /// <dd> <p>Number of constant defines.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>DefCount</unmanaged>
        /// <unmanaged-short>DefCount</unmanaged-short>
        public System.Int32 DefineCount;
        /// <summary>
        /// <dd> <p>Number of declarations (input + output).</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>DclCount</unmanaged>
        /// <unmanaged-short>DclCount</unmanaged-short>
        public System.Int32 DeclarationCount;
        /// <summary>
        /// <dd> <p>Number of non-categorized texture instructions.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>TextureNormalInstructions</unmanaged>
        /// <unmanaged-short>TextureNormalInstructions</unmanaged-short>
        public System.Int32 TextureNormalInstructions;
        /// <summary>
        /// <dd> <p>Number of texture load instructions</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>TextureLoadInstructions</unmanaged>
        /// <unmanaged-short>TextureLoadInstructions</unmanaged-short>
        public System.Int32 TextureLoadInstructions;
        /// <summary>
        /// <dd> <p>Number of texture comparison instructions</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>TextureCompInstructions</unmanaged>
        /// <unmanaged-short>TextureCompInstructions</unmanaged-short>
        public System.Int32 TextureCompInstructions;
        /// <summary>
        /// <dd> <p>Number of texture bias instructions</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>TextureBiasInstructions</unmanaged>
        /// <unmanaged-short>TextureBiasInstructions</unmanaged-short>
        public System.Int32 TextureBiasInstructions;
        /// <summary>
        /// <dd> <p>Number of texture gradient instructions.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>TextureGradientInstructions</unmanaged>
        /// <unmanaged-short>TextureGradientInstructions</unmanaged-short>
        public System.Int32 TextureGradientInstructions;
        /// <summary>
        /// <dd> <p>Number of floating point arithmetic instructions used.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>FloatInstructionCount</unmanaged>
        /// <unmanaged-short>FloatInstructionCount</unmanaged-short>
        public System.Int32 FloatInstructionCount;
        /// <summary>
        /// <dd> <p>Number of signed integer arithmetic instructions used.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>IntInstructionCount</unmanaged>
        /// <unmanaged-short>IntInstructionCount</unmanaged-short>
        public System.Int32 IntInstructionCount;
        /// <summary>
        /// <dd> <p>Number of unsigned integer arithmetic instructions used.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>UintInstructionCount</unmanaged>
        /// <unmanaged-short>UintInstructionCount</unmanaged-short>
        public System.Int32 UintInstructionCount;
        /// <summary>
        /// <dd> <p>Number of static flow control instructions used.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>StaticFlowControlCount</unmanaged>
        /// <unmanaged-short>StaticFlowControlCount</unmanaged-short>
        public System.Int32 StaticFlowControlCount;
        /// <summary>
        /// <dd> <p>Number of dynamic flow control instructions used.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>DynamicFlowControlCount</unmanaged>
        /// <unmanaged-short>DynamicFlowControlCount</unmanaged-short>
        public System.Int32 DynamicFlowControlCount;
        /// <summary>
        /// <dd> <p>Number of macro instructions used.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>MacroInstructionCount</unmanaged>
        /// <unmanaged-short>MacroInstructionCount</unmanaged-short>
        public System.Int32 MacroInstructionCount;
        /// <summary>
        /// <dd> <p>Number of array instructions used.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>ArrayInstructionCount</unmanaged>
        /// <unmanaged-short>ArrayInstructionCount</unmanaged-short>
        public System.Int32 ArrayInstructionCount;
        /// <summary>
        /// <dd> <p>Number of cut instructions used.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>CutInstructionCount</unmanaged>
        /// <unmanaged-short>CutInstructionCount</unmanaged-short>
        public System.Int32 CutInstructionCount;
        /// <summary>
        /// <dd> <p>Number of emit instructions used.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>EmitInstructionCount</unmanaged>
        /// <unmanaged-short>EmitInstructionCount</unmanaged-short>
        public System.Int32 EmitInstructionCount;
        /// <summary>
        /// <dd> <p>The <strong><see cref = "SharpDX.Direct3D.PrimitiveTopology"/></strong>-typed value that represents the geometry shader output topology.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>GSOutputTopology</unmanaged>
        /// <unmanaged-short>GSOutputTopology</unmanaged-short>
        public SharpDX.Direct3D.PrimitiveTopology GeometryShaderOutputTopology;
        /// <summary>
        /// <dd> <p>Geometry shader maximum output vertex count.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>GSMaxOutputVertexCount</unmanaged>
        /// <unmanaged-short>GSMaxOutputVertexCount</unmanaged-short>
        public System.Int32 GeometryShaderMaxOutputVertexCount;
        /// <summary>
        /// <dd> <p>The <strong><see cref = "SharpDX.D3DCompiler.InputPrimitive"/></strong>-typed value that represents the input primitive for a  geometry shader or hull shader.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>InputPrimitive</unmanaged>
        /// <unmanaged-short>InputPrimitive</unmanaged-short>
        public SharpDX.D3DCompiler.InputPrimitive InputPrimitive;
        /// <summary>
        /// <dd> <p>Number of parameters in the patch-constant signature.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>PatchConstantParameters</unmanaged>
        /// <unmanaged-short>PatchConstantParameters</unmanaged-short>
        public System.Int32 PatchConstantParameters;
        /// <summary>
        /// <dd> <p>Number of geometry shader instances.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>cGSInstanceCount</unmanaged>
        /// <unmanaged-short>cGSInstanceCount</unmanaged-short>
        public System.Int32 GeometryShaderInstanceCount;
        /// <summary>
        /// <dd> <p>Number of control points in the hull shader and domain shader.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>cControlPoints</unmanaged>
        /// <unmanaged-short>cControlPoints</unmanaged-short>
        public System.Int32 ControlPoints;
        /// <summary>
        /// <dd> <p>The <strong><see cref = "SharpDX.D3DCompiler.TessellatorOutputPrimitive"/></strong>-typed value that represents the tessellator output-primitive type.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>HSOutputPrimitive</unmanaged>
        /// <unmanaged-short>HSOutputPrimitive</unmanaged-short>
        public SharpDX.D3DCompiler.TessellatorOutputPrimitive HullShaderOutputPrimitive;
        /// <summary>
        /// <dd> <p>The <strong><see cref = "SharpDX.D3DCompiler.TessellatorPartitioning"/></strong>-typed value that represents the tessellator partitioning mode.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>HSPartitioning</unmanaged>
        /// <unmanaged-short>HSPartitioning</unmanaged-short>
        public SharpDX.D3DCompiler.TessellatorPartitioning HullShaderPartitioning;
        /// <summary>
        /// <dd> <p>The <strong><see cref = "SharpDX.D3DCompiler.TessellatorDomain"/></strong>-typed value that represents the tessellator domain.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>TessellatorDomain</unmanaged>
        /// <unmanaged-short>TessellatorDomain</unmanaged-short>
        public SharpDX.D3DCompiler.TessellatorDomain TessellatorDomain;
        /// <summary>
        /// <dd> <p>Number of barrier instructions in a compute shader.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>cBarrierInstructions</unmanaged>
        /// <unmanaged-short>cBarrierInstructions</unmanaged-short>
        public System.Int32 BarrierInstructions;
        /// <summary>
        /// <dd> <p>Number of interlocked instructions in a compute shader.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>cInterlockedInstructions</unmanaged>
        /// <unmanaged-short>cInterlockedInstructions</unmanaged-short>
        public System.Int32 InterlockedInstructions;
        /// <summary>
        /// <dd> <p>Number of texture writes in a compute shader.</p> </dd>
        /// </summary>
        /// <doc-id>ff476209</doc-id>
        /// <unmanaged>cTextureStoreInstructions</unmanaged>
        /// <unmanaged-short>cTextureStoreInstructions</unmanaged-short>
        public System.Int32 TextureStoreInstructions;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Int32 Version;
            public System.IntPtr Creator;
            public SharpDX.D3DCompiler.ShaderFlags Flags;
            public System.Int32 ConstantBuffers;
            public System.Int32 BoundResources;
            public System.Int32 InputParameters;
            public System.Int32 OutputParameters;
            public System.Int32 InstructionCount;
            public System.Int32 TempRegisterCount;
            public System.Int32 TempArrayCount;
            public System.Int32 DefineCount;
            public System.Int32 DeclarationCount;
            public System.Int32 TextureNormalInstructions;
            public System.Int32 TextureLoadInstructions;
            public System.Int32 TextureCompInstructions;
            public System.Int32 TextureBiasInstructions;
            public System.Int32 TextureGradientInstructions;
            public System.Int32 FloatInstructionCount;
            public System.Int32 IntInstructionCount;
            public System.Int32 UintInstructionCount;
            public System.Int32 StaticFlowControlCount;
            public System.Int32 DynamicFlowControlCount;
            public System.Int32 MacroInstructionCount;
            public System.Int32 ArrayInstructionCount;
            public System.Int32 CutInstructionCount;
            public System.Int32 EmitInstructionCount;
            public SharpDX.Direct3D.PrimitiveTopology GeometryShaderOutputTopology;
            public System.Int32 GeometryShaderMaxOutputVertexCount;
            public SharpDX.D3DCompiler.InputPrimitive InputPrimitive;
            public System.Int32 PatchConstantParameters;
            public System.Int32 GeometryShaderInstanceCount;
            public System.Int32 ControlPoints;
            public SharpDX.D3DCompiler.TessellatorOutputPrimitive HullShaderOutputPrimitive;
            public SharpDX.D3DCompiler.TessellatorPartitioning HullShaderPartitioning;
            public SharpDX.D3DCompiler.TessellatorDomain TessellatorDomain;
            public System.Int32 BarrierInstructions;
            public System.Int32 InterlockedInstructions;
            public System.Int32 TextureStoreInstructions;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.Creator);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Version = @ref.Version;
            Creator = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(@ref.Creator);
            Flags = @ref.Flags;
            ConstantBuffers = @ref.ConstantBuffers;
            BoundResources = @ref.BoundResources;
            InputParameters = @ref.InputParameters;
            OutputParameters = @ref.OutputParameters;
            InstructionCount = @ref.InstructionCount;
            TempRegisterCount = @ref.TempRegisterCount;
            TempArrayCount = @ref.TempArrayCount;
            DefineCount = @ref.DefineCount;
            DeclarationCount = @ref.DeclarationCount;
            TextureNormalInstructions = @ref.TextureNormalInstructions;
            TextureLoadInstructions = @ref.TextureLoadInstructions;
            TextureCompInstructions = @ref.TextureCompInstructions;
            TextureBiasInstructions = @ref.TextureBiasInstructions;
            TextureGradientInstructions = @ref.TextureGradientInstructions;
            FloatInstructionCount = @ref.FloatInstructionCount;
            IntInstructionCount = @ref.IntInstructionCount;
            UintInstructionCount = @ref.UintInstructionCount;
            StaticFlowControlCount = @ref.StaticFlowControlCount;
            DynamicFlowControlCount = @ref.DynamicFlowControlCount;
            MacroInstructionCount = @ref.MacroInstructionCount;
            ArrayInstructionCount = @ref.ArrayInstructionCount;
            CutInstructionCount = @ref.CutInstructionCount;
            EmitInstructionCount = @ref.EmitInstructionCount;
            GeometryShaderOutputTopology = @ref.GeometryShaderOutputTopology;
            GeometryShaderMaxOutputVertexCount = @ref.GeometryShaderMaxOutputVertexCount;
            InputPrimitive = @ref.InputPrimitive;
            PatchConstantParameters = @ref.PatchConstantParameters;
            GeometryShaderInstanceCount = @ref.GeometryShaderInstanceCount;
            ControlPoints = @ref.ControlPoints;
            HullShaderOutputPrimitive = @ref.HullShaderOutputPrimitive;
            HullShaderPartitioning = @ref.HullShaderPartitioning;
            TessellatorDomain = @ref.TessellatorDomain;
            BarrierInstructions = @ref.BarrierInstructions;
            InterlockedInstructions = @ref.InterlockedInstructions;
            TextureStoreInstructions = @ref.TextureStoreInstructions;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Version = Version;
            @ref.Creator = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(Creator);
            @ref.Flags = Flags;
            @ref.ConstantBuffers = ConstantBuffers;
            @ref.BoundResources = BoundResources;
            @ref.InputParameters = InputParameters;
            @ref.OutputParameters = OutputParameters;
            @ref.InstructionCount = InstructionCount;
            @ref.TempRegisterCount = TempRegisterCount;
            @ref.TempArrayCount = TempArrayCount;
            @ref.DefineCount = DefineCount;
            @ref.DeclarationCount = DeclarationCount;
            @ref.TextureNormalInstructions = TextureNormalInstructions;
            @ref.TextureLoadInstructions = TextureLoadInstructions;
            @ref.TextureCompInstructions = TextureCompInstructions;
            @ref.TextureBiasInstructions = TextureBiasInstructions;
            @ref.TextureGradientInstructions = TextureGradientInstructions;
            @ref.FloatInstructionCount = FloatInstructionCount;
            @ref.IntInstructionCount = IntInstructionCount;
            @ref.UintInstructionCount = UintInstructionCount;
            @ref.StaticFlowControlCount = StaticFlowControlCount;
            @ref.DynamicFlowControlCount = DynamicFlowControlCount;
            @ref.MacroInstructionCount = MacroInstructionCount;
            @ref.ArrayInstructionCount = ArrayInstructionCount;
            @ref.CutInstructionCount = CutInstructionCount;
            @ref.EmitInstructionCount = EmitInstructionCount;
            @ref.GeometryShaderOutputTopology = GeometryShaderOutputTopology;
            @ref.GeometryShaderMaxOutputVertexCount = GeometryShaderMaxOutputVertexCount;
            @ref.InputPrimitive = InputPrimitive;
            @ref.PatchConstantParameters = PatchConstantParameters;
            @ref.GeometryShaderInstanceCount = GeometryShaderInstanceCount;
            @ref.ControlPoints = ControlPoints;
            @ref.HullShaderOutputPrimitive = HullShaderOutputPrimitive;
            @ref.HullShaderPartitioning = HullShaderPartitioning;
            @ref.TessellatorDomain = TessellatorDomain;
            @ref.BarrierInstructions = BarrierInstructions;
            @ref.InterlockedInstructions = InterlockedInstructions;
            @ref.TextureStoreInstructions = TextureStoreInstructions;
        }
    }

    /// <summary>
    /// <p>Describes a shader signature.</p>
    /// </summary>
    /// <remarks>
    /// <p>A shader can take n inputs and can produce m outputs. The order of the input (or output) parameters, their associated types, and any attached semantics make up the shader signature. Each shader has an input and an output signature.</p><p>When compiling a shader or an effect, some API calls validate shader signatures  That is, they compare the output signature of one shader (like a vertex shader) with the input signature of another shader (like a pixel shader). This ensures that a shader outputs data that is compatible with a downstream shader that is consuming that data. Compatible means that a shader signature is a exact-match subset of the preceding shader stage. Exact match means parameter types and semantics must exactly match. Subset means that a parameter that is not required by a downstream stage, does not need to include that parameter in its shader signature.</p><p>Get a shader-signature from a shader or an effect by calling APIs such as <strong>ID3D11ShaderReflection::GetInputParameterDesc</strong>. </p>
    /// </remarks>
    /// <doc-id>ff476215</doc-id>
    /// <unmanaged>D3D11_SIGNATURE_PARAMETER_DESC</unmanaged>
    /// <unmanaged-short>D3D11_SIGNATURE_PARAMETER_DESC</unmanaged-short>
    public partial struct ShaderParameterDescription
    {
        /// <summary>
        /// <dd> <p>A per-parameter string that identifies how the data will be used. For more info, see Semantics. </p> </dd>
        /// </summary>
        /// <doc-id>ff476215</doc-id>
        /// <unmanaged>SemanticName</unmanaged>
        /// <unmanaged-short>SemanticName</unmanaged-short>
        public System.String SemanticName;
        /// <summary>
        /// <dd> <p>Semantic index that modifies the semantic. Used to differentiate different parameters that use the same semantic.</p> </dd>
        /// </summary>
        /// <doc-id>ff476215</doc-id>
        /// <unmanaged>SemanticIndex</unmanaged>
        /// <unmanaged-short>SemanticIndex</unmanaged-short>
        public System.Int32 SemanticIndex;
        /// <summary>
        /// <dd> <p>The register that will contain this variable's data.</p> </dd>
        /// </summary>
        /// <doc-id>ff476215</doc-id>
        /// <unmanaged>Register</unmanaged>
        /// <unmanaged-short>Register</unmanaged-short>
        public System.Int32 Register;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.D3DCompiler.SystemValueType"/></strong>-typed value that identifies a predefined string that determines the functionality of certain pipeline stages.</p> </dd>
        /// </summary>
        /// <doc-id>ff476215</doc-id>
        /// <unmanaged>SystemValueType</unmanaged>
        /// <unmanaged-short>SystemValueType</unmanaged-short>
        public SharpDX.D3DCompiler.SystemValueType SystemValueType;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.D3DCompiler.RegisterComponentType"/></strong>-typed value that identifies the per-component-data type that is stored in a register.  Each register can store up to four-components of data.</p> </dd>
        /// </summary>
        /// <doc-id>ff476215</doc-id>
        /// <unmanaged>ComponentType</unmanaged>
        /// <unmanaged-short>ComponentType</unmanaged-short>
        public SharpDX.D3DCompiler.RegisterComponentType ComponentType;
        /// <summary>
        /// <dd> <p>Mask which indicates which components of a register are used.</p> </dd>
        /// </summary>
        /// <doc-id>ff476215</doc-id>
        /// <unmanaged>Mask</unmanaged>
        /// <unmanaged-short>Mask</unmanaged-short>
        public SharpDX.D3DCompiler.RegisterComponentMaskFlags UsageMask;
        /// <summary>
        /// <dd> <p>Mask which indicates whether a given component is never written (if the signature is an output signature) or always read (if the signature is an input signature). </p> </dd>
        /// </summary>
        /// <doc-id>ff476215</doc-id>
        /// <unmanaged>ReadWriteMask</unmanaged>
        /// <unmanaged-short>ReadWriteMask</unmanaged-short>
        public SharpDX.D3DCompiler.RegisterComponentMaskFlags ReadWriteMask;
        /// <summary>
        /// <dd> <p>Indicates which stream the geometry shader is using for the signature parameter.</p> </dd>
        /// </summary>
        /// <doc-id>ff476215</doc-id>
        /// <unmanaged>Stream</unmanaged>
        /// <unmanaged-short>Stream</unmanaged-short>
        public System.Int32 Stream;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.Direct3D.MinimumPrecision"/></strong>-typed value that indicates the minimum desired interpolation precision. For more info, see Using HLSL minimum precision.</p> </dd>
        /// </summary>
        /// <doc-id>ff476215</doc-id>
        /// <unmanaged>MinPrecision</unmanaged>
        /// <unmanaged-short>MinPrecision</unmanaged-short>
        public SharpDX.Direct3D.MinimumPrecision MinPrecision;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr SemanticName;
            public System.Int32 SemanticIndex;
            public System.Int32 Register;
            public SharpDX.D3DCompiler.SystemValueType SystemValueType;
            public SharpDX.D3DCompiler.RegisterComponentType ComponentType;
            public SharpDX.D3DCompiler.RegisterComponentMaskFlags UsageMask;
            public SharpDX.D3DCompiler.RegisterComponentMaskFlags ReadWriteMask;
            public System.Int32 Stream;
            public SharpDX.Direct3D.MinimumPrecision MinPrecision;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.SemanticName);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            SemanticName = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(@ref.SemanticName);
            SemanticIndex = @ref.SemanticIndex;
            Register = @ref.Register;
            SystemValueType = @ref.SystemValueType;
            ComponentType = @ref.ComponentType;
            UsageMask = @ref.UsageMask;
            ReadWriteMask = @ref.ReadWriteMask;
            Stream = @ref.Stream;
            MinPrecision = @ref.MinPrecision;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.SemanticName = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(SemanticName);
            @ref.SemanticIndex = SemanticIndex;
            @ref.Register = Register;
            @ref.SystemValueType = SystemValueType;
            @ref.ComponentType = ComponentType;
            @ref.UsageMask = UsageMask;
            @ref.ReadWriteMask = ReadWriteMask;
            @ref.Stream = Stream;
            @ref.MinPrecision = MinPrecision;
        }
    }

    /// <summary>
    /// <p>Describes a shader-variable type.</p>
    /// </summary>
    /// <remarks>
    /// <p>Get a shader-variable-type description by calling <strong>ID3D11ShaderReflectionType::GetDesc</strong>.</p>
    /// </remarks>
    /// <doc-id>ff476212</doc-id>
    /// <unmanaged>D3D11_SHADER_TYPE_DESC</unmanaged>
    /// <unmanaged-short>D3D11_SHADER_TYPE_DESC</unmanaged-short>
    public partial struct ShaderTypeDescription
    {
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.D3DCompiler.ShaderVariableClass"/></strong>-typed value that identifies the variable class as one of scalar, vector, matrix, object, and so on.</p> </dd>
        /// </summary>
        /// <doc-id>ff476212</doc-id>
        /// <unmanaged>Class</unmanaged>
        /// <unmanaged-short>Class</unmanaged-short>
        public SharpDX.D3DCompiler.ShaderVariableClass Class;
        /// <summary>
        /// <dd> <p>A <strong><see cref = "SharpDX.D3DCompiler.ShaderVariableType"/></strong>-typed value that identifies the variable type.</p> </dd>
        /// </summary>
        /// <doc-id>ff476212</doc-id>
        /// <unmanaged>Type</unmanaged>
        /// <unmanaged-short>Type</unmanaged-short>
        public SharpDX.D3DCompiler.ShaderVariableType Type;
        /// <summary>
        /// <dd> <p>Number of rows in a matrix. Otherwise a numeric type returns 1, any other type returns 0.</p> </dd>
        /// </summary>
        /// <doc-id>ff476212</doc-id>
        /// <unmanaged>Rows</unmanaged>
        /// <unmanaged-short>Rows</unmanaged-short>
        public System.Int32 RowCount;
        /// <summary>
        /// <dd> <p>Number of columns in a matrix. Otherwise a numeric type returns 1, any other type returns 0.</p> </dd>
        /// </summary>
        /// <doc-id>ff476212</doc-id>
        /// <unmanaged>Columns</unmanaged>
        /// <unmanaged-short>Columns</unmanaged-short>
        public System.Int32 ColumnCount;
        /// <summary>
        /// <dd> <p>Number of elements in an array; otherwise 0.</p> </dd>
        /// </summary>
        /// <doc-id>ff476212</doc-id>
        /// <unmanaged>Elements</unmanaged>
        /// <unmanaged-short>Elements</unmanaged-short>
        public System.Int32 ElementCount;
        /// <summary>
        /// <dd> <p>Number of members in the structure; otherwise 0.</p> </dd>
        /// </summary>
        /// <doc-id>ff476212</doc-id>
        /// <unmanaged>Members</unmanaged>
        /// <unmanaged-short>Members</unmanaged-short>
        public System.Int32 MemberCount;
        /// <summary>
        /// <dd> <p>Offset, in bytes, between the start of the parent structure and this variable. Can be 0 if not a structure member.</p> </dd>
        /// </summary>
        /// <doc-id>ff476212</doc-id>
        /// <unmanaged>Offset</unmanaged>
        /// <unmanaged-short>Offset</unmanaged-short>
        public System.Int32 Offset;
        /// <summary>
        /// <dd> <p>Name of the shader-variable type. This member can be <strong><c>null</c></strong> if it isn't used. This member supports dynamic shader linkage interface types, which have names. For more info about dynamic shader linkage, see Dynamic Linking.</p> </dd>
        /// </summary>
        /// <doc-id>ff476212</doc-id>
        /// <unmanaged>Name</unmanaged>
        /// <unmanaged-short>Name</unmanaged-short>
        public System.String Name;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public SharpDX.D3DCompiler.ShaderVariableClass Class;
            public SharpDX.D3DCompiler.ShaderVariableType Type;
            public System.Int32 RowCount;
            public System.Int32 ColumnCount;
            public System.Int32 ElementCount;
            public System.Int32 MemberCount;
            public System.Int32 Offset;
            public System.IntPtr Name;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.Name);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Class = @ref.Class;
            Type = @ref.Type;
            RowCount = @ref.RowCount;
            ColumnCount = @ref.ColumnCount;
            ElementCount = @ref.ElementCount;
            MemberCount = @ref.MemberCount;
            Offset = @ref.Offset;
            Name = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(@ref.Name);
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Class = Class;
            @ref.Type = Type;
            @ref.RowCount = RowCount;
            @ref.ColumnCount = ColumnCount;
            @ref.ElementCount = ElementCount;
            @ref.MemberCount = MemberCount;
            @ref.Offset = Offset;
            @ref.Name = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(Name);
        }
    }

    /// <summary>
    /// <p>Describes a shader variable.</p>
    /// </summary>
    /// <remarks>
    /// <p> Get a shader-variable description using reflection by calling <strong>ID3D11ShaderReflectionVariable::GetDesc</strong>. </p><p> As of the June 2010 update, <strong>DefaultValue</strong> emits default values for reflection. </p>
    /// </remarks>
    /// <doc-id>ff476213</doc-id>
    /// <unmanaged>D3D11_SHADER_VARIABLE_DESC</unmanaged>
    /// <unmanaged-short>D3D11_SHADER_VARIABLE_DESC</unmanaged-short>
    public partial struct ShaderVariableDescription
    {
        /// <summary>
        /// <dd> <p>The variable name.</p> </dd>
        /// </summary>
        /// <doc-id>ff476213</doc-id>
        /// <unmanaged>Name</unmanaged>
        /// <unmanaged-short>Name</unmanaged-short>
        public System.String Name;
        /// <summary>
        /// <dd> <p>Offset from the start of the parent structure to the beginning of the variable.</p> </dd>
        /// </summary>
        /// <doc-id>ff476213</doc-id>
        /// <unmanaged>StartOffset</unmanaged>
        /// <unmanaged-short>StartOffset</unmanaged-short>
        public System.Int32 StartOffset;
        /// <summary>
        /// <dd> <p>Size of the variable (in bytes).</p> </dd>
        /// </summary>
        /// <doc-id>ff476213</doc-id>
        /// <unmanaged>Size</unmanaged>
        /// <unmanaged-short>Size</unmanaged-short>
        public System.Int32 Size;
        /// <summary>
        /// <dd> <p> A combination of <strong><see cref = "SharpDX.D3DCompiler.ShaderVariableFlags"/></strong>-typed values that are combined by using a bitwise OR operation. The resulting value identifies shader-variable properties. </p> </dd>
        /// </summary>
        /// <doc-id>ff476213</doc-id>
        /// <unmanaged>uFlags</unmanaged>
        /// <unmanaged-short>uFlags</unmanaged-short>
        public SharpDX.D3DCompiler.ShaderVariableFlags Flags;
        /// <summary>
        /// <dd> <p>The default value for initializing the variable.</p> </dd>
        /// </summary>
        /// <doc-id>ff476213</doc-id>
        /// <unmanaged>DefaultValue</unmanaged>
        /// <unmanaged-short>DefaultValue</unmanaged-short>
        public System.IntPtr DefaultValue;
        /// <summary>
        /// <dd> <p>Offset from the start of the variable to the beginning of the texture. </p> </dd>
        /// </summary>
        /// <doc-id>ff476213</doc-id>
        /// <unmanaged>StartTexture</unmanaged>
        /// <unmanaged-short>StartTexture</unmanaged-short>
        public System.Int32 StartTexture;
        /// <summary>
        /// <dd> <p>The size of the texture, in bytes.  </p> </dd>
        /// </summary>
        /// <doc-id>ff476213</doc-id>
        /// <unmanaged>TextureSize</unmanaged>
        /// <unmanaged-short>TextureSize</unmanaged-short>
        public System.Int32 TextureSize;
        /// <summary>
        /// <dd> <p>Offset from the start of the variable to the beginning of the sampler. </p> </dd>
        /// </summary>
        /// <doc-id>ff476213</doc-id>
        /// <unmanaged>StartSampler</unmanaged>
        /// <unmanaged-short>StartSampler</unmanaged-short>
        public System.Int32 StartSampler;
        /// <summary>
        /// <dd> <p>The size of the sampler, in bytes. </p> </dd>
        /// </summary>
        /// <doc-id>ff476213</doc-id>
        /// <unmanaged>SamplerSize</unmanaged>
        /// <unmanaged-short>SamplerSize</unmanaged-short>
        public System.Int32 SamplerSize;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr Name;
            public System.Int32 StartOffset;
            public System.Int32 Size;
            public SharpDX.D3DCompiler.ShaderVariableFlags Flags;
            public System.IntPtr DefaultValue;
            public System.Int32 StartTexture;
            public System.Int32 TextureSize;
            public System.Int32 StartSampler;
            public System.Int32 SamplerSize;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.Name);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Name = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(@ref.Name);
            StartOffset = @ref.StartOffset;
            Size = @ref.Size;
            Flags = @ref.Flags;
            DefaultValue = @ref.DefaultValue;
            StartTexture = @ref.StartTexture;
            TextureSize = @ref.TextureSize;
            StartSampler = @ref.StartSampler;
            SamplerSize = @ref.SamplerSize;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(Name);
            @ref.StartOffset = StartOffset;
            @ref.Size = Size;
            @ref.Flags = Flags;
            @ref.DefaultValue = DefaultValue;
            @ref.StartTexture = StartTexture;
            @ref.TextureSize = TextureSize;
            @ref.StartSampler = StartSampler;
            @ref.SamplerSize = SamplerSize;
        }
    }
}