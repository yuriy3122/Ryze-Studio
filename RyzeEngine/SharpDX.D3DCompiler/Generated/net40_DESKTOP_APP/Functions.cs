// <auto-generated/>

namespace SharpDX.D3DCompiler
{
    /// <summary>
    /// Functions
    /// </summary>
    static partial class D3D
    {
        /// <summary>
        /// <strong>Note</strong>??You can use this API to develop your Windows Store apps, but you can't use it in apps that you submit to the Windows Store.?<p>Reads a file  that is on disk into memory.</p>
        /// </summary>
        /// <param name = "fileNameRef"><dd> <p>A reference to a constant null-terminated string that contains  the name of the file to read into memory.</p> </dd></param>
        /// <param name = "contentsOut"><dd> <p>A reference to a variable that receives a reference to the <strong>ID3DBlob</strong> interface that contains information that <strong>D3DReadFileToBlob</strong> read from the <em>pFileName</em> file. You can use this <strong>ID3DBlob</strong> interface to access the file information and pass it to other compiler functions.</p> </dd></param>
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??The D3dcompiler_44.dll or later version of the file contains the <strong>D3DReadFileToBlob</strong> compiler function.?
        /// </remarks>
        /// <doc-id>hh446877</doc-id>
        /// <unmanaged>HRESULT D3DReadFileToBlob([In] const wchar_t* pFileName,[Out] ID3D10Blob** ppContents)</unmanaged>
        /// <unmanaged-short>D3DReadFileToBlob</unmanaged-short>
        public static unsafe void ReadFileToBlob(System.String fileNameRef, out SharpDX.Direct3D.Blob contentsOut)
        {
            System.IntPtr contentsOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (char *fileNameRef_ = fileNameRef)
                __result__ = D3DReadFileToBlob_((void *)fileNameRef_, &contentsOut_);
            if (contentsOut_ != System.IntPtr.Zero)
                contentsOut = new SharpDX.Direct3D.Blob(contentsOut_);
            else
                contentsOut = null;
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("d3dcompiler_47.dll", EntryPoint = "D3DReadFileToBlob", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D3DReadFileToBlob_(void *param0, void *param1);
        /// <summary>
        /// <strong>Note</strong>??You can use this API to develop your Windows Store apps, but you can't use it in apps that you submit to the Windows Store.?<p>Writes a memory blob to a file on disk.</p>
        /// </summary>
        /// <param name = "blobRef"><dd>  <p>A reference to a <strong>ID3DBlob</strong> interface that contains the memory blob to write to the file that the <em>pFileName</em> parameter specifies.</p> </dd></param>
        /// <param name = "fileNameRef"><dd>  <p>A reference to a constant null-terminated string that contains  the name of the file to which to write.</p> </dd></param>
        /// <param name = "bOverwrite"><dd>  <p>A Boolean value that specifies whether to overwrite information in the <em>pFileName</em> file. TRUE specifies to overwrite information and <see cref = "SharpDX.Result.False"/> specifies not to overwrite information.</p> </dd></param>
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??The D3dcompiler_44.dll or later version of the file contains the <strong>D3DWriteBlobToFile</strong> compiler function.?
        /// </remarks>
        /// <doc-id>hh446883</doc-id>
        /// <unmanaged>HRESULT D3DWriteBlobToFile([In] ID3D10Blob* pBlob,[In] const wchar_t* pFileName,[In] BOOL bOverwrite)</unmanaged>
        /// <unmanaged-short>D3DWriteBlobToFile</unmanaged-short>
        public static unsafe void WriteBlobToFile(SharpDX.Direct3D.Blob blobRef, System.String fileNameRef, SharpDX.Mathematics.Interop.RawBool bOverwrite)
        {
            System.IntPtr blobRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            blobRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D.Blob>(blobRef);
            fixed (char *fileNameRef_ = fileNameRef)
                __result__ = D3DWriteBlobToFile_((void *)blobRef_, (void *)fileNameRef_, bOverwrite);
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("d3dcompiler_47.dll", EntryPoint = "D3DWriteBlobToFile", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D3DWriteBlobToFile_(void *param0, void *param1, SharpDX.Mathematics.Interop.RawBool param2);
        /// <summary>
        /// <p>Compile HLSL code or an  effect file into bytecode for a given target.</p>
        /// </summary>
        /// <param name = "srcDataRef"><dd>  <p>A reference to uncompiled shader data; either ASCII HLSL code or a compiled effect.</p> </dd></param>
        /// <param name = "srcDataSize"><dd>  <p>Length of <em>pSrcData</em>.</p> </dd></param>
        /// <param name = "sourceNameRef"><dd>  <p> You can use this parameter for strings that specify  error messages. If not used, set to <strong><c>null</c></strong>.</p> </dd></param>
        /// <param name = "definesRef"><dd>  <p> An array of <c>null</c>-terminated macro definitions (see <strong><see cref = "SharpDX.Direct3D.ShaderMacro"/></strong>).</p> </dd></param>
        /// <param name = "includeRef"><dd>  <p>Optional. A reference to an <strong><see cref = "SharpDX.D3DCompiler.Include"/></strong> for handling include files. Setting this to <strong><c>null</c></strong> will cause a compile error if a shader contains a #include. You can pass the <strong>D3D_COMPILE_STANDARD_FILE_INCLUDE</strong> macro, which is a reference to a default include handler. This default include handler includes files that are relative to the current directory and files that are relative to the directory of the initial source file. When you use <strong>D3D_COMPILE_STANDARD_FILE_INCLUDE</strong>, you must specify the source file name in the <em>pSourceName</em> parameter; the compiler will derive the initial relative directory from <em>pSourceName</em>.</p>  <pre>#define D3D_COMPILE_STANDARD_FILE_INCLUDE ((<see cref = "SharpDX.D3DCompiler.Include"/>*)(<see cref = "System.IntPtr"/>)1)</pre>  </dd></param>
        /// <param name = "entrypointRef"><dd>  <p>The name of the shader entry point function where shader execution begins. When you compile using a fx profile (for example, fx_4_0, fx_5_0, and so on), <strong>D3DCompile</strong> ignores <em>pEntrypoint</em>. In this case, we recommend that you set <em>pEntrypoint</em> to <strong><c>null</c></strong> because it is good programming practice to set a reference parameter to <strong><c>null</c></strong> if the called function will not use it. For all other shader profiles, a valid <em>pEntrypoint</em> is required.</p> </dd></param>
        /// <param name = "targetRef"><dd>  <p>A string that specifies the shader target or set of shader features to compile against. The shader target can be shader model 2, shader model 3, shader model 4, or shader model 5. The target can also be an effect type (for example, fx_4_1). For info about the targets that various profiles support, see Specifying Compiler Targets. </p> </dd></param>
        /// <param name = "flags1"><dd>  <p>Flags defined by <strong>D3D compile constants</strong>.</p> </dd></param>
        /// <param name = "flags2"><dd>  <p>Flags defined by <strong>D3D compile effect constants</strong>. When you compile a shader and not an effect file, <strong>D3DCompile</strong> ignores <em>Flags2</em>; we recommend that you set <em>Flags2</em> to zero because it is good programming practice to set a nonreference parameter to zero if the called function will not use it.</p> </dd></param>
        /// <param name = "codeOut"><dd>  <p>A reference to a variable that receives a reference to the <strong>ID3DBlob</strong> interface that you can use to access the compiled code.</p> </dd></param>
        /// <param name = "errorMsgsOut"><dd>  <p>A reference to a variable that receives a reference to the <strong>ID3DBlob</strong> interface that you can use to access compiler error messages, or <strong><c>null</c></strong> if there are no errors.</p> </dd></param>
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>
        /// <remarks>
        /// <p>The difference between <strong>D3DCompile</strong> and <strong>D3DCompile2</strong> is that the latter method takes some optional parameters that can be used to control some aspects of how bytecode is generated. If this extra flexibility is not required, there is no performance gain from using <strong>D3DCompile2</strong>.</p>
        /// </remarks>
        /// <doc-id>dd607324</doc-id>
        /// <unmanaged>HRESULT D3DCompile([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[In, Optional] const char* pSourceName,[In, Buffer, Optional] const D3D_SHADER_MACRO* pDefines,[In, Optional] ID3DInclude* pInclude,[In, Optional] const char* pEntrypoint,[In] const char* pTarget,[In] unsigned int Flags1,[In] unsigned int Flags2,[Out] ID3D10Blob** ppCode,[Out, Optional] ID3D10Blob** ppErrorMsgs)</unmanaged>
        /// <unmanaged-short>D3DCompile</unmanaged-short>
        public static unsafe SharpDX.Result Compile(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, System.String sourceNameRef, SharpDX.Direct3D.ShaderMacro[] definesRef, SharpDX.D3DCompiler.Include includeRef, System.String entrypointRef, System.String targetRef, SharpDX.D3DCompiler.ShaderFlags flags1, SharpDX.D3DCompiler.EffectFlags flags2, out SharpDX.Direct3D.Blob codeOut, out SharpDX.Direct3D.Blob errorMsgsOut)
        {
            System.IntPtr sourceNameRef_;
            SharpDX.Direct3D.ShaderMacro.__Native[] definesRef_ = definesRef == null ? null : new SharpDX.Direct3D.ShaderMacro.__Native[definesRef.Length];
            System.IntPtr includeRef_ = System.IntPtr.Zero;
            System.IntPtr entrypointRef_;
            System.IntPtr targetRef_;
            System.IntPtr codeOut_ = System.IntPtr.Zero;
            System.IntPtr errorMsgsOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            sourceNameRef_ = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(sourceNameRef);
            if (definesRef != null)
                for (int i = 0; i < definesRef.Length; ++i)
                    if (definesRef != null)
                        definesRef[i].__MarshalTo(ref (definesRef_)[i]);
            includeRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.D3DCompiler.Include>(includeRef);
            entrypointRef_ = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(entrypointRef);
            targetRef_ = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(targetRef);
            fixed (void *_definesRef = definesRef_)
                __result__ = D3DCompile_((void *)srcDataRef, (void *)srcDataSize, (void *)sourceNameRef_, _definesRef, (void *)includeRef_, (void *)entrypointRef_, (void *)targetRef_, unchecked ((System.Int32)flags1), unchecked ((System.Int32)flags2), &codeOut_, &errorMsgsOut_);
            if (codeOut_ != System.IntPtr.Zero)
                codeOut = new SharpDX.Direct3D.Blob(codeOut_);
            else
                codeOut = null;
            if (errorMsgsOut_ != System.IntPtr.Zero)
                errorMsgsOut = new SharpDX.Direct3D.Blob(errorMsgsOut_);
            else
                errorMsgsOut = null;
            System.Runtime.InteropServices.Marshal.FreeHGlobal(sourceNameRef_);
            if (definesRef != null)
                for (int i = 0; i < definesRef.Length; ++i)
                    if (definesRef != null)
                        definesRef[i].__MarshalFree(ref (definesRef_)[i]);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(entrypointRef_);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(targetRef_);
            return __result__;
        }

        [System.Runtime.InteropServices.DllImportAttribute("d3dcompiler_47.dll", EntryPoint = "D3DCompile", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D3DCompile_(void *param0, void *param1, void *param2, void *param3, void *param4, void *param5, void *param6, int param7, int param8, void *param9, void *param10);
        /// <summary>
        /// <p>Compiles Microsoft High Level Shader Language (HLSL) code into bytecode for a given target.</p>
        /// </summary>
        /// <param name = "srcDataRef"><dd>  <p>A reference to uncompiled shader data (ASCII HLSL code).</p> </dd></param>
        /// <param name = "srcDataSize"><dd>  <p>The size, in bytes, of the block of memory that <em>pSrcData</em> points to.</p> </dd></param>
        /// <param name = "sourceNameRef"><dd>  <p>An optional reference to a constant null-terminated string containing the name that identifies the source data to use in error messages. If not used, set to <strong><c>null</c></strong>.</p> </dd></param>
        /// <param name = "definesRef"><dd>  <p>An optional array of <strong><see cref = "SharpDX.Direct3D.ShaderMacro"/></strong> structures that define shader macros. Each macro definition contains a name and a <c>null</c>-terminated definition. If not used, set to <strong><c>null</c></strong>.</p> </dd></param>
        /// <param name = "includeRef"><dd>  <p> A reference to an <strong><see cref = "SharpDX.D3DCompiler.Include"/></strong> interface that the compiler uses to handle include files. If you set this parameter to <strong><c>null</c></strong> and the shader contains a #include, a compile error occurs. You can pass the <strong>D3D_COMPILE_STANDARD_FILE_INCLUDE</strong> macro, which is a reference to a default include handler. This default include handler includes files that are relative to the current directory and files that are relative to the directory of the initial source file. When you use <strong>D3D_COMPILE_STANDARD_FILE_INCLUDE</strong>, you must specify the source file name in the <em>pSourceName</em> parameter; the compiler will derive the initial relative directory from <em>pSourceName</em>.</p>  <pre>#define D3D_COMPILE_STANDARD_FILE_INCLUDE ((<see cref = "SharpDX.D3DCompiler.Include"/>*)(<see cref = "System.IntPtr"/>)1)</pre>  </dd></param>
        /// <param name = "entrypointRef"><dd>  <p>A reference to a constant null-terminated string that contains  the name of the shader entry point function where shader execution begins. When you compile an effect, <strong>D3DCompile2</strong> ignores <em>pEntrypoint</em>; we recommend that you set <em>pEntrypoint</em> to <strong><c>null</c></strong> because it is good programming practice to set a reference parameter to <strong><c>null</c></strong> if the called function will not use it.</p> </dd></param>
        /// <param name = "targetRef"><dd>  <p>A reference to a constant null-terminated string that specifies the shader target or set of shader features to compile against. The shader target can be a shader model (for example, shader model 2, shader model 3, shader model 4, or shader model 5). The target can also be an effect type (for example, fx_4_1). For info about the targets that various profiles support, see Specifying Compiler Targets. </p> </dd></param>
        /// <param name = "flags1"><dd>  <p>A combination of shader <strong>D3D compile constants</strong> that are combined by using a bitwise <strong>OR</strong> operation. The resulting value specifies how the compiler compiles the HLSL code.</p> </dd></param>
        /// <param name = "flags2"><dd>  <p>A combination of effect <strong>D3D compile effect constants</strong> that are combined by using a bitwise <strong>OR</strong> operation. The resulting value specifies how the compiler compiles the effect. When you compile a shader and not an effect file, <strong>D3DCompile2</strong> ignores <em>Flags2</em>; we recommend that you set <em>Flags2</em> to zero because it is good programming practice to set a nonreference parameter to zero if the called function will not use it.</p> </dd></param>
        /// <param name = "secondaryDataFlags"><dd>  <p>A combination of the following flags that are combined by using a bitwise <strong>OR</strong> operation. The resulting value specifies how the compiler compiles the HLSL code. </p> <table> <tr><th>Flag</th><th>Description</th></tr> <tr><td>D3DCOMPILE_SECDATA_MERGE_UAV_SLOTS (0x01)</td><td>Merge unordered access view (UAV) slots in the secondary data that the <em>pSecondaryData</em> parameter points to.</td></tr> <tr><td>D3DCOMPILE_SECDATA_PRESERVE_TEMPLATE_SLOTS (0x02)</td><td>Preserve template slots in the secondary data that the <em>pSecondaryData</em> parameter points to.</td></tr> <tr><td>D3DCOMPILE_SECDATA_REQUIRE_TEMPLATE_MATCH (0x04)</td><td>Require that templates in the secondary data that the <em>pSecondaryData</em> parameter points to match when the compiler compiles the HLSL code.</td></tr> </table> <p>?</p> <p>If <em>pSecondaryData</em> is <strong><c>null</c></strong>, set to zero.</p> </dd></param>
        /// <param name = "secondaryDataRef"><dd>  <p>A reference to secondary data. If you don't pass secondary data, set to <strong><c>null</c></strong>. Use this secondary data  to align UAV slots in two shaders. Suppose shader A has UAVs and they are bound to some slots. To compile shader B such that UAVs with the same names are mapped in B to the same slots as in A, pass A?s byte code to <strong>D3DCompile2</strong> as the secondary data. </p> </dd></param>
        /// <param name = "secondaryDataSize"><dd>  <p>The size, in bytes, of the block of memory that <em>pSecondaryData</em> points to. If <em>pSecondaryData</em> is <strong><c>null</c></strong>, set to zero.</p> </dd></param>
        /// <param name = "codeOut"><dd>  <p>A reference to a variable that receives a reference to the <strong>ID3DBlob</strong> interface that you can use to access the compiled code.</p> </dd></param>
        /// <param name = "errorMsgsOut"><dd>  <p>A reference to a variable that receives a reference to the <strong>ID3DBlob</strong> interface that you can use to access compiler error messages, or <strong><c>null</c></strong> if there are no errors.</p> </dd></param>
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>
        /// <remarks>
        /// <p>The difference between <strong>D3DCompile2</strong> and <strong>D3DCompile</strong> is that <strong>D3DCompile2</strong> takes some optional parameters (<em>SecondaryDataFlags</em>, <em>pSecondaryData</em> and <em>SecondaryDataSize</em>)  that can be used to control some aspects of how bytecode is generated. Refer to the descriptions of these parameters for more details. There is no difference otherwise to the efficiency of the bytecode generated between  <strong>D3DCompile2</strong> and <strong>D3DCompile</strong>.</p>
        /// </remarks>
        /// <doc-id>hh446869</doc-id>
        /// <unmanaged>HRESULT D3DCompile2([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[In, Optional] const char* pSourceName,[In, Buffer, Optional] const D3D_SHADER_MACRO* pDefines,[In, Optional] ID3DInclude* pInclude,[In] const char* pEntrypoint,[In] const char* pTarget,[In] unsigned int Flags1,[In] unsigned int Flags2,[In] unsigned int SecondaryDataFlags,[In, Buffer, Optional] const void* pSecondaryData,[In] SIZE_T SecondaryDataSize,[Out] ID3D10Blob** ppCode,[Out, Optional] ID3D10Blob** ppErrorMsgs)</unmanaged>
        /// <unmanaged-short>D3DCompile2</unmanaged-short>
        public static unsafe SharpDX.Result Compile2(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, System.String sourceNameRef, SharpDX.Direct3D.ShaderMacro[] definesRef, SharpDX.D3DCompiler.Include includeRef, System.String entrypointRef, System.String targetRef, SharpDX.D3DCompiler.ShaderFlags flags1, SharpDX.D3DCompiler.EffectFlags flags2, SharpDX.D3DCompiler.SecondaryDataFlags secondaryDataFlags, System.IntPtr secondaryDataRef, SharpDX.PointerSize secondaryDataSize, out SharpDX.Direct3D.Blob codeOut, out SharpDX.Direct3D.Blob errorMsgsOut)
        {
            System.IntPtr sourceNameRef_;
            SharpDX.Direct3D.ShaderMacro.__Native[] definesRef_ = definesRef == null ? null : new SharpDX.Direct3D.ShaderMacro.__Native[definesRef.Length];
            System.IntPtr includeRef_ = System.IntPtr.Zero;
            System.IntPtr entrypointRef_;
            System.IntPtr targetRef_;
            System.IntPtr codeOut_ = System.IntPtr.Zero;
            System.IntPtr errorMsgsOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            sourceNameRef_ = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(sourceNameRef);
            if (definesRef != null)
                for (int i = 0; i < definesRef.Length; ++i)
                    if (definesRef != null)
                        definesRef[i].__MarshalTo(ref (definesRef_)[i]);
            includeRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.D3DCompiler.Include>(includeRef);
            entrypointRef_ = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(entrypointRef);
            targetRef_ = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(targetRef);
            fixed (void *_definesRef = definesRef_)
                __result__ = D3DCompile2_((void *)srcDataRef, (void *)srcDataSize, (void *)sourceNameRef_, _definesRef, (void *)includeRef_, (void *)entrypointRef_, (void *)targetRef_, unchecked ((System.Int32)flags1), unchecked ((System.Int32)flags2), unchecked ((System.Int32)secondaryDataFlags), (void *)secondaryDataRef, (void *)secondaryDataSize, &codeOut_, &errorMsgsOut_);
            if (codeOut_ != System.IntPtr.Zero)
                codeOut = new SharpDX.Direct3D.Blob(codeOut_);
            else
                codeOut = null;
            if (errorMsgsOut_ != System.IntPtr.Zero)
                errorMsgsOut = new SharpDX.Direct3D.Blob(errorMsgsOut_);
            else
                errorMsgsOut = null;
            System.Runtime.InteropServices.Marshal.FreeHGlobal(sourceNameRef_);
            if (definesRef != null)
                for (int i = 0; i < definesRef.Length; ++i)
                    if (definesRef != null)
                        definesRef[i].__MarshalFree(ref (definesRef_)[i]);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(entrypointRef_);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(targetRef_);
            return __result__;
        }

        [System.Runtime.InteropServices.DllImportAttribute("d3dcompiler_47.dll", EntryPoint = "D3DCompile2", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D3DCompile2_(void *param0, void *param1, void *param2, void *param3, void *param4, void *param5, void *param6, int param7, int param8, int param9, void *param10, void *param11, void *param12, void *param13);
        /// <summary>
        /// <strong>Note</strong>??You can use this API to develop your Windows Store apps, but you can't use it in apps that you submit to the Windows Store. Refer to the section, "Compiling shaders for UWP", in the remarks for <strong>D3DCompile2</strong>.?<p>Compiles Microsoft High Level Shader Language (HLSL) code into bytecode for a given target.</p>
        /// </summary>
        /// <param name = "fileNameRef">No documentation.</param>
        /// <param name = "definesRef">No documentation.</param>
        /// <param name = "includeRef">No documentation.</param>
        /// <param name = "entrypointRef">No documentation.</param>
        /// <param name = "targetRef">No documentation.</param>
        /// <param name = "flags1">No documentation.</param>
        /// <param name = "flags2">No documentation.</param>
        /// <param name = "codeOut">No documentation.</param>
        /// <param name = "errorMsgsOut">No documentation.</param>
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??The D3dcompiler_44.dll or later version of the file contains the <strong>D3DCompileFromFile</strong> compiler function.?
        /// </remarks>
        /// <doc-id>hh446872</doc-id>
        /// <unmanaged>HRESULT D3DCompileFromFile([In] const wchar_t* pFileName,[In, Buffer, Optional] const D3D_SHADER_MACRO* pDefines,[In, Optional] ID3DInclude* pInclude,[In] const char* pEntrypoint,[In] const char* pTarget,[In] unsigned int Flags1,[In] unsigned int Flags2,[Out] ID3D10Blob** ppCode,[Out, Optional] ID3D10Blob** ppErrorMsgs)</unmanaged>
        /// <unmanaged-short>D3DCompileFromFile</unmanaged-short>
        public static unsafe SharpDX.Result CompileFromFile(System.String fileNameRef, SharpDX.Direct3D.ShaderMacro[] definesRef, SharpDX.D3DCompiler.Include includeRef, System.String entrypointRef, System.String targetRef, SharpDX.D3DCompiler.ShaderFlags flags1, SharpDX.D3DCompiler.EffectFlags flags2, out SharpDX.Direct3D.Blob codeOut, out SharpDX.Direct3D.Blob errorMsgsOut)
        {
            SharpDX.Direct3D.ShaderMacro.__Native[] definesRef_ = definesRef == null ? null : new SharpDX.Direct3D.ShaderMacro.__Native[definesRef.Length];
            System.IntPtr includeRef_ = System.IntPtr.Zero;
            System.IntPtr entrypointRef_;
            System.IntPtr targetRef_;
            System.IntPtr codeOut_ = System.IntPtr.Zero;
            System.IntPtr errorMsgsOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (definesRef != null)
                for (int i = 0; i < definesRef.Length; ++i)
                    if (definesRef != null)
                        definesRef[i].__MarshalTo(ref (definesRef_)[i]);
            includeRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.D3DCompiler.Include>(includeRef);
            entrypointRef_ = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(entrypointRef);
            targetRef_ = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(targetRef);
            fixed (void *_definesRef = definesRef_)
                fixed (char *fileNameRef_ = fileNameRef)
                    __result__ = D3DCompileFromFile_((void *)fileNameRef_, _definesRef, (void *)includeRef_, (void *)entrypointRef_, (void *)targetRef_, unchecked ((System.Int32)flags1), unchecked ((System.Int32)flags2), &codeOut_, &errorMsgsOut_);
            if (codeOut_ != System.IntPtr.Zero)
                codeOut = new SharpDX.Direct3D.Blob(codeOut_);
            else
                codeOut = null;
            if (errorMsgsOut_ != System.IntPtr.Zero)
                errorMsgsOut = new SharpDX.Direct3D.Blob(errorMsgsOut_);
            else
                errorMsgsOut = null;
            if (definesRef != null)
                for (int i = 0; i < definesRef.Length; ++i)
                    if (definesRef != null)
                        definesRef[i].__MarshalFree(ref (definesRef_)[i]);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(entrypointRef_);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(targetRef_);
            return __result__;
        }

        [System.Runtime.InteropServices.DllImportAttribute("d3dcompiler_47.dll", EntryPoint = "D3DCompileFromFile", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D3DCompileFromFile_(void *param0, void *param1, void *param2, void *param3, void *param4, int param5, int param6, void *param7, void *param8);
        /// <summary>
        /// <p>Preprocesses uncompiled HLSL code.</p>
        /// </summary>
        /// <param name = "srcDataRef"><dd>  <p>A reference to uncompiled shader data; either ASCII HLSL code or a compiled effect.</p> </dd></param>
        /// <param name = "srcDataSize"><dd>  <p>Length of <em>pSrcData</em>.</p> </dd></param>
        /// <param name = "sourceNameRef"><dd>  <p> The name of the file that contains the uncompiled HLSL code.</p> </dd></param>
        /// <param name = "definesRef"><dd>  <p> An array of <c>null</c>-terminated macro definitions (see <strong><see cref = "SharpDX.Direct3D.ShaderMacro"/></strong>).</p> </dd></param>
        /// <param name = "includeRef"><dd>  <p> A reference to an <strong><see cref = "SharpDX.D3DCompiler.Include"/></strong> for handling include files. Setting this to <strong><c>null</c></strong> will cause a compile error if a shader contains a #include. You can pass the <strong>D3D_COMPILE_STANDARD_FILE_INCLUDE</strong> macro, which is a reference to a default include handler. This default include handler includes files that are relative to the current directory and files that are relative to the directory of the initial source file. When you use <strong>D3D_COMPILE_STANDARD_FILE_INCLUDE</strong>, you must specify the source file name in the <em>pSourceName</em> parameter; the compiler will derive the initial relative directory from <em>pSourceName</em>.</p>  <pre>#define D3D_COMPILE_STANDARD_FILE_INCLUDE ((<see cref = "SharpDX.D3DCompiler.Include"/>*)(<see cref = "System.IntPtr"/>)1)</pre>  </dd></param>
        /// <param name = "codeTextOut"><dd>  <p>The address of a <strong>ID3DBlob</strong> that contains the compiled code.</p> </dd></param>
        /// <param name = "errorMsgsOut"><dd>  <p> A reference to an <strong>ID3DBlob</strong> that contains compiler error messages, or <strong><c>null</c></strong> if there were no errors.</p> </dd></param>
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>
        /// <remarks>
        /// <p><strong>D3DPreprocess</strong> outputs #line directives and preserves line numbering of source input so that output line numbering can be properly related to the input source.</p>
        /// </remarks>
        /// <doc-id>dd607332</doc-id>
        /// <unmanaged>HRESULT D3DPreprocess([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[In, Optional] const char* pSourceName,[In, Buffer, Optional] const D3D_SHADER_MACRO* pDefines,[In, Optional] ID3DInclude* pInclude,[Out] ID3D10Blob** ppCodeText,[Out, Optional] ID3D10Blob** ppErrorMsgs)</unmanaged>
        /// <unmanaged-short>D3DPreprocess</unmanaged-short>
        public static unsafe void Preprocess(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, System.String sourceNameRef, SharpDX.Direct3D.ShaderMacro[] definesRef, SharpDX.D3DCompiler.Include includeRef, out SharpDX.Direct3D.Blob codeTextOut, out SharpDX.Direct3D.Blob errorMsgsOut)
        {
            System.IntPtr sourceNameRef_;
            SharpDX.Direct3D.ShaderMacro.__Native[] definesRef_ = definesRef == null ? null : new SharpDX.Direct3D.ShaderMacro.__Native[definesRef.Length];
            System.IntPtr includeRef_ = System.IntPtr.Zero;
            System.IntPtr codeTextOut_ = System.IntPtr.Zero;
            System.IntPtr errorMsgsOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            sourceNameRef_ = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(sourceNameRef);
            if (definesRef != null)
                for (int i = 0; i < definesRef.Length; ++i)
                    if (definesRef != null)
                        definesRef[i].__MarshalTo(ref (definesRef_)[i]);
            includeRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.D3DCompiler.Include>(includeRef);
            fixed (void *_definesRef = definesRef_)
                __result__ = D3DPreprocess_((void *)srcDataRef, (void *)srcDataSize, (void *)sourceNameRef_, _definesRef, (void *)includeRef_, &codeTextOut_, &errorMsgsOut_);
            if (codeTextOut_ != System.IntPtr.Zero)
                codeTextOut = new SharpDX.Direct3D.Blob(codeTextOut_);
            else
                codeTextOut = null;
            if (errorMsgsOut_ != System.IntPtr.Zero)
                errorMsgsOut = new SharpDX.Direct3D.Blob(errorMsgsOut_);
            else
                errorMsgsOut = null;
            System.Runtime.InteropServices.Marshal.FreeHGlobal(sourceNameRef_);
            if (definesRef != null)
                for (int i = 0; i < definesRef.Length; ++i)
                    if (definesRef != null)
                        definesRef[i].__MarshalFree(ref (definesRef_)[i]);
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("d3dcompiler_47.dll", EntryPoint = "D3DPreprocess", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D3DPreprocess_(void *param0, void *param1, void *param2, void *param3, void *param4, void *param5, void *param6);
        /// <summary>
        /// <strong>Note</strong>??You can use this API to develop your Windows Store apps, but you can't use it in apps that you submit to the Windows Store.?<p>Gets shader debug information.</p>
        /// </summary>
        /// <param name = "srcDataRef"><dd>  <p>A reference to source data; either uncompiled or compiled HLSL code.</p> </dd></param>
        /// <param name = "srcDataSize"><dd>  <p>Length of <em>pSrcData</em>.</p> </dd></param>
        /// <param name = "debugInfoOut"><dd>  <p>A reference to a buffer that receives the <strong>ID3DBlob</strong> interface that contains debug information.</p> </dd></param>
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>
        /// <remarks>
        /// <p>Debug information is embedded in the body of the shader after calling <strong>D3DCompile</strong>.</p>
        /// </remarks>
        /// <doc-id>dd607328</doc-id>
        /// <unmanaged>HRESULT D3DGetDebugInfo([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[Out] ID3D10Blob** ppDebugInfo)</unmanaged>
        /// <unmanaged-short>D3DGetDebugInfo</unmanaged-short>
        public static unsafe void GetDebugInfo(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, out SharpDX.Direct3D.Blob debugInfoOut)
        {
            System.IntPtr debugInfoOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = D3DGetDebugInfo_((void *)srcDataRef, (void *)srcDataSize, &debugInfoOut_);
            if (debugInfoOut_ != System.IntPtr.Zero)
                debugInfoOut = new SharpDX.Direct3D.Blob(debugInfoOut_);
            else
                debugInfoOut = null;
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("d3dcompiler_47.dll", EntryPoint = "D3DGetDebugInfo", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D3DGetDebugInfo_(void *param0, void *param1, void *param2);
        /// <summary>
        /// <p>Gets a reference to a reflection interface.</p>
        /// </summary>
        /// <param name = "srcDataRef"><dd>  <p>A reference to source data as compiled HLSL code.</p> </dd></param>
        /// <param name = "srcDataSize"><dd>  <p>Length of <em>pSrcData</em>.</p> </dd></param>
        /// <param name = "interfaceRef"><dd>  <p>The reference <see cref = "System.Guid"/> of the COM interface to use. For example, <strong>IID_ID3D11ShaderReflection</strong>.</p> </dd></param>
        /// <param name = "reflectorOut"><dd>  <p>A reference to a reflection interface.</p> </dd></param>
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>
        /// <remarks>
        /// <p>Shader code contains metadata that can be inspected using the reflection APIs.</p><p>The following code illustrates retrieving a <strong><see cref = "SharpDX.D3DCompiler.ShaderReflection"/></strong> Interface from a shader.</p><pre> pd3dDevice-&gt;CreatePixelShader( pPixelShaderBuffer-&gt;GetBufferPointer(), pPixelShaderBuffer-&gt;GetBufferSize(), g_pPSClassLinkage, &amp;g_pPixelShader ); <see cref = "SharpDX.D3DCompiler.ShaderReflection"/>* pReflector = <c>null</c>; 
        /// D3DReflect( pPixelShaderBuffer-&gt;GetBufferPointer(), pPixelShaderBuffer-&gt;GetBufferSize(),  IID_ID3D11ShaderReflection, (void**) &amp;pReflector);
        /// </pre>
        /// </remarks>
        /// <doc-id>dd607334</doc-id>
        /// <unmanaged>HRESULT D3DReflect([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[In] const GUID&amp; pInterface,[Out] void** ppReflector)</unmanaged>
        /// <unmanaged-short>D3DReflect</unmanaged-short>
        public static unsafe void Reflect(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, System.Guid interfaceRef, out System.IntPtr reflectorOut)
        {
            SharpDX.Result __result__;
            fixed (void *reflectorOut_ = &reflectorOut)
                __result__ = D3DReflect_((void *)srcDataRef, (void *)srcDataSize, &interfaceRef, reflectorOut_);
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("d3dcompiler_47.dll", EntryPoint = "D3DReflect", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D3DReflect_(void *param0, void *param1, void *param2, void *param3);
        /// <summary>
        /// <p>Creates a library-reflection interface from source data that contains an HLSL library of functions. </p><strong>Note</strong>??This function is part of the HLSL shader linking technology that you can use on all Direct3D?11 platforms to create precompiled HLSL functions, package them into libraries, and link them into full shaders at run time.?
        /// </summary>
        /// <param name = "srcDataRef"><dd>  <p>A reference to source data as an HLSL library of functions. </p> </dd></param>
        /// <param name = "srcDataSize"><dd>  <p>The size, in bytes, of the block of memory that <em>pSrcData</em> points to.</p> </dd></param>
        /// <param name = "riid"><dd>  <p>The reference <see cref = "System.Guid"/> of the COM interface to use. For example, <strong>IID_ID3D11LibraryReflection</strong>.</p> </dd></param>
        /// <param name = "reflectorOut"><dd>  <p>A reference to a variable that receives a reference to a library-reflection interface, <strong><see cref = "SharpDX.D3DCompiler.LibraryReflection"/></strong>.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns one of the Direct3D 11 Return Codes. </p></returns>
        /// <doc-id>dn280343</doc-id>
        /// <unmanaged>HRESULT D3DReflectLibrary([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[In] const GUID&amp; riid,[Out] void** ppReflector)</unmanaged>
        /// <unmanaged-short>D3DReflectLibrary</unmanaged-short>
        public static unsafe void ReflectLibrary(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, System.Guid riid, out System.IntPtr reflectorOut)
        {
            SharpDX.Result __result__;
            fixed (void *reflectorOut_ = &reflectorOut)
                __result__ = D3DReflectLibrary_((void *)srcDataRef, (void *)srcDataSize, &riid, reflectorOut_);
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("d3dcompiler_47.dll", EntryPoint = "D3DReflectLibrary", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D3DReflectLibrary_(void *param0, void *param1, void *param2, void *param3);
        /// <summary>
        /// <p>Disassembles compiled HLSL code.</p>
        /// </summary>
        /// <param name = "srcDataRef"><dd>  <p>A reference to source data as compiled HLSL code.</p> </dd></param>
        /// <param name = "srcDataSize"><dd>  <p>Length of <em>pSrcData</em>.</p> </dd></param>
        /// <param name = "flags"><dd>  <p>Flags affecting the behavior of <strong>D3DDisassemble</strong>.  <em>Flags</em> can be a combination of zero or more of the following values. </p> <table> <tr><th>Flag</th><th>Description</th></tr> <tr><td><strong>D3D_DISASM_ENABLE_COLOR_CODE</strong></td><td>Enable the output of color codes.</td></tr> <tr><td><strong>D3D_DISASM_ENABLE_DEFAULT_VALUE_PRINTS</strong></td><td>Enable the output of default values.</td></tr> <tr><td><strong>D3D_DISASM_ENABLE_INSTRUCTION_NUMBERING</strong></td><td>Enable instruction numbering.</td></tr> <tr><td><strong>D3D_DISASM_ENABLE_INSTRUCTION_CYCLE</strong></td><td>No effect.</td></tr> <tr><td><strong>D3D_DISASM_DISABLE_DEBUG_INFO</strong></td><td>Disable debug information.</td></tr> <tr><td><strong>D3D_DISASM_ENABLE_INSTRUCTION_OFFSET</strong></td><td>Enable instruction offsets.</td></tr> <tr><td><strong>D3D_DISASM_INSTRUCTION_ONLY</strong></td><td>Disassemble instructions only.</td></tr> <tr><td><strong> D3D_DISASM_PRINT_HEX_LITERALS</strong></td><td>Use hex symbols in disassemblies.</td></tr> </table> <p>?</p> </dd></param>
        /// <param name = "szComments"><dd>  <p>The comment string at the top of the shader that identifies the shader constants and variables.</p> </dd></param>
        /// <param name = "disassemblyOut"><dd>  <p>A reference to a buffer that receives the <strong>ID3DBlob</strong> interface that accesses assembly text.</p> </dd></param>
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>
        /// <doc-id>dd607326</doc-id>
        /// <unmanaged>HRESULT D3DDisassemble([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[In] unsigned int Flags,[In, Optional] const char* szComments,[Out] ID3D10Blob** ppDisassembly)</unmanaged>
        /// <unmanaged-short>D3DDisassemble</unmanaged-short>
        public static unsafe void Disassemble(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, SharpDX.D3DCompiler.DisassemblyFlags flags, System.String szComments, out SharpDX.Direct3D.Blob disassemblyOut)
        {
            System.IntPtr szComments_;
            System.IntPtr disassemblyOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            szComments_ = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(szComments);
            __result__ = D3DDisassemble_((void *)srcDataRef, (void *)srcDataSize, unchecked ((System.Int32)flags), (void *)szComments_, &disassemblyOut_);
            if (disassemblyOut_ != System.IntPtr.Zero)
                disassemblyOut = new SharpDX.Direct3D.Blob(disassemblyOut_);
            else
                disassemblyOut = null;
            System.Runtime.InteropServices.Marshal.FreeHGlobal(szComments_);
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("d3dcompiler_47.dll", EntryPoint = "D3DDisassemble", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D3DDisassemble_(void *param0, void *param1, int param2, void *param3, void *param4);
        /// <summary>
        /// <p>Disassembles a specific region of compiled Microsoft High Level Shader Language (HLSL) code.</p>
        /// </summary>
        /// <param name = "srcDataRef"><dd> <p>A reference to compiled shader data.</p> </dd></param>
        /// <param name = "srcDataSize"><dd> <p>The size, in bytes, of the block of memory that <em>pSrcData</em> points to.</p> </dd></param>
        /// <param name = "flags"><dd> <p>A combination of zero or more of the following flags that are combined by using a bitwise <strong>OR</strong> operation. The resulting value specifies how <strong>D3DDisassembleRegion</strong> disassembles the compiled shader data.</p> <table> <tr><th>Flag</th><th>Description</th></tr> <tr><td>D3D_DISASM_ENABLE_COLOR_CODE (0x01)</td><td>Enable the output of color codes.</td></tr> <tr><td>D3D_DISASM_ENABLE_DEFAULT_VALUE_PRINTS (0x02)</td><td>Enable the output of default values.</td></tr> <tr><td>D3D_DISASM_ENABLE_INSTRUCTION_NUMBERING (0x04)</td><td>Enable instruction numbering.</td></tr> <tr><td>D3D_DISASM_ENABLE_INSTRUCTION_CYCLE (0x08)</td><td>No effect.</td></tr> <tr><td>D3D_DISASM_DISABLE_DEBUG_INFO (0x10)</td><td>Disable the output of debug information.</td></tr> <tr><td>D3D_DISASM_ENABLE_INSTRUCTION_OFFSET (0x20)</td><td>Enable the output of instruction offsets.</td></tr> <tr><td>D3D_DISASM_INSTRUCTION_ONLY (0x40)</td><td>This flag has no effect in <strong>D3DDisassembleRegion</strong>. Cycle information comes from the trace; therefore, cycle information is available only in <strong>D3DDisassemble11Trace</strong>'s trace disassembly.</td></tr> </table> <p>?</p> </dd></param>
        /// <param name = "szComments"><dd> <p>A reference to a constant null-terminated string at the top of the shader that identifies the shader constants and variables.</p> </dd></param>
        /// <param name = "startByteOffset"><dd> <p>The number of bytes offset into the compiled shader data where <strong>D3DDisassembleRegion</strong> starts the disassembly.</p> </dd></param>
        /// <param name = "numInsts"><dd> <p>The number of instructions to disassemble.</p> </dd></param>
        /// <param name = "finishByteOffsetRef"><dd> <p>A reference to a variable that receives the number of bytes offset into the compiled shader data where <strong>D3DDisassembleRegion</strong> finishes the disassembly.</p> </dd></param>
        /// <param name = "disassemblyOut"><dd> <p>A reference to a buffer that receives the <strong>ID3DBlob</strong> interface that accesses the disassembled HLSL code.</p> </dd></param>
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??The D3dcompiler_44.dll or later version of the file contains the <strong>D3DDisassembleRegion</strong> compiler function.?
        /// </remarks>
        /// <doc-id>hh706344</doc-id>
        /// <unmanaged>HRESULT D3DDisassembleRegion([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[In] unsigned int Flags,[In, Optional] const char* szComments,[In] SIZE_T StartByteOffset,[In] SIZE_T NumInsts,[Out, Optional] SIZE_T* pFinishByteOffset,[Out] ID3D10Blob** ppDisassembly)</unmanaged>
        /// <unmanaged-short>D3DDisassembleRegion</unmanaged-short>
        public static unsafe void DisassembleRegion(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, System.Int32 flags, System.String szComments, SharpDX.PointerSize startByteOffset, SharpDX.PointerSize numInsts, out SharpDX.PointerSize finishByteOffsetRef, out SharpDX.Direct3D.Blob disassemblyOut)
        {
            System.IntPtr szComments_;
            finishByteOffsetRef = default (SharpDX.PointerSize);
            System.IntPtr disassemblyOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            szComments_ = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(szComments);
            fixed (void *finishByteOffsetRef_ = &finishByteOffsetRef)
                __result__ = D3DDisassembleRegion_((void *)srcDataRef, (void *)srcDataSize, flags, (void *)szComments_, (void *)startByteOffset, (void *)numInsts, finishByteOffsetRef_, &disassemblyOut_);
            if (disassemblyOut_ != System.IntPtr.Zero)
                disassemblyOut = new SharpDX.Direct3D.Blob(disassemblyOut_);
            else
                disassemblyOut = null;
            System.Runtime.InteropServices.Marshal.FreeHGlobal(szComments_);
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("d3dcompiler_47.dll", EntryPoint = "D3DDisassembleRegion", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D3DDisassembleRegion_(void *param0, void *param1, int param2, void *param3, void *param4, void *param5, void *param6, void *param7);
        /// <summary>
        /// <p>Creates a linker interface. </p><strong>Note</strong>??This function is part of the HLSL shader linking technology that you can use on all Direct3D?11 platforms to create precompiled HLSL functions, package them into libraries, and link them into full shaders at run time.?
        /// </summary>
        /// <param name = "linkerOut"><dd>  <p>A reference to a variable that receives a reference to the <strong><see cref = "SharpDX.D3DCompiler.Linker"/></strong> interface that is used to link a shader module.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns one of the Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??The D3dcompiler_47.dll or later version of the DLL contains the <strong>D3DCreateLinker</strong> function.?
        /// </remarks>
        /// <doc-id>dn280341</doc-id>
        /// <unmanaged>HRESULT D3DCreateLinker([Out, Fast] ID3D11Linker** ppLinker)</unmanaged>
        /// <unmanaged-short>D3DCreateLinker</unmanaged-short>
        public static unsafe void CreateLinker(SharpDX.D3DCompiler.Linker linkerOut)
        {
            System.IntPtr linkerOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = D3DCreateLinker_(&linkerOut_);
            (linkerOut).NativePointer = linkerOut_;
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("d3dcompiler_47.dll", EntryPoint = "D3DCreateLinker", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D3DCreateLinker_(void *param0);
        /// <summary>
        /// <p>Creates a shader module interface from source data for the shader module. </p><strong>Note</strong>??This function is part of the HLSL shader linking technology that you can use on all Direct3D?11 platforms to create precompiled HLSL functions, package them into libraries, and link them into full shaders at run time.?
        /// </summary>
        /// <param name = "srcDataRef"><dd>  <p>A reference to the source data for the shader module.</p> </dd></param>
        /// <param name = "cbSrcDataSize"><dd>  <p>The size, in bytes, of the block of memory that <em>pSrcData</em> points to.</p> </dd></param>
        /// <param name = "moduleOut"><dd>  <p>A reference to a variable that receives a reference to the <strong><see cref = "SharpDX.D3DCompiler.Module"/></strong> interface that is used for shader resource re-binding.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns one of the Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??The D3dcompiler_47.dll or later version of the DLL contains the <strong>D3DLoadModule</strong> function.?
        /// </remarks>
        /// <doc-id>dn280342</doc-id>
        /// <unmanaged>HRESULT D3DLoadModule([In] const void* pSrcData,[In] SIZE_T cbSrcDataSize,[Out, Fast] ID3D11Module** ppModule)</unmanaged>
        /// <unmanaged-short>D3DLoadModule</unmanaged-short>
        public static unsafe SharpDX.Result LoadModule(System.IntPtr srcDataRef, SharpDX.PointerSize cbSrcDataSize, SharpDX.D3DCompiler.Module moduleOut)
        {
            System.IntPtr moduleOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = D3DLoadModule_((void *)srcDataRef, (void *)cbSrcDataSize, &moduleOut_);
            (moduleOut).NativePointer = moduleOut_;
            return __result__;
        }

        [System.Runtime.InteropServices.DllImportAttribute("d3dcompiler_47.dll", EntryPoint = "D3DLoadModule", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D3DLoadModule_(void *param0, void *param1, void *param2);
        /// <summary>
        /// <p>Creates a function-linking-graph interface. </p><strong>Note</strong>??This function is part of the HLSL shader linking technology that you can use on all Direct3D?11 platforms to create precompiled HLSL functions, package them into libraries, and link them into full shaders at run time.?
        /// </summary>
        /// <param name = "uFlags"><dd>  <p>Reserved</p> </dd></param>
        /// <param name = "functionLinkingGraphOut"><dd>  <p>A reference to a variable that receives a reference to the <strong><see cref = "SharpDX.D3DCompiler.FunctionLinkingGraph"/></strong> interface that is used for constructing shaders that consist of a sequence of precompiled function calls.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns one of the Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??The D3dcompiler_47.dll or later version of the DLL contains the <strong>D3DCreateFunctionLinkingGraph</strong> function.?
        /// </remarks>
        /// <doc-id>dn280340</doc-id>
        /// <unmanaged>HRESULT D3DCreateFunctionLinkingGraph([In] unsigned int uFlags,[Out, Fast] ID3D11FunctionLinkingGraph** ppFunctionLinkingGraph)</unmanaged>
        /// <unmanaged-short>D3DCreateFunctionLinkingGraph</unmanaged-short>
        public static unsafe void CreateFunctionLinkingGraph(System.Int32 uFlags, SharpDX.D3DCompiler.FunctionLinkingGraph functionLinkingGraphOut)
        {
            System.IntPtr functionLinkingGraphOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = D3DCreateFunctionLinkingGraph_(uFlags, &functionLinkingGraphOut_);
            (functionLinkingGraphOut).NativePointer = functionLinkingGraphOut_;
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("d3dcompiler_47.dll", EntryPoint = "D3DCreateFunctionLinkingGraph", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D3DCreateFunctionLinkingGraph_(int param0, void *param1);
        /// <summary>
        /// <p>Retrieves the byte offsets for instructions within a section of shader code.</p>
        /// </summary>
        /// <param name = "srcDataRef"><dd> <p>A reference to the compiled shader data.</p> </dd></param>
        /// <param name = "srcDataSize"><dd> <p>The size, in bytes, of the block of memory that <em>pSrcData</em> points to.</p> </dd></param>
        /// <param name = "flags"><dd> <p>A combination of the following flags that are combined by using a bitwise <strong>OR</strong> operation. The resulting value specifies how <strong>D3DGetTraceInstructionOffsets</strong> retrieves the instruction offsets.</p> <table> <tr><th>Flag</th><th>Description</th></tr> <tr><td>D3D_GET_INST_OFFSETS_INCLUDE_NON_EXECUTABLE (0x01)</td><td>Include non-executable code in the retrieved information.</td></tr> </table> <p>?</p> </dd></param>
        /// <param name = "startInstIndex"><dd> <p>The index of the instruction in the compiled shader data for which <strong>D3DGetTraceInstructionOffsets</strong> starts to retrieve the byte offsets.</p> </dd></param>
        /// <param name = "numInsts"><dd> <p>The number of instructions for which <strong>D3DGetTraceInstructionOffsets</strong> retrieves the byte offsets.</p> </dd></param>
        /// <param name = "totalInstsRef"><dd> <p>A reference to a variable that receives the total number of instructions in the section of shader code.</p> </dd></param>
        /// <returns><dd> <p>A reference to a variable that receives the actual number of offsets.</p> </dd></returns>
        /// <remarks>
        /// <p>A new kind of Microsoft High Level Shader Language (HLSL) debugging information from a program database (PDB) file uses instruction-byte offsets within a shader blob (arbitrary-length data buffer). You use <strong>D3DGetTraceInstructionOffsets</strong> to translate to and from instruction indexes.</p><strong>Note</strong>??The D3dcompiler_44.dll or later version of the file contains the <strong>D3DGetTraceInstructionOffsets</strong> compiler function.?
        /// </remarks>
        /// <doc-id>hh446875</doc-id>
        /// <unmanaged>HRESULT D3DGetTraceInstructionOffsets([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[In] unsigned int Flags,[In] SIZE_T StartInstIndex,[In] SIZE_T NumInsts,[Out] SIZE_T* pOffsets,[Out] SIZE_T* pTotalInsts)</unmanaged>
        /// <unmanaged-short>D3DGetTraceInstructionOffsets</unmanaged-short>
        public static unsafe SharpDX.PointerSize GetTraceInstructionOffsets(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, System.Int32 flags, SharpDX.PointerSize startInstIndex, SharpDX.PointerSize numInsts, out SharpDX.PointerSize totalInstsRef)
        {
            SharpDX.PointerSize offsetsRef;
            totalInstsRef = default (SharpDX.PointerSize);
            SharpDX.Result __result__;
            fixed (void *totalInstsRef_ = &totalInstsRef)
                __result__ = D3DGetTraceInstructionOffsets_((void *)srcDataRef, (void *)srcDataSize, flags, (void *)startInstIndex, (void *)numInsts, &offsetsRef, totalInstsRef_);
            __result__.CheckError();
            return offsetsRef;
        }

        [System.Runtime.InteropServices.DllImportAttribute("d3dcompiler_47.dll", EntryPoint = "D3DGetTraceInstructionOffsets", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D3DGetTraceInstructionOffsets_(void *param0, void *param1, int param2, void *param3, void *param4, void *param5, void *param6);
        /// <summary>
        /// <strong>Note</strong>??<strong>D3DGetInputSignatureBlob</strong> may be altered or unavailable for releases after Windows?8.1. Instead use <strong>D3DGetBlobPart</strong> with the <strong>D3D_BLOB_INPUT_SIGNATURE_BLOB</strong> value.?<p>Gets the input signature from a compilation result.</p>
        /// </summary>
        /// <param name = "srcDataRef">No documentation.</param>
        /// <param name = "srcDataSize">No documentation.</param>
        /// <param name = "signatureBlobOut">No documentation.</param>
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>
        /// <doc-id>dd607330</doc-id>
        /// <unmanaged>HRESULT D3DGetInputSignatureBlob([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[Out] ID3D10Blob** ppSignatureBlob)</unmanaged>
        /// <unmanaged-short>D3DGetInputSignatureBlob</unmanaged-short>
        public static unsafe SharpDX.Result GetInputSignatureBlob(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, out SharpDX.Direct3D.Blob signatureBlobOut)
        {
            System.IntPtr signatureBlobOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = D3DGetInputSignatureBlob_((void *)srcDataRef, (void *)srcDataSize, &signatureBlobOut_);
            if (signatureBlobOut_ != System.IntPtr.Zero)
                signatureBlobOut = new SharpDX.Direct3D.Blob(signatureBlobOut_);
            else
                signatureBlobOut = null;
            return __result__;
        }

        [System.Runtime.InteropServices.DllImportAttribute("d3dcompiler_47.dll", EntryPoint = "D3DGetInputSignatureBlob", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D3DGetInputSignatureBlob_(void *param0, void *param1, void *param2);
        /// <summary>
        /// <strong>Note</strong>??<strong>D3DGetOutputSignatureBlob</strong> may be altered or unavailable for releases after Windows?8.1. Instead use <strong>D3DGetBlobPart</strong> with the <strong>D3D_BLOB_OUTPUT_SIGNATURE_BLOB</strong> value.?<p>Gets the output signature from a compilation result.</p>
        /// </summary>
        /// <param name = "srcDataRef">No documentation.</param>
        /// <param name = "srcDataSize">No documentation.</param>
        /// <param name = "signatureBlobOut">No documentation.</param>
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>
        /// <doc-id>dd607331</doc-id>
        /// <unmanaged>HRESULT D3DGetOutputSignatureBlob([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[Out] ID3D10Blob** ppSignatureBlob)</unmanaged>
        /// <unmanaged-short>D3DGetOutputSignatureBlob</unmanaged-short>
        public static unsafe SharpDX.Result GetOutputSignatureBlob(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, out SharpDX.Direct3D.Blob signatureBlobOut)
        {
            System.IntPtr signatureBlobOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = D3DGetOutputSignatureBlob_((void *)srcDataRef, (void *)srcDataSize, &signatureBlobOut_);
            if (signatureBlobOut_ != System.IntPtr.Zero)
                signatureBlobOut = new SharpDX.Direct3D.Blob(signatureBlobOut_);
            else
                signatureBlobOut = null;
            return __result__;
        }

        [System.Runtime.InteropServices.DllImportAttribute("d3dcompiler_47.dll", EntryPoint = "D3DGetOutputSignatureBlob", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D3DGetOutputSignatureBlob_(void *param0, void *param1, void *param2);
        /// <summary>
        /// <strong>Note</strong>??<strong>D3DGetInputAndOutputSignatureBlob</strong> may be altered or unavailable for releases after Windows?8.1. Instead use <strong>D3DGetBlobPart</strong> with the <strong>D3D_BLOB_INPUT_AND_OUTPUT_SIGNATURE_BLOB</strong> value.?<p>Gets the input and output signatures from a compilation result.</p>
        /// </summary>
        /// <param name = "srcDataRef">No documentation.</param>
        /// <param name = "srcDataSize">No documentation.</param>
        /// <param name = "signatureBlobOut">No documentation.</param>
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>
        /// <doc-id>dd607329</doc-id>
        /// <unmanaged>HRESULT D3DGetInputAndOutputSignatureBlob([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[Out] ID3D10Blob** ppSignatureBlob)</unmanaged>
        /// <unmanaged-short>D3DGetInputAndOutputSignatureBlob</unmanaged-short>
        public static unsafe SharpDX.Result GetInputAndOutputSignatureBlob(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, out SharpDX.Direct3D.Blob signatureBlobOut)
        {
            System.IntPtr signatureBlobOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = D3DGetInputAndOutputSignatureBlob_((void *)srcDataRef, (void *)srcDataSize, &signatureBlobOut_);
            if (signatureBlobOut_ != System.IntPtr.Zero)
                signatureBlobOut = new SharpDX.Direct3D.Blob(signatureBlobOut_);
            else
                signatureBlobOut = null;
            return __result__;
        }

        [System.Runtime.InteropServices.DllImportAttribute("d3dcompiler_47.dll", EntryPoint = "D3DGetInputAndOutputSignatureBlob", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D3DGetInputAndOutputSignatureBlob_(void *param0, void *param1, void *param2);
        /// <summary>
        /// <p>Removes unwanted blobs from a compilation result.</p>
        /// </summary>
        /// <param name = "shaderBytecodeRef"><dd>  <p>A reference to source data as compiled HLSL code.</p> </dd></param>
        /// <param name = "bytecodeLength"><dd>  <p>Length of <em>pSrcData</em>.</p> </dd></param>
        /// <param name = "uStripFlags"><dd>  <p>Strip flag options, represented by <strong><see cref = "SharpDX.D3DCompiler.StripFlags"/></strong>.</p> </dd></param>
        /// <param name = "strippedBlobOut"><dd>  <p>A reference to a variable that receives a reference to the <strong>ID3DBlob</strong> interface that you can use to access the unwanted stripped out shader code.</p> </dd></param>
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>
        /// <doc-id>dd607335</doc-id>
        /// <unmanaged>HRESULT D3DStripShader([In, Buffer] const void* pShaderBytecode,[In] SIZE_T BytecodeLength,[In] unsigned int uStripFlags,[Out] ID3D10Blob** ppStrippedBlob)</unmanaged>
        /// <unmanaged-short>D3DStripShader</unmanaged-short>
        public static unsafe SharpDX.Result StripShader(System.IntPtr shaderBytecodeRef, SharpDX.PointerSize bytecodeLength, SharpDX.D3DCompiler.StripFlags uStripFlags, out SharpDX.Direct3D.Blob strippedBlobOut)
        {
            System.IntPtr strippedBlobOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = D3DStripShader_((void *)shaderBytecodeRef, (void *)bytecodeLength, unchecked ((System.Int32)uStripFlags), &strippedBlobOut_);
            if (strippedBlobOut_ != System.IntPtr.Zero)
                strippedBlobOut = new SharpDX.Direct3D.Blob(strippedBlobOut_);
            else
                strippedBlobOut = null;
            return __result__;
        }

        [System.Runtime.InteropServices.DllImportAttribute("d3dcompiler_47.dll", EntryPoint = "D3DStripShader", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D3DStripShader_(void *param0, void *param1, int param2, void *param3);
        /// <summary>
        /// <p>Retrieves a specific part from a compilation result.</p>
        /// </summary>
        /// <param name = "srcDataRef"><dd>  <p>A reference to uncompiled shader data; either ASCII HLSL code or a compiled effect.</p> </dd></param>
        /// <param name = "srcDataSize"><dd>  <p>Length of uncompiled shader data that <em>pSrcData</em> points to.</p> </dd></param>
        /// <param name = "part"><dd>  <p>A <strong><see cref = "SharpDX.D3DCompiler.ShaderBytecodePart"/></strong>-typed value that specifies the part of the buffer to retrieve.</p> </dd></param>
        /// <param name = "flags"><dd>  <p>Flags that indicate how to retrieve the blob part. Currently, no flags are defined.</p> </dd></param>
        /// <param name = "partOut"><dd>  <p>The address of a reference to the <strong>ID3DBlob</strong> interface that is used to retrieve the specified part of the buffer.</p> </dd></param>
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>
        /// <remarks>
        /// <p><strong>D3DGetBlobPart</strong> retrieves the part of a blob (arbitrary length data buffer) that contains the type of data that the  <em>Part</em> parameter specifies.</p>
        /// </remarks>
        /// <doc-id>ff728674</doc-id>
        /// <unmanaged>HRESULT D3DGetBlobPart([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[In] D3D_BLOB_PART Part,[In] unsigned int Flags,[Out] ID3D10Blob** ppPart)</unmanaged>
        /// <unmanaged-short>D3DGetBlobPart</unmanaged-short>
        public static unsafe void GetBlobPart(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, SharpDX.D3DCompiler.ShaderBytecodePart part, System.Int32 flags, out SharpDX.Direct3D.Blob partOut)
        {
            System.IntPtr partOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = D3DGetBlobPart_((void *)srcDataRef, (void *)srcDataSize, unchecked ((System.Int32)part), flags, &partOut_);
            if (partOut_ != System.IntPtr.Zero)
                partOut = new SharpDX.Direct3D.Blob(partOut_);
            else
                partOut = null;
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("d3dcompiler_47.dll", EntryPoint = "D3DGetBlobPart", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D3DGetBlobPart_(void *param0, void *param1, int param2, int param3, void *param4);
        /// <summary>
        /// <p>Sets information in a compilation result.</p>
        /// </summary>
        /// <param name = "srcDataRef"><dd>  <p>A reference to compiled shader data.</p> </dd></param>
        /// <param name = "srcDataSize"><dd>  <p>The length of the compiled shader data that <em>pSrcData</em> points to.</p> </dd></param>
        /// <param name = "part"><dd>  <p>A <strong><see cref = "SharpDX.D3DCompiler.ShaderBytecodePart"/></strong>-typed value that specifies the part to set. Currently, you can update only private data; that is, <strong>D3DSetBlobPart</strong> currently only supports the <strong>D3D_BLOB_PRIVATE_DATA</strong> value.</p> </dd></param>
        /// <param name = "flags"><dd>  <p>Flags that indicate how to set the blob part. Currently, no flags are defined; therefore, set to zero.</p> </dd></param>
        /// <param name = "partRef"><dd>  <p>A reference to data to set in the compilation result.</p> </dd></param>
        /// <param name = "partSize"><dd>  <p>The length of the data that <em>pPart</em> points to.</p> </dd></param>
        /// <param name = "newShaderOut"><dd>  <p>A reference to a buffer that receives the <strong>ID3DBlob</strong> interface for the new shader in which the new part data is set.</p> </dd></param>
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>
        /// <remarks>
        /// <p><strong>D3DSetBlobPart</strong> modifies data in a compiled shader.  Currently, <strong>D3DSetBlobPart</strong> can update only the private data in a compiled shader. You can use  <strong>D3DSetBlobPart</strong> to attach arbitrary uninterpreted data to a compiled shader.</p><strong>Note</strong>??The D3dcompiler_44.dll or later version of the file contains the <strong>D3DSetBlobPart</strong> compiler function.?
        /// </remarks>
        /// <doc-id>hh446880</doc-id>
        /// <unmanaged>HRESULT D3DSetBlobPart([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[In] D3D_BLOB_PART Part,[In] unsigned int Flags,[In, Buffer] const void* pPart,[In] SIZE_T PartSize,[Out] ID3D10Blob** ppNewShader)</unmanaged>
        /// <unmanaged-short>D3DSetBlobPart</unmanaged-short>
        public static unsafe void SetBlobPart(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, SharpDX.D3DCompiler.ShaderBytecodePart part, System.Int32 flags, System.IntPtr partRef, SharpDX.PointerSize partSize, out SharpDX.Direct3D.Blob newShaderOut)
        {
            System.IntPtr newShaderOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = D3DSetBlobPart_((void *)srcDataRef, (void *)srcDataSize, unchecked ((System.Int32)part), flags, (void *)partRef, (void *)partSize, &newShaderOut_);
            if (newShaderOut_ != System.IntPtr.Zero)
                newShaderOut = new SharpDX.Direct3D.Blob(newShaderOut_);
            else
                newShaderOut = null;
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("d3dcompiler_47.dll", EntryPoint = "D3DSetBlobPart", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D3DSetBlobPart_(void *param0, void *param1, int param2, int param3, void *param4, void *param5, void *param6);
        /// <summary>
        /// <p>Creates a buffer.</p>
        /// </summary>
        /// <param name = "size"><dd>  <p>Number of bytes in the blob.</p> </dd></param>
        /// <param name = "blobOut"><dd>  <p>The address of a reference to the <strong>ID3DBlob</strong> interface that is used to retrieve the buffer.</p> </dd></param>
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>
        /// <remarks>
        /// <p>The latest D3dcompiler_nn.dll contains the <strong>D3DCreateBlob</strong> compiler function. Therefore, you are no longer required to create and use an arbitrary length data buffer by using the  <strong>D3D10CreateBlob</strong> function that is contained in D3d10.dll.</p>
        /// </remarks>
        /// <doc-id>ff728672</doc-id>
        /// <unmanaged>HRESULT D3DCreateBlob([In] SIZE_T Size,[Out] ID3D10Blob** ppBlob)</unmanaged>
        /// <unmanaged-short>D3DCreateBlob</unmanaged-short>
        public static unsafe void CreateBlob(SharpDX.PointerSize size, out SharpDX.Direct3D.Blob blobOut)
        {
            System.IntPtr blobOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = D3DCreateBlob_((void *)size, &blobOut_);
            if (blobOut_ != System.IntPtr.Zero)
                blobOut = new SharpDX.Direct3D.Blob(blobOut_);
            else
                blobOut = null;
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("d3dcompiler_47.dll", EntryPoint = "D3DCreateBlob", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D3DCreateBlob_(void *param0, void *param1);
        /// <summary>
        /// <strong>Note</strong>??You can use this API to develop your Windows Store apps, but you can't use it in apps that you submit to the Windows Store.?<p>Compresses a set of shaders into a more compact form. </p>
        /// </summary>
        /// <param name = "uNumShaders"><dd>  <p>The number of shaders to compress.</p> </dd></param>
        /// <param name = "shaderDataRef"><dd>  <p>An array of <strong><see cref = "SharpDX.D3DCompiler.ShaderData"/></strong> structures that describe the set of shaders to compress.</p> </dd></param>
        /// <param name = "uFlags"><dd>  <p>Flags that indicate how to compress the shaders. Currently, only the  D3D_COMPRESS_SHADER_KEEP_ALL_PARTS (0x00000001) flag is defined.</p> </dd></param>
        /// <param name = "compressedDataOut"><dd>  <p>The address of a reference to the <strong>ID3DBlob</strong> interface that is used to retrieve the compressed shader data.</p> </dd></param>
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>
        /// <doc-id>ff728671</doc-id>
        /// <unmanaged>HRESULT D3DCompressShaders([In] unsigned int uNumShaders,[In, Buffer] D3D_SHADER_DATA* pShaderData,[In] unsigned int uFlags,[Out] ID3D10Blob** ppCompressedData)</unmanaged>
        /// <unmanaged-short>D3DCompressShaders</unmanaged-short>
        public static unsafe void CompressShaders(System.Int32 uNumShaders, SharpDX.D3DCompiler.ShaderData[] shaderDataRef, System.Int32 uFlags, out SharpDX.Direct3D.Blob compressedDataOut)
        {
            SharpDX.D3DCompiler.ShaderData.__Native[] shaderDataRef_ = new SharpDX.D3DCompiler.ShaderData.__Native[shaderDataRef.Length];
            System.IntPtr compressedDataOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            for (int i = 0; i < shaderDataRef.Length; ++i)
                shaderDataRef[i].__MarshalTo(ref (shaderDataRef_)[i]);
            fixed (void *_shaderDataRef = shaderDataRef_)
                __result__ = D3DCompressShaders_(uNumShaders, _shaderDataRef, uFlags, &compressedDataOut_);
            if (compressedDataOut_ != System.IntPtr.Zero)
                compressedDataOut = new SharpDX.Direct3D.Blob(compressedDataOut_);
            else
                compressedDataOut = null;
            for (int i = 0; i < shaderDataRef.Length; ++i)
                shaderDataRef[i].__MarshalFree(ref (shaderDataRef_)[i]);
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("d3dcompiler_47.dll", EntryPoint = "D3DCompressShaders", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D3DCompressShaders_(int param0, void *param1, int param2, void *param3);
        /// <summary>
        /// <strong>Note</strong>??You can use this API to develop your Windows Store apps, but you can't use it in apps that you submit to the Windows Store.?<p>Decompresses one or more shaders from a compressed set. </p>
        /// </summary>
        /// <param name = "srcDataRef"><dd>  <p>A reference to uncompiled shader data; either ASCII HLSL code or a compiled effect.</p> </dd></param>
        /// <param name = "srcDataSize"><dd>  <p>Length of uncompiled shader data that <em>pSrcData</em> points to.</p> </dd></param>
        /// <param name = "uNumShaders"><dd>  <p>The number of shaders to decompress.</p> </dd></param>
        /// <param name = "uStartIndex"><dd>  <p>The index of the first shader to decompress.</p> </dd></param>
        /// <param name = "indicesRef"><dd>  <p>An array of indexes that represent the shaders to decompress.</p> </dd></param>
        /// <param name = "uFlags"><dd>  <p>Flags that indicate how to decompress. Currently, no flags are defined.</p> </dd></param>
        /// <param name = "shadersOut"><dd>  <p>The address of a reference to the <strong>ID3DBlob</strong> interface that is used to retrieve the decompressed shader data.</p> </dd></param>
        /// <param name = "totalShadersRef"><dd>  <p>A reference to a variable that receives the total number of shaders that  <strong>D3DDecompressShaders</strong> decompressed.</p> </dd></param>
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>
        /// <doc-id>ff728673</doc-id>
        /// <unmanaged>HRESULT D3DDecompressShaders([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[In] unsigned int uNumShaders,[In] unsigned int uStartIndex,[In, Buffer, Optional] unsigned int* pIndices,[In] unsigned int uFlags,[Out, Buffer] ID3D10Blob** ppShaders,[Out, Optional] unsigned int* pTotalShaders)</unmanaged>
        /// <unmanaged-short>D3DDecompressShaders</unmanaged-short>
        public static unsafe void DecompressShaders(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, System.Int32 uNumShaders, System.Int32 uStartIndex, System.Int32[] indicesRef, System.Int32 uFlags, SharpDX.Direct3D.Blob[] shadersOut, out System.Int32 totalShadersRef)
        {
            System.IntPtr*shadersOut_;
            shadersOut_ = (System.IntPtr*)0;
            {
                System.IntPtr*_shadersOut = stackalloc System.IntPtr[shadersOut.Length];
                shadersOut_ = _shadersOut;
            }

            SharpDX.Result __result__;
            fixed (void *totalShadersRef_ = &totalShadersRef)
                fixed (void *indicesRef_ = indicesRef)
                    __result__ = D3DDecompressShaders_((void *)srcDataRef, (void *)srcDataSize, uNumShaders, uStartIndex, indicesRef_, uFlags, (void *)shadersOut_, totalShadersRef_);
            for (int i = 0; i < shadersOut.Length; ++i)
                if ((shadersOut_)[i] != System.IntPtr.Zero)
                    shadersOut[i] = new SharpDX.Direct3D.Blob((shadersOut_)[i]);
                else
                    shadersOut[i] = null;
            __result__.CheckError();
        }

        [System.Runtime.InteropServices.DllImportAttribute("d3dcompiler_47.dll", EntryPoint = "D3DDecompressShaders", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        private unsafe static extern int D3DDecompressShaders_(void *param0, void *param1, int param2, int param3, void *param4, int param5, void *param6, void *param7);
    }

    /// <summary>
    /// Functions
    /// </summary>
    static partial class D3DCommon
    {
    }
}